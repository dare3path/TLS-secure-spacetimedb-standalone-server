* this is work in progress, even though it works so far (rust client, some cli commands)

diff --git a/Cargo.lock b/Cargo.lock
index 5b15f068..75acd9a3 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -194,6 +194,12 @@ dependencies = [
  "derive_arbitrary",
 ]
 
+[[package]]
+name = "arc-swap"
+version = "1.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "69f7f8c3906b62b754cd5326047894316021dcfe5a194c8ea52bdd94934a3457"
+
 [[package]]
 name = "arrayref"
 version = "0.3.9"
@@ -292,6 +298,29 @@ version = "1.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26"
 
+[[package]]
+name = "aws-lc-rs"
+version = "1.13.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "19b756939cb2f8dc900aa6dcd505e6e2428e9cae7ff7b028c49e3946efa70878"
+dependencies = [
+ "aws-lc-sys",
+ "zeroize",
+]
+
+[[package]]
+name = "aws-lc-sys"
+version = "0.28.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b9f7720b74ed28ca77f90769a71fd8c637a0137f6fae4ae947e1050229cff57f"
+dependencies = [
+ "bindgen",
+ "cc",
+ "cmake",
+ "dunce",
+ "fs_extra",
+]
+
 [[package]]
 name = "axum"
 version = "0.7.7"
@@ -370,6 +399,28 @@ dependencies = [
  "tracing",
 ]
 
+[[package]]
+name = "axum-server"
+version = "0.7.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "495c05f60d6df0093e8fb6e74aa5846a0ad06abaf96d76166283720bf740f8ab"
+dependencies = [
+ "arc-swap",
+ "bytes",
+ "fs-err 3.1.0",
+ "http 1.1.0",
+ "http-body 1.0.1",
+ "hyper 1.5.0",
+ "hyper-util",
+ "pin-project-lite",
+ "rustls",
+ "rustls-pemfile 2.2.0",
+ "rustls-pki-types",
+ "tokio",
+ "tokio-rustls",
+ "tower-service",
+]
+
 [[package]]
 name = "backtrace"
 version = "0.3.74"
@@ -427,6 +478,29 @@ dependencies = [
  "serde",
 ]
 
+[[package]]
+name = "bindgen"
+version = "0.69.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "271383c67ccabffb7381723dea0672a673f292304fcb45c01cc648c7a8d58088"
+dependencies = [
+ "bitflags 2.6.0",
+ "cexpr",
+ "clang-sys",
+ "itertools 0.12.1",
+ "lazy_static",
+ "lazycell",
+ "log",
+ "prettyplease",
+ "proc-macro2",
+ "quote",
+ "regex",
+ "rustc-hash 1.1.0",
+ "shlex",
+ "syn 2.0.87",
+ "which",
+]
+
 [[package]]
 name = "bit-set"
 version = "0.5.3"
@@ -704,6 +778,15 @@ version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6d43a04d8753f35258c91f8ec639f792891f748a1edbd759cf1dcea3382ad83c"
 
+[[package]]
+name = "cexpr"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766"
+dependencies = [
+ "nom",
+]
+
 [[package]]
 name = "cfg-if"
 version = "1.0.0"
@@ -768,6 +851,17 @@ dependencies = [
  "inout",
 ]
 
+[[package]]
+name = "clang-sys"
+version = "1.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b023947811758c97c59bf9d1c188fd619ad4718dcaa767947df1cadb14f39f4"
+dependencies = [
+ "glob",
+ "libc",
+ "libloading",
+]
+
 [[package]]
 name = "clap"
 version = "3.2.23"
@@ -868,6 +962,15 @@ dependencies = [
  "winapi",
 ]
 
+[[package]]
+name = "cmake"
+version = "0.1.54"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e7caa3f9de89ddbe2c607f4101924c5abec803763ae9534e4f4d7d8f84aa81f0"
+dependencies = [
+ "cc",
+]
+
 [[package]]
 name = "cobs"
 version = "0.2.3"
@@ -1024,7 +1127,7 @@ dependencies = [
  "hashbrown 0.14.5",
  "log",
  "regalloc2",
- "rustc-hash",
+ "rustc-hash 2.0.0",
  "smallvec",
  "target-lexicon",
 ]
@@ -1525,6 +1628,12 @@ dependencies = [
  "shared_child",
 ]
 
+[[package]]
+name = "dunce"
+version = "1.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "92773504d58c093f6de2459af4af33faa518c13451eb8f2b5698ed3d36e7c813"
+
 [[package]]
 name = "educe"
 version = "0.4.23"
@@ -1847,6 +1956,16 @@ dependencies = [
  "autocfg",
 ]
 
+[[package]]
+name = "fs-err"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1f89bda4c2a21204059a977ed3bfe746677dfd137b83c339e702b0ac91d482aa"
+dependencies = [
+ "autocfg",
+ "tokio",
+]
+
 [[package]]
 name = "fs2"
 version = "0.4.3"
@@ -1857,6 +1976,12 @@ dependencies = [
  "winapi",
 ]
 
+[[package]]
+name = "fs_extra"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42703706b716c37f96a77aea830392ad231f44c9e9a67872fa5548707e11b11c"
+
 [[package]]
 name = "fuchsia-cprng"
 version = "0.1.1"
@@ -2901,6 +3026,12 @@ version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
+[[package]]
+name = "lazycell"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55"
+
 [[package]]
 name = "leb128"
 version = "0.2.5"
@@ -2913,6 +3044,16 @@ version = "0.2.162"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "18d287de67fe55fd7e1581fe933d965a5a9477b38e949cfa9f8574ef01506398"
 
+[[package]]
+name = "libloading"
+version = "0.8.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc2f4eb4bc735547cfed7c0a4922cbd04a4655978c09b54f1f7b228750664c34"
+dependencies = [
+ "cfg-if",
+ "windows-targets 0.52.6",
+]
+
 [[package]]
 name = "libm"
 version = "0.2.11"
@@ -3128,6 +3269,12 @@ version = "0.3.17"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"
 
+[[package]]
+name = "minimal-lexical"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"
+
 [[package]]
 name = "miniz_oxide"
 version = "0.8.0"
@@ -3219,6 +3366,16 @@ version = "0.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2bf50223579dc7cdcfb3bfcacf7069ff68243f8c363f62ffa99cf000a6b9c451"
 
+[[package]]
+name = "nom"
+version = "7.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
+dependencies = [
+ "memchr",
+ "minimal-lexical",
+]
+
 [[package]]
 name = "nu-ansi-term"
 version = "0.46.0"
@@ -3817,6 +3974,16 @@ dependencies = [
  "yansi",
 ]
 
+[[package]]
+name = "prettyplease"
+version = "0.2.25"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "64d1ec885c64d0457d564db4ec299b2dae3f9c02808b8ad9c3a089c591b18033"
+dependencies = [
+ "proc-macro2",
+ "syn 2.0.87",
+]
+
 [[package]]
 name = "proc-macro-crate"
 version = "3.2.0"
@@ -4221,7 +4388,7 @@ checksum = "12908dbeb234370af84d0579b9f68258a0f67e201412dd9a2814e6f45b2fc0f0"
 dependencies = [
  "hashbrown 0.14.5",
  "log",
- "rustc-hash",
+ "rustc-hash 2.0.0",
  "slice-group-by",
  "smallvec",
 ]
@@ -4475,6 +4642,12 @@ version = "0.1.24"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"
 
+[[package]]
+name = "rustc-hash"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"
+
 [[package]]
 name = "rustc-hash"
 version = "2.0.0"
@@ -4509,7 +4682,10 @@ version = "0.23.16"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "eee87ff5d9b36712a58574e12e9f0ea80f915a5b0ac518d322b24a465617925e"
 dependencies = [
+ "aws-lc-rs",
+ "log",
  "once_cell",
+ "ring",
  "rustls-pki-types",
  "rustls-webpki",
  "subtle",
@@ -4546,6 +4722,7 @@ version = "0.102.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "64ca1bc8749bd4cf37b5ce386cc146580777b4e8572c7b97baf22c83f444bee9"
 dependencies = [
+ "aws-lc-rs",
  "ring",
  "rustls-pki-types",
  "untrusted",
@@ -5121,7 +5298,7 @@ dependencies = [
  "duct",
  "email_address",
  "flate2",
- "fs-err",
+ "fs-err 2.11.0",
  "futures",
  "http 1.1.0",
  "indicatif",
@@ -5325,7 +5502,7 @@ dependencies = [
  "regex",
  "reqwest 0.12.9",
  "rustc-demangle",
- "rustc-hash",
+ "rustc-hash 2.0.0",
  "scopeguard",
  "semver",
  "serde",
@@ -5659,9 +5836,12 @@ dependencies = [
  "home",
  "http 1.1.0",
  "log",
+ "native-tls",
  "once_cell",
  "prometheus",
  "rand 0.9.0",
+ "rustls",
+ "rustls-pemfile 2.2.0",
  "spacetimedb-client-api-messages",
  "spacetimedb-data-structures",
  "spacetimedb-lib",
@@ -5719,6 +5899,7 @@ dependencies = [
  "anyhow",
  "async-trait",
  "axum",
+ "axum-server",
  "clap 4.5.20",
  "dirs",
  "futures",
@@ -5728,6 +5909,8 @@ dependencies = [
  "once_cell",
  "openssl",
  "prometheus",
+ "ring",
+ "rustls",
  "scopeguard",
  "serde_json",
  "sled",
@@ -5878,7 +6061,7 @@ checksum = "78ea1056caa9180e7e5727eed1a377d96c9f4615303fa82d2f4c202c64736dee"
 dependencies = [
  "async-trait",
  "educe",
- "fs-err",
+ "fs-err 2.11.0",
  "futures",
  "glob",
  "humantime",
@@ -5936,7 +6119,7 @@ dependencies = [
  "clap 4.5.20",
  "console",
  "derive_more",
- "fs-err",
+ "fs-err 2.11.0",
  "futures",
  "glob",
  "itertools 0.12.1",
diff --git a/crates/cli/src/subcommands/delete.rs b/crates/cli/src/subcommands/delete.rs
index e0d5c756..10e49baa 100644
--- a/crates/cli/src/subcommands/delete.rs
+++ b/crates/cli/src/subcommands/delete.rs
@@ -13,17 +13,45 @@ pub fn cli() -> clap::Command {
         )
         .arg(common_args::server().help("The nickname, host name or URL of the server hosting the database"))
         .arg(common_args::yes())
+        .arg(
+            Arg::new("cert")
+                .long("cert")
+                .value_name("FILE")
+                .action(clap::ArgAction::Set)
+                .value_parser(clap::value_parser!(std::path::PathBuf))
+                .help("Path to the server’s self-signed certificate or CA certificate (PEM format) to trust"),
+        )
         .after_help("Run `spacetime help delete` for more detailed information.\n")
 }
 
+
+
 pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::Error> {
     let server = args.get_one::<String>("server").map(|s| s.as_ref());
     let database = args.get_one::<String>("database").unwrap();
     let force = args.get_flag("force");
 
-    let identity = database_identity(&config, database, server).await?;
+    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+
+    pub async fn build_client(cert_path: Option<&std::path::Path>) -> anyhow::Result<reqwest::Client> {
+        let mut client_builder = reqwest::Client::builder();
+
+        if let Some(path) = cert_path {
+            let cert_pem = tokio::fs::read_to_string(path).await
+                .map_err(|e| anyhow::anyhow!("Failed to read certificate file {} err: {}", path.display(), e))?;
+            let cert = reqwest::Certificate::from_pem(cert_pem.as_bytes())
+                .map_err(|e| anyhow::anyhow!("Failed to parse certificate file {} err: {}", path.display(), e))?;
+            client_builder = client_builder.add_root_certificate(cert);
+        }
+
+        client_builder.build()
+            .map_err(|e| anyhow::anyhow!("Failed to build client with cert {:?} err: {}", cert_path, e))
+    }
+
+    let client = build_client(cert).await?;
+    let identity = database_identity(&config, database, server, &client).await?;
 
-    let builder = reqwest::Client::new().delete(format!("{}/v1/database/{}", config.get_host_url(server)?, identity));
+    let builder = client.delete(format!("{}/v1/database/{}", config.get_host_url(server)?, identity));
     let auth_header = get_auth_header(&mut config, false, server, !force).await?;
     let builder = add_auth_header_opt(builder, &auth_header);
     builder.send().await?.error_for_status()?;
diff --git a/crates/cli/src/subcommands/login.rs b/crates/cli/src/subcommands/login.rs
index 8e2568b4..db5944df 100644
--- a/crates/cli/src/subcommands/login.rs
+++ b/crates/cli/src/subcommands/login.rs
@@ -31,6 +31,14 @@ pub fn cli() -> Command {
                 .group("login-method")
                 .help("Bypass the login flow and use a login token directly"),
         )
+        .arg(
+            Arg::new("cert")
+                .long("cert")
+                .value_name("FILE")
+                .action(clap::ArgAction::Set)
+                .value_parser(clap::value_parser!(std::path::PathBuf))
+                .help("Path to the server’s self-signed certificate or the CA certificate (PEM format) which signed it, to trust the server."),
+        )
         .about("Manage your login to the SpacetimeDB CLI")
 }
 
@@ -53,7 +61,18 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     let spacetimedb_token: Option<&String> = args.get_one("spacetimedb-token");
     let host: &String = args.get_one("auth-host").unwrap();
     let host = Url::parse(host)?;
+    // XXX: specifying an url for the server below, instead of an existing nickname, will cause 'login' to
+    // succeed but you might wrongly assume like I did in https://github.com/clockworklabs/SpacetimeDB/issues/2512
+    // that any subsequent commands like `spacetime publish` will use that server that you specified
+    // but instead they won't, they'll use a default 127.0.0.1:3000(http) server instead
+    // because the url you used to login isn't saved in ~/.config/spacetime/cli.toml
+    // only the (login)spacetimedb_token is, and to select a default or add a new server
+    // to the list you've to use `spacetime server help`
+    // so let's warn, but allow this behavior.
     let server_issued_login: Option<&String> = args.get_one("server");
+    if let Some(server) = server_issued_login {
+        println!("WARNING: the server that you specified here as '{}' isn't the one that will be used by commands like 'spacetime publish' but instead it's the one listed on 'spacetime server list' as the default (3 stars) that will be used, eg. 127.0.0.1:3000 if you haven't manually added any via 'spacetime server add'.\n",server);//extra new line
+    }//if
 
     if let Some(token) = spacetimedb_token {
         config.set_spacetimedb_token(token.clone());
@@ -61,11 +80,14 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
         return Ok(());
     }
 
+    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
     if let Some(server) = server_issued_login {
         let host = Url::parse(&config.get_host_url(Some(server))?)?;
-        spacetimedb_token_cached(&mut config, &host, true).await?;
+        //config.protocol=host.scheme();
+        //eprintln!("!!!!! scheme: '{:#?}', host: '{}', config: '{:#?}'", config.protocol(Some(server)), host, config);
+        spacetimedb_token_cached(&mut config, &host, true, cert).await?;
     } else {
-        spacetimedb_token_cached(&mut config, &host, false).await?;
+        spacetimedb_token_cached(&mut config, &host, false, cert).await?;
     }
 
     Ok(())
@@ -98,7 +120,7 @@ async fn exec_show(config: Config, args: &ArgMatches) -> Result<(), anyhow::Erro
     Ok(())
 }
 
-async fn spacetimedb_token_cached(config: &mut Config, host: &Url, direct_login: bool) -> anyhow::Result<String> {
+async fn spacetimedb_token_cached(config: &mut Config, host: &Url, direct_login: bool, cert: Option<&std::path::Path>) -> anyhow::Result<String> {
     // Currently, this token does not expire. However, it will at some point in the future. When that happens,
     // this code will need to happen before any request to a spacetimedb server, rather than at the end of the login flow here.
     if let Some(token) = config.spacetimedb_token() {
@@ -106,17 +128,19 @@ async fn spacetimedb_token_cached(config: &mut Config, host: &Url, direct_login:
         println!("If you want to log out, use spacetime logout.");
         Ok(token.clone())
     } else {
-        spacetimedb_login_force(config, host, direct_login).await
+        spacetimedb_login_force(config, host, direct_login, cert).await
     }
 }
 
-pub async fn spacetimedb_login_force(config: &mut Config, host: &Url, direct_login: bool) -> anyhow::Result<String> {
+pub async fn spacetimedb_login_force(config: &mut Config, host: &Url, direct_login: bool, cert: Option<&std::path::Path>) -> anyhow::Result<String> {
     let token = if direct_login {
-        let token = spacetimedb_direct_login(host).await?;
+        println!("We will log in directly to your target server.");
+        let token = spacetimedb_direct_login(host, cert).await?;
         println!("We have logged in directly to your target server.");
         println!("WARNING: This login will NOT work for any other servers.");
         token
     } else {
+        println!("We will log in NON-directly to your target server.");
         let session_token = web_login_cached(config, host).await?;
         spacetimedb_login(host, &session_token).await?
     };
@@ -271,8 +295,25 @@ struct LocalLoginResponse {
     pub token: String,
 }
 
-async fn spacetimedb_direct_login(host: &Url) -> Result<String, anyhow::Error> {
-    let client = reqwest::Client::new();
+async fn spacetimedb_direct_login(host: &Url, cert: Option<&std::path::Path>) -> Result<String, anyhow::Error> {
+    pub async fn build_client(cert_path: Option<&std::path::Path>) -> anyhow::Result<reqwest::Client> {
+        let mut client_builder = reqwest::Client::builder();
+
+        if let Some(path) = cert_path {
+            let cert_pem = tokio::fs::read_to_string(path).await
+                .map_err(|e| anyhow::anyhow!("Failed to read certificate file {} err: {}", path.display(), e))?;
+            let cert = reqwest::Certificate::from_pem(cert_pem.as_bytes())
+                .map_err(|e| anyhow::anyhow!("Failed to parse certificate file {} err: {}", path.display(), e))?;
+            client_builder = client_builder.add_root_certificate(cert);
+        }
+
+        client_builder.build()
+            .map_err(|e| anyhow::anyhow!("Failed to build client with cert {:?} err: {}", cert_path, e))
+    }
+
+    //let client = reqwest::Client::new();
+    let client = build_client(cert.as_deref()).await?;
+
     let response: LocalLoginResponse = client
         .post(host.join("/v1/identity")?)
         .send()
diff --git a/crates/cli/src/subcommands/logs.rs b/crates/cli/src/subcommands/logs.rs
index c92a6f01..298588b8 100644
--- a/crates/cli/src/subcommands/logs.rs
+++ b/crates/cli/src/subcommands/logs.rs
@@ -48,6 +48,14 @@ pub fn cli() -> clap::Command {
                 .help("Output format for the logs")
         )
         .arg(common_args::yes())
+        .arg(
+            Arg::new("cert")
+            .long("cert")
+            .value_name("FILE")
+            .action(clap::ArgAction::Set)
+            .value_parser(clap::value_parser!(std::path::PathBuf))
+            .help("Path to the server’s self-signed certificate or CA certificate (PEM format) to trust"),
+        )
         .after_help("Run `spacetime help logs` for more detailed information.\n")
 }
 
@@ -120,7 +128,25 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
 
     let auth_header = get_auth_header(&mut config, false, server, !force).await?;
 
-    let database_identity = database_identity(&config, database, server).await?;
+    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+
+    pub async fn build_client(cert_path: Option<&std::path::Path>) -> anyhow::Result<reqwest::Client> {
+        let mut client_builder = reqwest::Client::builder();
+
+        if let Some(path) = cert_path {
+            let cert_pem = tokio::fs::read_to_string(path).await
+                .map_err(|e| anyhow::anyhow!("Failed to read certificate file {} err: {}", path.display(), e))?;
+            let cert = reqwest::Certificate::from_pem(cert_pem.as_bytes())
+                .map_err(|e| anyhow::anyhow!("Failed to parse certificate file {} err: {}", path.display(), e))?;
+            client_builder = client_builder.add_root_certificate(cert);
+        }
+
+        client_builder.build()
+            .map_err(|e| anyhow::anyhow!("Failed to build client with cert {:?} err: {}", cert_path, e))
+    }
+
+    let client = build_client(cert).await?;
+    let database_identity = database_identity(&config, database, server, &client).await?;
 
     if follow && num_lines.is_none() {
         // We typically don't want logs from the very beginning if we're also following.
@@ -130,7 +156,7 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
 
     let host_url = config.get_host_url(server)?;
 
-    let builder = reqwest::Client::new().get(format!("{}/v1/database/{}/logs", host_url, database_identity));
+    let builder = client.get(format!("{}/v1/database/{}/logs", host_url, database_identity));
     let builder = add_auth_header_opt(builder, &auth_header);
     let mut res = builder.query(&query_parms).send().await?;
     let status = res.status();
diff --git a/crates/cli/src/subcommands/publish.rs b/crates/cli/src/subcommands/publish.rs
index 65cdf343..80a8068f 100644
--- a/crates/cli/src/subcommands/publish.rs
+++ b/crates/cli/src/subcommands/publish.rs
@@ -63,6 +63,14 @@ i.e. only lowercase ASCII letters and numbers, separated by dashes."),
         .arg(common_args::server()
                 .help("The nickname, domain name or URL of the server to host the database."),
         )
+        .arg(
+            Arg::new("cert")
+                .long("cert")
+                .value_name("FILE")
+                .action(Set)
+                .value_parser(clap::value_parser!(std::path::PathBuf))
+                .help("Path to the server’s self-signed certificate or the CA certificate (PEM format) which signed it, to trust the server."),
+        )
         .arg(
             common_args::yes()
         )
@@ -79,6 +87,9 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     let wasm_file = args.get_one::<PathBuf>("wasm_file");
     let database_host = config.get_host_url(server)?;
     let build_options = args.get_one::<String>("build_options").unwrap();
+    //let cert_path = args.get_one::<String>("cert").map(PathBuf::from);
+    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+
 
     // If the user didn't specify an identity and we didn't specify an anonymous identity, then
     // we want to use the default identity
@@ -86,7 +97,25 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     //  easily create a new identity with an email
     let auth_header = get_auth_header(&mut config, anon_identity, server, !force).await?;
 
-    let client = reqwest::Client::new();
+    //use reqwest::Client;
+    //use std::path::Path;
+    pub async fn build_client(cert_path: Option<&std::path::Path>) -> anyhow::Result<reqwest::Client> {
+        let mut client_builder = reqwest::Client::builder();
+
+        if let Some(path) = cert_path {
+            let cert_pem = tokio::fs::read_to_string(path).await
+                .map_err(|e| anyhow::anyhow!("Failed to read certificate file {} err: {}", path.display(), e))?;
+            let cert = reqwest::Certificate::from_pem(cert_pem.as_bytes())
+                .map_err(|e| anyhow::anyhow!("Failed to parse certificate file {} err: {}", path.display(), e))?;
+            client_builder = client_builder.add_root_certificate(cert);
+        }
+
+        client_builder.build()
+            .map_err(|e| anyhow::anyhow!("Failed to build client with cert {:?} err: {}", cert_path, e))
+    }
+
+    //let client = reqwest::Client::new();
+    let client = build_client(cert).await?;
 
     // If a domain or identity was provided, we should locally make sure it looks correct and
     let mut builder = if let Some(name_or_identity) = name_or_identity {
@@ -119,7 +148,17 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
         let url = Url::parse(&database_host)?;
         url.host_str().unwrap_or("<default>").to_string()
     };
-    if server_address != "localhost" && server_address != "127.0.0.1" {
+
+    use std::net::IpAddr;
+    fn is_local_address(address: &str) -> bool {
+        if let Ok(IpAddr::V4(ipv4)) = address.parse::<IpAddr>() {
+            ipv4.is_loopback() // Check if the address is a loopback address
+        } else {
+            address.eq_ignore_ascii_case("localhost") // or 'false'
+        }
+    }
+    //if server_address != "localhost" && server_address != "127.0.0.1" {
+    if !is_local_address(&server_address) {
         println!("You are about to publish to a non-local server: {}", server_address);
         if !y_or_n(force, "Are you sure you want to proceed?")? {
             println!("Aborting");
diff --git a/crates/cli/src/subcommands/sql.rs b/crates/cli/src/subcommands/sql.rs
index 8e6cac17..252cc39f 100644
--- a/crates/cli/src/subcommands/sql.rs
+++ b/crates/cli/src/subcommands/sql.rs
@@ -37,6 +37,14 @@ pub fn cli() -> clap::Command {
         .arg(common_args::anonymous())
         .arg(common_args::server().help("The nickname, host name or URL of the server hosting the database"))
         .arg(common_args::yes())
+        .arg(
+            Arg::new("cert")
+            .long("cert")
+            .value_name("FILE")
+            .action(clap::ArgAction::Set)
+            .value_parser(clap::value_parser!(std::path::PathBuf))
+            .help("Path to the server’s self-signed certificate or CA certificate (PEM format) to trust"),
+        )
 }
 
 pub(crate) async fn parse_req(mut config: Config, args: &ArgMatches) -> Result<Connection, anyhow::Error> {
@@ -45,10 +53,11 @@ pub(crate) async fn parse_req(mut config: Config, args: &ArgMatches) -> Result<C
     let database_name_or_identity = args.get_one::<String>("database").unwrap();
     let anon_identity = args.get_flag("anon_identity");
 
+    let client = reqwest::Client::new();//TODO: see where this is for 'spacetime sql'
     Ok(Connection {
         host: config.get_host_url(server)?,
         auth_header: get_auth_header(&mut config, anon_identity, server, !force).await?,
-        database_identity: database_identity(&config, database_name_or_identity, server).await?,
+        database_identity: database_identity(&config, database_name_or_identity, server, &client).await?,
         database: database_name_or_identity.to_string(),
     })
 }
diff --git a/crates/cli/src/util.rs b/crates/cli/src/util.rs
index 20e0591c..24f6730c 100644
--- a/crates/cli/src/util.rs
+++ b/crates/cli/src/util.rs
@@ -17,11 +17,12 @@ pub async fn database_identity(
     config: &Config,
     name_or_identity: &str,
     server: Option<&str>,
+    client: &reqwest::Client,
 ) -> Result<Identity, anyhow::Error> {
     if let Ok(identity) = Identity::from_hex(name_or_identity) {
         return Ok(identity);
     }
-    spacetime_dns(config, name_or_identity, server)
+    spacetime_dns(config, name_or_identity, server, client)
         .await?
         .with_context(|| format!("the dns resolution of `{name_or_identity}` failed."))
 }
@@ -111,8 +112,9 @@ pub async fn spacetime_dns(
     config: &Config,
     domain: &str,
     server: Option<&str>,
+    client: &reqwest::Client,
 ) -> Result<Option<Identity>, anyhow::Error> {
-    let client = reqwest::Client::new();
+    //let client = reqwest::Client::new();
     let url = format!("{}/v1/database/{}/identity", config.get_host_url(server)?, domain);
     let Some(res) = client.get(url).send().await?.found() else {
         return Ok(None);
@@ -314,9 +316,9 @@ pub async fn get_login_token_or_log_in(
 
     if full_login {
         let host = Url::parse(DEFAULT_AUTH_HOST)?;
-        spacetimedb_login_force(config, &host, false).await
+        spacetimedb_login_force(config, &host, false, None/*TODO*/).await
     } else {
         let host = Url::parse(&config.get_host_url(target_server)?)?;
-        spacetimedb_login_force(config, &host, true).await
+        spacetimedb_login_force(config, &host, true, None/*TODO*/).await
     }
 }
diff --git a/crates/sdk/Cargo.toml b/crates/sdk/Cargo.toml
index 9daa2a98..739b7ccf 100644
--- a/crates/sdk/Cargo.toml
+++ b/crates/sdk/Cargo.toml
@@ -29,6 +29,10 @@ prometheus.workspace = true
 rand.workspace = true
 tokio.workspace = true
 tokio-tungstenite.workspace = true
+rustls = "0.23"
+rustls-pemfile = "2.2.0"
+#tokio-rustls="0.24"
+native-tls = "0.2"  # Explicitly add for Connector::NativeTls
 
 [dev-dependencies]
 # for quickstart-chat and cursive-chat examples
diff --git a/crates/sdk/examples/quickstart-chat/main.rs b/crates/sdk/examples/quickstart-chat/main.rs
index e04ff9cb..f686791a 100644
--- a/crates/sdk/examples/quickstart-chat/main.rs
+++ b/crates/sdk/examples/quickstart-chat/main.rs
@@ -5,11 +5,20 @@ use module_bindings::*;
 
 use spacetimedb_sdk::{credentials, DbContext, Error, Event, Identity, Status, Table, TableWithPrimaryKey};
 
+use std::path::PathBuf;
+
+
 // ## Define the main function
 
 fn main() {
-    // Connect to the database
-    let ctx = connect_to_db();
+    // ### Parse command-line arguments for --cert into a PathBuf
+    let args: Vec<String> = std::env::args().collect();
+    let cert_path: Option<PathBuf> = args.iter()
+        .position(|arg| arg == "--cert")
+        .map(|i| args.get(i + 1).expect("Missing certificate path after --cert"))
+        .map(|s| PathBuf::from(s));
+    // Connect to the database with optional cert
+    let ctx = connect_to_db(cert_path);
 
     // Register callbacks to run in response to database events.
     register_callbacks(&ctx);
@@ -26,15 +35,21 @@ fn main() {
 
 // ## Connect to the database
 
-/// The URI of the SpacetimeDB instance hosting our chat module.
-const HOST: &str = "http://localhost:3000";
+/// The host and port, without scheme, of the SpacetimeDB instance hosting our chat module.
+const HOST_PORT: &str = "localhost:3000";
+//const HOST_PORT: &str = "127.1.2.3:6543";
 
 /// The module name we chose when we published our module.
 const DB_NAME: &str = "quickstart-chat";
 
 /// Load credentials from a file and connect to the database.
-fn connect_to_db() -> DbConnection {
-    DbConnection::builder()
+fn connect_to_db(cert_path: Option<PathBuf>) -> DbConnection {
+    // ### Construct URI with scheme based on cert presence
+    let scheme = if cert_path.is_some() { "https" } else { "http" };
+    let uri = format!("{}://{}", scheme, HOST_PORT);
+
+//    let mut builder=
+        DbConnection::builder()
         // Register our `on_connect` callback, which will save our auth token.
         .on_connect(on_connected)
         // Register our `on_connect_error` callback, which will print a message, then exit the process.
@@ -48,7 +63,17 @@ fn connect_to_db() -> DbConnection {
         // Set the database name we chose when we called `spacetime publish`.
         .with_module_name(DB_NAME)
         // Set the URI of the SpacetimeDB host that's running our database.
-        .with_uri(HOST)
+        .with_uri(&uri)
+//;    // ### Add trusted cert if provided
+//    if let Some(cert_path) = cert_path {
+//    //XXX: we don't wanna do this(that's why it's acception Option instead):
+//        builder = builder.with_trusted_cert(cert_path);
+//    }
+//     // Finalize configuration and connect!
+//     builder.build()
+//         .expect("Failed to connect")
+        // ### Add trusted cert if provided
+        .with_trusted_cert(cert_path)
         // Finalize configuration and connect!
         .build()
         .expect("Failed to connect")
diff --git a/crates/sdk/src/db_connection.rs b/crates/sdk/src/db_connection.rs
index e1e4133e..9c6a300b 100644
--- a/crates/sdk/src/db_connection.rs
+++ b/crates/sdk/src/db_connection.rs
@@ -748,6 +748,8 @@ pub struct DbConnectionBuilder<M: SpacetimeModule> {
     on_disconnect: Option<OnDisconnectCallback<M>>,
 
     params: WsParams,
+
+    trusted_cert: Option<std::path::PathBuf>,
 }
 
 /// This process's global connection ID, which will be attacked to all connections it makes.
@@ -794,6 +796,7 @@ impl<M: SpacetimeModule> DbConnectionBuilder<M> {
             on_connect_error: None,
             on_disconnect: None,
             params: <_>::default(),
+            trusted_cert: None,
         }
     }
 
@@ -841,6 +844,7 @@ but you must call one of them, or else the connection will never progress.
                 self.token.as_deref(),
                 get_connection_id(),
                 self.params,
+                self.trusted_cert.as_ref(),
             ))
         })
         .map_err(|source| crate::Error::FailedToConnect {
@@ -892,6 +896,15 @@ but you must call one of them, or else the connection will never progress.
         self
     }
 
+//    pub fn with_trusted_cert(mut self, cert: impl Into<std::path::PathBuf>) -> Self {
+//        self.trusted_cert = Some(cert.into());
+//        self
+//    }
+    pub fn with_trusted_cert(mut self, cert: Option<impl Into<std::path::PathBuf>>) -> Self {
+        self.trusted_cert = cert.map(|c| c.into());
+        self
+    }
+
     /// Set the name or identity of the remote module.
     pub fn with_module_name(mut self, name_or_identity: impl Into<String>) -> Self {
         self.module_name = Some(name_or_identity.into());
diff --git a/crates/sdk/src/websocket.rs b/crates/sdk/src/websocket.rs
index 436520d5..ac21fa7b 100644
--- a/crates/sdk/src/websocket.rs
+++ b/crates/sdk/src/websocket.rs
@@ -21,10 +21,11 @@ use tokio::task::JoinHandle;
 use tokio::time::Instant;
 use tokio::{net::TcpStream, runtime};
 use tokio_tungstenite::{
-    connect_async_with_config,
+    //connect_async_with_config,
     tungstenite::client::IntoClientRequest,
     tungstenite::protocol::{Message as WebSocketMessage, WebSocketConfig},
-    MaybeTlsStream, WebSocketStream,
+    MaybeTlsStream,
+    WebSocketStream,
 };
 
 use crate::metrics::CLIENT_METRICS;
@@ -207,19 +208,85 @@ impl WsConnection {
         token: Option<&str>,
         connection_id: ConnectionId,
         params: WsParams,
+        trusted_cert: Option<&std::path::PathBuf>, // Changed to borrow PathBuf
     ) -> Result<Self, WsError> {
         let req = make_request(host, db_name, token, connection_id, params)?;
 
         // Grab the URI for error-reporting.
         let uri = req.uri().clone();
 
-        let (sock, _): (WebSocketStream<MaybeTlsStream<TcpStream>>, _) = connect_async_with_config(
+        let host = uri.clone(); //shadow, and it's thus wss:// not https://
+        use native_tls::Certificate;
+        use native_tls::TlsConnector;
+        use std::sync::Arc;
+        use tokio::net::TcpStream;
+        use tokio_tungstenite::{client_async_tls_with_config, Connector, MaybeTlsStream, WebSocketStream};
+
+        let host_str = host.host().ok_or(WsError::UriError(UriError::InvalidUri {
+            source: Arc::new("No host in URI".parse::<Uri>().unwrap_err().into()),
+        }))?;
+        let port = host.port_u16().ok_or(WsError::UriError(UriError::InvalidUri {
+            source: Arc::new("No port specified in URI".parse::<Uri>().unwrap_err().into()),
+        }))?;
+        if port == 0 {
+            //|| port > 65535 {
+            return Err(WsError::UriError(UriError::InvalidUri {
+                source: Arc::new(format!("Invalid port: {}", port).parse::<Uri>().unwrap_err().into()),
+            }));
+        }
+
+        let tcp_stream = TcpStream::connect((host_str, port))
+            .await
+            .map_err(|source| WsError::Tungstenite {
+                uri: uri.clone(),
+                source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(source)),
+            })?;
+
+        let connector = if host.scheme_str() == Some("wss") {
+            let mut builder = TlsConnector::builder();
+            if let Some(cert_path) = trusted_cert {
+                let cert_pem = std::fs::read_to_string(cert_path).map_err(|e| WsError::Tungstenite {
+                    uri: uri.clone(),
+                    source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                        e.kind(),
+                        format!("Failed to read cert file '{}': {}", cert_path.display(), e),
+                    ))),
+                })?;
+                let cert = Certificate::from_pem(cert_pem.as_bytes()).map_err(|e| WsError::Tungstenite {
+                    uri: uri.clone(),
+                    source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                        std::io::ErrorKind::InvalidData,
+                        format!("Failed to parse PEM cert file '{}': {}", cert_path.display(), e),
+                    ))),
+                })?;
+                builder.add_root_certificate(cert);
+            } else {
+                println!("Didn't add trusted cert file {:?}", trusted_cert);
+            }
+            let tls_connector = builder.build().map_err(|e| WsError::Tungstenite {
+                uri: uri.clone(),
+                source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                    std::io::ErrorKind::Other,
+                    e,
+                ))),
+            })?;
+            Some(Connector::NativeTls(tls_connector))
+        } else {
+            //This is probably just ws:// ie. from http:// aka plaintext non-TLS
+            //println!("!!! Unexpected non-wss:// scheme, is: {}", uri);
+            None
+        };
+
+        let (sock, _): (WebSocketStream<MaybeTlsStream<TcpStream>>, _) = client_async_tls_with_config(
+//        let (sock, _): (WebSocketStream<MaybeTlsStream<TcpStream>>, _) = connect_async_with_config(
             req,
+            tcp_stream,
             // TODO(kim): In order to be able to replicate module WASM blobs,
             // `cloud-next` cannot have message / frame size limits. That's
             // obviously a bad default for all other clients, though.
             Some(WebSocketConfig::default().max_frame_size(None).max_message_size(None)),
-            false,
+            connector
+//            false,
         )
         .await
         .map_err(|source| WsError::Tungstenite {
@@ -231,7 +298,7 @@ impl WsConnection {
             connection_id,
             sock,
         })
-    }
+    } //connect(
 
     pub(crate) fn parse_response(bytes: &[u8]) -> Result<ServerMessage<BsatnFormat>, WsError> {
         let (compression, bytes) = bytes.split_first().ok_or(WsError::EmptyMessage)?;
diff --git a/crates/standalone/Cargo.toml b/crates/standalone/Cargo.toml
index 5207edf4..61a191de 100644
--- a/crates/standalone/Cargo.toml
+++ b/crates/standalone/Cargo.toml
@@ -29,6 +29,15 @@ spacetimedb-paths.workspace = true
 anyhow.workspace = true
 async-trait.workspace = true
 axum.workspace = true
+
+# Add this for TLS support
+#axum-server = "0.6"  # Compatible with axum 0.7.9
+#axum-server = "0.7"  # Compatible with axum 0.7.9
+axum-server = { version = "0.7.2", features = ["tls-rustls"] }
+
+ring = "0.17"  # explicitly add this for the CryptoProvider, even tho it's included transitively.
+rustls= { version="0.23", default-features = true, features=[ "ring" ] }
+
 clap = { workspace = true, features = ["derive", "string"] }
 dirs.workspace = true
 futures.workspace = true
diff --git a/crates/standalone/src/subcommands/start.rs b/crates/standalone/src/subcommands/start.rs
index d74267c6..29d0cb33 100644
--- a/crates/standalone/src/subcommands/start.rs
+++ b/crates/standalone/src/subcommands/start.rs
@@ -13,7 +13,7 @@ use spacetimedb_client_api::routes::database::DatabaseRoutes;
 use spacetimedb_client_api::routes::router;
 use spacetimedb_paths::cli::{PrivKeyPath, PubKeyPath};
 use spacetimedb_paths::server::ServerDataDir;
-use tokio::net::TcpListener;
+//use tokio::net::TcpListener;
 
 pub fn cli() -> clap::Command {
     clap::Command::new("start")
@@ -67,6 +67,9 @@ pub fn cli() -> clap::Command {
         .arg(Arg::new("in_memory").long("in-memory").action(SetTrue).help(
             "If specified the database will run entirely in memory. After the process exits all data will be lost.",
         ))
+        .arg(Arg::new("ssl").long("ssl").alias("tls").alias("https").alias("secure").action(clap::ArgAction::SetTrue).help("enables the standalone server to listen in SSL mode, ie. use https instead of http to connect to it. Aliases --tls, --ssl, --secure, or --https."))
+        .arg(Arg::new("cert").long("cert").requires("ssl").value_name("FILE").help("--cert cert.pem: The server sends this to clients during the TLS handshake. ie. server's public key, which if it's self-signed then this is the file that you pass to clients via --cert when talking to the server from a client(or the cli), or if signed by a local CA then pass that CA's pub cert to your clients instead, in order to can trust this server from a client connection. Otherwise, you don't have to pass anything to clients if this cert was signed by a public CA like Let's Encrypt."))
+        .arg(Arg::new("key").long("key").requires("ssl").value_name("FILE").help("--key key.pem: The server keeps this private to decrypt and sign responses. ie. the server's private key"))
     // .after_help("Run `spacetime help start` for more detailed information.")
 }
 
@@ -143,10 +146,35 @@ pub async fn exec(args: &ArgMatches) -> anyhow::Result<()> {
     let extra = axum::Router::new().nest("/health", spacetimedb_client_api::routes::health::router());
     let service = router(&ctx, db_routes, extra).with_state(ctx);
 
-    let tcp = TcpListener::bind(listen_addr).await?;
-    socket2::SockRef::from(&tcp).set_nodelay(true)?;
-    log::debug!("Starting SpacetimeDB listening on {}", tcp.local_addr().unwrap());
-    axum::serve(tcp, service).await?;
+//    let tcp = TcpListener::bind(listen_addr).await?;
+//    socket2::SockRef::from(&tcp).set_nodelay(true)?;
+//    log::debug!("Starting SpacetimeDB listening on {}", tcp.local_addr().unwrap());
+//    axum::serve(tcp, service).await?;
+    use std::net::SocketAddr;
+    let addr: SocketAddr = listen_addr.parse()?;
+    if args.get_flag("ssl") {
+        let cert_path = args.get_one::<String>("cert").context("Missing --cert for SSL")?;
+        let key_path = args.get_one::<String>("key").context("Missing --key for SSL")?;
+        // Install the default CryptoProvider at the start of the function
+        // This only needs to happen once per process, so it's safe to call here
+        use rustls::crypto::ring::default_provider;  // Add this
+        use rustls::crypto::CryptoProvider;          // Add this
+        CryptoProvider::install_default(default_provider())
+            .expect("Failed to install default CryptoProvider");
+
+        use axum_server::tls_rustls::RustlsConfig;
+        let tls_config = RustlsConfig::from_pem_file(cert_path, key_path).await?;
+        log::debug!("Starting SpacetimeDB with SSL listening on {}", addr);
+        axum_server::bind_rustls(addr, tls_config)
+            .serve(service.into_make_service())
+            .await?;
+    } else {
+        log::debug!("Starting SpacetimeDB without any ssl (so it's plaintext) listening on {}", addr);
+        axum_server::bind(addr)
+            .serve(service.into_make_service())
+            .await?;
+    }
+
     Ok(())
 }
 
