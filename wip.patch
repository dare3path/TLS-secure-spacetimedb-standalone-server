Future updates should be here: https://github.com/dare3path/spacetimedb-tls-patch
This is work in progress, proof-of-concept patch, even though it works so far (rust client, some cli commands)
This patch is already an upstream _draft_ PR here:
https://github.com/clockworklabs/SpacetimeDB/pull/2598

patch is to be applied on latest master, currently:
commit 651f79d22cc4bb1c3c996ef2436186501a5d83bd (origin/master, origin/HEAD, master)


The features that this patch confers:

======
the spacetime standalone server can listen for incoming TLS connections if you use the --ssl arg, but plaintext ones aren't accepted unless you stop it and start it without the --ssl arg.

clients already could connect to it via TLS, however the server's cert must've been signed by a trusted(in root store) CA (certificate authority) already, however you can use --cert as mentioned below:
======
You can use --cert for most cli commands(including the rust quickstart-chat example) to add a public certificate to trust (ie. as if it were part of the cert trust store) which can thus be either the server's public key, or the CA's public key which is the CA that signed the server's public key. This way, client knows the server's public key is trusted and will connect rather than fail with untrusted signature.
======
These subcommands consider the protocol(eg. https or http) as a unique identifier along with the host and port:
$ spacetime server set-default
$ spacetime server add
$ spacetime server remove
$ spacetime server edit
$ spacetime server fingerprint
$ spacetime server ping

ie. you can have these:

$ spacetime server list
WARNING: This command is UNSTABLE and subject to breaking changes.

 DEFAULT  HOSTNAME                   PROTOCOL  NICKNAME  
          maincloud.spacetimedb.com  https     maincloud 
          127.0.0.1:3000             http      local     
          127.0.0.1:3001             http      local2    
          127.0.0.1:3000             https     slocal    
          127.0.0.1:3001             https     slocal2   

======
You get a warning when using `spacetime login --server-issued-login server` that this `server` isn't the one that cli commands like `spacetime publish`(with no args) will use, but it's the 3 star default one in `spacetime server list` instead.
======
These subcommands support --cert:
spacetime server add
spacetime server edit
spacetime server fingerprint
spacetime server ping
spacetime publish
spacetime login
spacetime logs
spacetime delete
spacetime sql
spacetime start  (this requires passing --key and --ssl also)
======
FIXME: the changes in config.rs are supremely hacky, since the original code disregarded protocol as uniquely identifying the server+proto in the list of `spacetime server list`, so there are functions that take only host:port and assume there's only one in the list where they can be two or more: one for each proto (http, https)
//But seems this is so due to the inability to run more than one spacetimedb (standalone)server per user, since the .pid file is kept in /home/user/.local/share/spacetime/data/spacetime.pid for any/all running instances and thus prevents running more than 1 instance. Unless, --data-dir is specified, then can have multiple instances after all, hmm...
======


diff --git a/Cargo.lock b/Cargo.lock
index 5b15f068..75acd9a3 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -194,6 +194,12 @@ dependencies = [
  "derive_arbitrary",
 ]
 
+[[package]]
+name = "arc-swap"
+version = "1.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "69f7f8c3906b62b754cd5326047894316021dcfe5a194c8ea52bdd94934a3457"
+
 [[package]]
 name = "arrayref"
 version = "0.3.9"
@@ -292,6 +298,29 @@ version = "1.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26"
 
+[[package]]
+name = "aws-lc-rs"
+version = "1.13.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "19b756939cb2f8dc900aa6dcd505e6e2428e9cae7ff7b028c49e3946efa70878"
+dependencies = [
+ "aws-lc-sys",
+ "zeroize",
+]
+
+[[package]]
+name = "aws-lc-sys"
+version = "0.28.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b9f7720b74ed28ca77f90769a71fd8c637a0137f6fae4ae947e1050229cff57f"
+dependencies = [
+ "bindgen",
+ "cc",
+ "cmake",
+ "dunce",
+ "fs_extra",
+]
+
 [[package]]
 name = "axum"
 version = "0.7.7"
@@ -370,6 +399,28 @@ dependencies = [
  "tracing",
 ]
 
+[[package]]
+name = "axum-server"
+version = "0.7.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "495c05f60d6df0093e8fb6e74aa5846a0ad06abaf96d76166283720bf740f8ab"
+dependencies = [
+ "arc-swap",
+ "bytes",
+ "fs-err 3.1.0",
+ "http 1.1.0",
+ "http-body 1.0.1",
+ "hyper 1.5.0",
+ "hyper-util",
+ "pin-project-lite",
+ "rustls",
+ "rustls-pemfile 2.2.0",
+ "rustls-pki-types",
+ "tokio",
+ "tokio-rustls",
+ "tower-service",
+]
+
 [[package]]
 name = "backtrace"
 version = "0.3.74"
@@ -427,6 +478,29 @@ dependencies = [
  "serde",
 ]
 
+[[package]]
+name = "bindgen"
+version = "0.69.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "271383c67ccabffb7381723dea0672a673f292304fcb45c01cc648c7a8d58088"
+dependencies = [
+ "bitflags 2.6.0",
+ "cexpr",
+ "clang-sys",
+ "itertools 0.12.1",
+ "lazy_static",
+ "lazycell",
+ "log",
+ "prettyplease",
+ "proc-macro2",
+ "quote",
+ "regex",
+ "rustc-hash 1.1.0",
+ "shlex",
+ "syn 2.0.87",
+ "which",
+]
+
 [[package]]
 name = "bit-set"
 version = "0.5.3"
@@ -704,6 +778,15 @@ version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6d43a04d8753f35258c91f8ec639f792891f748a1edbd759cf1dcea3382ad83c"
 
+[[package]]
+name = "cexpr"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766"
+dependencies = [
+ "nom",
+]
+
 [[package]]
 name = "cfg-if"
 version = "1.0.0"
@@ -768,6 +851,17 @@ dependencies = [
  "inout",
 ]
 
+[[package]]
+name = "clang-sys"
+version = "1.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b023947811758c97c59bf9d1c188fd619ad4718dcaa767947df1cadb14f39f4"
+dependencies = [
+ "glob",
+ "libc",
+ "libloading",
+]
+
 [[package]]
 name = "clap"
 version = "3.2.23"
@@ -868,6 +962,15 @@ dependencies = [
  "winapi",
 ]
 
+[[package]]
+name = "cmake"
+version = "0.1.54"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e7caa3f9de89ddbe2c607f4101924c5abec803763ae9534e4f4d7d8f84aa81f0"
+dependencies = [
+ "cc",
+]
+
 [[package]]
 name = "cobs"
 version = "0.2.3"
@@ -1024,7 +1127,7 @@ dependencies = [
  "hashbrown 0.14.5",
  "log",
  "regalloc2",
- "rustc-hash",
+ "rustc-hash 2.0.0",
  "smallvec",
  "target-lexicon",
 ]
@@ -1525,6 +1628,12 @@ dependencies = [
  "shared_child",
 ]
 
+[[package]]
+name = "dunce"
+version = "1.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "92773504d58c093f6de2459af4af33faa518c13451eb8f2b5698ed3d36e7c813"
+
 [[package]]
 name = "educe"
 version = "0.4.23"
@@ -1847,6 +1956,16 @@ dependencies = [
  "autocfg",
 ]
 
+[[package]]
+name = "fs-err"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1f89bda4c2a21204059a977ed3bfe746677dfd137b83c339e702b0ac91d482aa"
+dependencies = [
+ "autocfg",
+ "tokio",
+]
+
 [[package]]
 name = "fs2"
 version = "0.4.3"
@@ -1857,6 +1976,12 @@ dependencies = [
  "winapi",
 ]
 
+[[package]]
+name = "fs_extra"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42703706b716c37f96a77aea830392ad231f44c9e9a67872fa5548707e11b11c"
+
 [[package]]
 name = "fuchsia-cprng"
 version = "0.1.1"
@@ -2901,6 +3026,12 @@ version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
+[[package]]
+name = "lazycell"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55"
+
 [[package]]
 name = "leb128"
 version = "0.2.5"
@@ -2913,6 +3044,16 @@ version = "0.2.162"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "18d287de67fe55fd7e1581fe933d965a5a9477b38e949cfa9f8574ef01506398"
 
+[[package]]
+name = "libloading"
+version = "0.8.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc2f4eb4bc735547cfed7c0a4922cbd04a4655978c09b54f1f7b228750664c34"
+dependencies = [
+ "cfg-if",
+ "windows-targets 0.52.6",
+]
+
 [[package]]
 name = "libm"
 version = "0.2.11"
@@ -3128,6 +3269,12 @@ version = "0.3.17"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"
 
+[[package]]
+name = "minimal-lexical"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"
+
 [[package]]
 name = "miniz_oxide"
 version = "0.8.0"
@@ -3219,6 +3366,16 @@ version = "0.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2bf50223579dc7cdcfb3bfcacf7069ff68243f8c363f62ffa99cf000a6b9c451"
 
+[[package]]
+name = "nom"
+version = "7.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
+dependencies = [
+ "memchr",
+ "minimal-lexical",
+]
+
 [[package]]
 name = "nu-ansi-term"
 version = "0.46.0"
@@ -3817,6 +3974,16 @@ dependencies = [
  "yansi",
 ]
 
+[[package]]
+name = "prettyplease"
+version = "0.2.25"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "64d1ec885c64d0457d564db4ec299b2dae3f9c02808b8ad9c3a089c591b18033"
+dependencies = [
+ "proc-macro2",
+ "syn 2.0.87",
+]
+
 [[package]]
 name = "proc-macro-crate"
 version = "3.2.0"
@@ -4221,7 +4388,7 @@ checksum = "12908dbeb234370af84d0579b9f68258a0f67e201412dd9a2814e6f45b2fc0f0"
 dependencies = [
  "hashbrown 0.14.5",
  "log",
- "rustc-hash",
+ "rustc-hash 2.0.0",
  "slice-group-by",
  "smallvec",
 ]
@@ -4475,6 +4642,12 @@ version = "0.1.24"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"
 
+[[package]]
+name = "rustc-hash"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"
+
 [[package]]
 name = "rustc-hash"
 version = "2.0.0"
@@ -4509,7 +4682,10 @@ version = "0.23.16"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "eee87ff5d9b36712a58574e12e9f0ea80f915a5b0ac518d322b24a465617925e"
 dependencies = [
+ "aws-lc-rs",
+ "log",
  "once_cell",
+ "ring",
  "rustls-pki-types",
  "rustls-webpki",
  "subtle",
@@ -4546,6 +4722,7 @@ version = "0.102.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "64ca1bc8749bd4cf37b5ce386cc146580777b4e8572c7b97baf22c83f444bee9"
 dependencies = [
+ "aws-lc-rs",
  "ring",
  "rustls-pki-types",
  "untrusted",
@@ -5121,7 +5298,7 @@ dependencies = [
  "duct",
  "email_address",
  "flate2",
- "fs-err",
+ "fs-err 2.11.0",
  "futures",
  "http 1.1.0",
  "indicatif",
@@ -5325,7 +5502,7 @@ dependencies = [
  "regex",
  "reqwest 0.12.9",
  "rustc-demangle",
- "rustc-hash",
+ "rustc-hash 2.0.0",
  "scopeguard",
  "semver",
  "serde",
@@ -5659,9 +5836,12 @@ dependencies = [
  "home",
  "http 1.1.0",
  "log",
+ "native-tls",
  "once_cell",
  "prometheus",
  "rand 0.9.0",
+ "rustls",
+ "rustls-pemfile 2.2.0",
  "spacetimedb-client-api-messages",
  "spacetimedb-data-structures",
  "spacetimedb-lib",
@@ -5719,6 +5899,7 @@ dependencies = [
  "anyhow",
  "async-trait",
  "axum",
+ "axum-server",
  "clap 4.5.20",
  "dirs",
  "futures",
@@ -5728,6 +5909,8 @@ dependencies = [
  "once_cell",
  "openssl",
  "prometheus",
+ "ring",
+ "rustls",
  "scopeguard",
  "serde_json",
  "sled",
@@ -5878,7 +6061,7 @@ checksum = "78ea1056caa9180e7e5727eed1a377d96c9f4615303fa82d2f4c202c64736dee"
 dependencies = [
  "async-trait",
  "educe",
- "fs-err",
+ "fs-err 2.11.0",
  "futures",
  "glob",
  "humantime",
@@ -5936,7 +6119,7 @@ dependencies = [
  "clap 4.5.20",
  "console",
  "derive_more",
- "fs-err",
+ "fs-err 2.11.0",
  "futures",
  "glob",
  "itertools 0.12.1",
diff --git a/crates/cli/src/config.rs b/crates/cli/src/config.rs
index 1e709b89..ebd5b4d3 100644
--- a/crates/cli/src/config.rs
+++ b/crates/cli/src/config.rs
@@ -177,21 +177,59 @@ impl RawConfig {
     }
 
     fn find_server(&self, name_or_host: &str) -> anyhow::Result<&ServerConfig> {
+        self.find_server_with_protocol(name_or_host, None)
+    }
+    fn find_server_with_protocol(&self, name_or_host: &str, protocol: Option<&str>) -> anyhow::Result<&ServerConfig> {
+        let mut matches = Vec::new();
         for cfg in &self.server_configs {
-            if cfg.nickname.as_deref() == Some(name_or_host) || cfg.host == name_or_host {
-                return Ok(cfg);
+            if cfg.nickname.as_deref() == Some(name_or_host) {
+                return Ok(cfg); // Nickname is unique
+            }
+            if cfg.host == name_or_host && protocol.map_or(true, |p| cfg.protocol == p) {
+                matches.push(cfg);
             }
         }
-        Err(no_such_server_error(name_or_host))
+        match matches.len() {
+            0 => Err(no_such_server_error(name_or_host)),
+            1 => Ok(matches[0]),
+            _ => Err(anyhow::anyhow!(
+                    "Ambiguous server: {} matches multiple protocols (e.g., {}://{}, {}://{}). Specify nickname or protocol.",
+                    name_or_host,
+                    matches[0].protocol,
+                    name_or_host,
+                    matches[1].protocol,
+                    name_or_host
+            )),
+        }
     }
 
-    fn find_server_mut(&mut self, name_or_host: &str) -> anyhow::Result<&mut ServerConfig> {
-        for cfg in &mut self.server_configs {
-            if cfg.nickname.as_deref() == Some(name_or_host) || cfg.host == name_or_host {
-                return Ok(cfg);
+    fn find_server_with_protocol_mut(&mut self, name_or_host: &str, protocol: Option<&str>) -> anyhow::Result<&mut ServerConfig> {
+        let mut indices = Vec::new();
+        let mut protocols = Vec::new();
+        for (i, cfg) in self.server_configs.iter().enumerate() {
+            if cfg.nickname.as_deref() == Some(name_or_host) {
+                return Ok(&mut self.server_configs[i]);
             }
+            if cfg.host == name_or_host && protocol.map_or(true, |p| cfg.protocol == p) {
+                indices.push(i);
+                protocols.push(&cfg.protocol);
+            }
+        }
+        match indices.len() {
+            0 => Err(no_such_server_error(name_or_host)),
+            1 => Ok(&mut self.server_configs[indices[0]]),
+            _ => Err(anyhow::anyhow!(
+                    "Ambiguous server: {} matches multiple protocols (e.g., {}://{}, {}://{}). Specify nickname or protocol.",
+                    name_or_host,
+                    protocols[0],
+                    name_or_host,
+                    protocols[1],
+                    name_or_host
+            )),
         }
-        Err(no_such_server_error(name_or_host))
+    }
+    fn find_server_mut(&mut self, name_or_host: &str) -> anyhow::Result<&mut ServerConfig> {
+        self.find_server_with_protocol_mut(name_or_host, None)
     }
 
     fn default_server(&self) -> anyhow::Result<&ServerConfig> {
@@ -231,13 +269,10 @@ impl RawConfig {
             }
         }
 
-        if let Ok(cfg) = self.find_server(&host) {
-            if let Some(nick) = &cfg.nickname {
-                if nick == &host {
-                    anyhow::bail!("Server host name is ambiguous with existing server nickname: {}", nick);
-                }
-            }
-            anyhow::bail!("Server already configured for host: {}", host);
+        if self.server_configs.iter().any(|cfg| {
+            cfg.host == host && cfg.protocol == protocol
+        }) {
+            anyhow::bail!("Server already configured for host: {}, proto: {}", host, protocol);
         }
 
         self.server_configs.push(ServerConfig {
@@ -271,47 +306,68 @@ impl RawConfig {
             .map(|cfg| cfg.protocol.as_ref())
     }
 
-    fn set_default_server(&mut self, server: &str) -> anyhow::Result<()> {
+    fn set_default_server(&mut self, server: &str, protocol: Option<&str>) -> anyhow::Result<()> {
         // Check that such a server exists before setting the default.
-        self.find_server(server)
-            .with_context(|| format!("Cannot set default server to unknown server {server}"))?;
+        let cfg = self
+            .find_server_with_protocol(server, protocol)
+            .with_context(|| {
+                if let Some(p) = protocol {
+                    format!("Cannot set default server to unknown server {} with protocol {}", server, p)
+                } else {
+                    format!("Cannot set default server to unknown server {}", server)
+                }
+            })?;
 
-        self.default_server = Some(server.to_string());
+        // Prefer nickname if available, else use host
+        self.default_server = Some(cfg.nickname.clone().unwrap_or_else(|| cfg.host.clone()));
 
         Ok(())
     }
 
     /// Implements `spacetime server remove`.
-    fn remove_server(&mut self, server: &str) -> anyhow::Result<()> {
-        // Have to find the server config manually instead of doing `find_server_mut`
-        // because we need to mutably borrow multiple components of `self`.
-        if let Some(idx) = self
-            .server_configs
-            .iter()
-            .position(|cfg| cfg.nick_or_host_or_url_is(server))
-        {
-            // Actually remove the config.
-            let cfg = self.server_configs.remove(idx);
-
-            // If we're removing the default server,
-            // unset the default server.
-            if let Some(default_server) = &self.default_server {
-                if cfg.nick_or_host_or_url_is(default_server) {
-                    self.default_server = None;
-                }
+    fn remove_server(&mut self, server: &str, protocol: Option<&str>) -> anyhow::Result<()> {
+        let mut indices = Vec::new();
+        let mut protocols = Vec::new();
+        for (i, cfg) in self.server_configs.iter().enumerate() {
+            if cfg.nickname.as_deref() == Some(server) {
+                indices = vec![i];
+                protocols = vec![&cfg.protocol];
+                break; // Nickname is unique
+            }
+            if cfg.host == server && protocol.map_or(true, |p| cfg.protocol == p) {
+                indices.push(i);
+                protocols.push(&cfg.protocol);
             }
+        }
 
-            return Ok(());
+        match indices.len() {
+            0 => Err(no_such_server_error(server)),
+            1 => {
+                let cfg = self.server_configs.remove(indices[0]);
+                if let Some(default_server) = &self.default_server {
+                    if cfg.nickname.as_deref() == Some(default_server) || cfg.host == *default_server {
+                        self.default_server = None;
+                    }
+                }
+                Ok(())
+            }
+            _ => Err(anyhow::anyhow!(
+                    "Ambiguous server: {} matches multiple protocols (e.g., {}://{}, {}://{}). Specify nickname or protocol.",
+                    server,
+                    protocols[0],
+                    server,
+                    protocols[1],
+                    server
+            )),
         }
-        Err(no_such_server_error(server))
     }
 
     /// Return the ECDSA public key in PEM format for the server named by `server`.
     ///
     /// Returns an `Err` if there is no such server configuration.
     /// Returns `None` if the server configuration exists, but does not have a fingerprint saved.
-    fn server_fingerprint(&self, server: &str) -> anyhow::Result<Option<&str>> {
-        self.find_server(server)
+    fn server_fingerprint(&self, server: &str, protocol: Option<&str>) -> anyhow::Result<Option<&str>> {
+        self.find_server_with_protocol(server, protocol)
             .with_context(|| {
                 format!(
                     "No saved fingerprint for server: {server}
@@ -319,7 +375,7 @@ Fetch the server's fingerprint with:
 \tspacetime server fingerprint -s {server}"
                 )
             })
-            .map(|cfg| cfg.ecdsa_public_key.as_deref())
+        .map(|cfg| cfg.ecdsa_public_key.as_deref())
     }
 
     /// Return the ECDSA public key in PEM format for the default server.
@@ -328,7 +384,7 @@ Fetch the server's fingerprint with:
     /// Returns `None` if the server configuration exists, but does not have a fingerprint saved.
     fn default_server_fingerprint(&self) -> anyhow::Result<Option<&str>> {
         if let Some(server) = &self.default_server {
-            self.server_fingerprint(server)
+            self.server_fingerprint(server, None)
         } else {
             Err(anyhow::anyhow!(NO_DEFAULT_SERVER_ERROR_MESSAGE))
         }
@@ -364,6 +420,7 @@ Fetch the server's fingerprint with:
     pub fn edit_server(
         &mut self,
         server: &str,
+        old_protocol: Option<&str>,
         new_nickname: Option<&str>,
         new_host: Option<&str>,
         new_protocol: Option<&str>,
@@ -371,7 +428,7 @@ Fetch the server's fingerprint with:
         // Check if the new nickname or host name would introduce ambiguities between
         // server configurations.
         if let Some(new_nick) = new_nickname {
-            if let Ok(other_server) = self.find_server(new_nick) {
+            if let Ok(other_server) = self.find_server_with_protocol(new_nick, None) {
                 anyhow::bail!(
                     "Nickname {} conflicts with saved configuration for server {}: {}://{}",
                     new_nick,
@@ -382,7 +439,7 @@ Fetch the server's fingerprint with:
             }
         }
         if let Some(new_host) = new_host {
-            if let Ok(other_server) = self.find_server(new_host) {
+            if let Ok(other_server) = self.find_server_with_protocol(new_host, new_protocol) {
                 anyhow::bail!(
                     "Host {} conflicts with saved configuration for server {}: {}://{}",
                     new_host,
@@ -393,7 +450,7 @@ Fetch the server's fingerprint with:
             }
         }
 
-        let cfg = self.find_server_mut(server)?;
+        let cfg = self.find_server_with_protocol_mut(server, old_protocol)?;
         let old_nickname = if let Some(new_nickname) = new_nickname {
             std::mem::replace(&mut cfg.nickname, Some(new_nickname.to_string()))
         } else {
@@ -509,8 +566,8 @@ impl Config {
     /// Callers should call `Config::save` afterwards
     /// to ensure modifications are persisted to disk.
     pub fn set_default_server(&mut self, nickname_or_host_or_url: &str) -> anyhow::Result<()> {
-        let (host, _) = host_or_url_to_host_and_protocol(nickname_or_host_or_url);
-        self.home.set_default_server(host)
+        let (host, proto) = host_or_url_to_host_and_protocol(nickname_or_host_or_url);
+        self.home.set_default_server(host, proto)
     }
 
     /// Delete a `ServerConfig` from the home configuration.
@@ -522,8 +579,8 @@ impl Config {
     /// Callers should call `Config::save` afterwards
     /// to ensure modifications are persisted to disk.
     pub fn remove_server(&mut self, nickname_or_host_or_url: &str) -> anyhow::Result<()> {
-        let (host, _) = host_or_url_to_host_and_protocol(nickname_or_host_or_url);
-        self.home.remove_server(host)
+        let (host, proto) = host_or_url_to_host_and_protocol(nickname_or_host_or_url);
+        self.home.remove_server(host, proto)
     }
 
     /// Get a URL for the specified `server`.
@@ -734,7 +791,7 @@ impl Config {
     }
 
     pub fn server_decoding_key(&self, server: Option<&str>) -> anyhow::Result<DecodingKey> {
-        self.server_fingerprint(server).and_then(|fing| {
+        self.server_fingerprint(server, None).and_then(|fing| {
             if let Some(fing) = fing {
                 DecodingKey::from_ec_pem(fing.as_bytes()).with_context(|| {
                     format!(
@@ -762,10 +819,11 @@ Update the server's fingerprint with:
         }
     }
 
-    pub fn server_fingerprint(&self, server: Option<&str>) -> anyhow::Result<Option<&str>> {
+    pub fn server_fingerprint(&self, server: Option<&str>, protocol: Option<&str>) -> anyhow::Result<Option<&str>> {
         if let Some(server) = server {
-            let (host, _) = host_or_url_to_host_and_protocol(server);
-            self.home.server_fingerprint(host)
+            let (host, _proto) = host_or_url_to_host_and_protocol(server);
+            //FIXME: if _proto exists and one was specified as arg too... or if none as arg, take _proto?
+            self.home.server_fingerprint(host, protocol)
         } else {
             self.home.default_server_fingerprint()
         }
@@ -787,8 +845,8 @@ Update the server's fingerprint with:
         new_host: Option<&str>,
         new_protocol: Option<&str>,
     ) -> anyhow::Result<(Option<String>, Option<String>, Option<String>)> {
-        let (host, _) = host_or_url_to_host_and_protocol(server);
-        self.home.edit_server(host, new_nickname, new_host, new_protocol)
+        let (host, oldproto) = host_or_url_to_host_and_protocol(server);
+        self.home.edit_server(host, oldproto, new_nickname, new_host, new_protocol)
     }
 
     pub fn delete_server_fingerprint(&mut self, server: Option<&str>) -> anyhow::Result<()> {
diff --git a/crates/cli/src/subcommands/delete.rs b/crates/cli/src/subcommands/delete.rs
index e0d5c756..10e49baa 100644
--- a/crates/cli/src/subcommands/delete.rs
+++ b/crates/cli/src/subcommands/delete.rs
@@ -13,17 +13,45 @@ pub fn cli() -> clap::Command {
         )
         .arg(common_args::server().help("The nickname, host name or URL of the server hosting the database"))
         .arg(common_args::yes())
+        .arg(
+            Arg::new("cert")
+                .long("cert")
+                .value_name("FILE")
+                .action(clap::ArgAction::Set)
+                .value_parser(clap::value_parser!(std::path::PathBuf))
+                .help("Path to the server’s self-signed certificate or CA certificate (PEM format) to trust"),
+        )
         .after_help("Run `spacetime help delete` for more detailed information.\n")
 }
 
+
+
 pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::Error> {
     let server = args.get_one::<String>("server").map(|s| s.as_ref());
     let database = args.get_one::<String>("database").unwrap();
     let force = args.get_flag("force");
 
-    let identity = database_identity(&config, database, server).await?;
+    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+
+    pub async fn build_client(cert_path: Option<&std::path::Path>) -> anyhow::Result<reqwest::Client> {
+        let mut client_builder = reqwest::Client::builder();
+
+        if let Some(path) = cert_path {
+            let cert_pem = tokio::fs::read_to_string(path).await
+                .map_err(|e| anyhow::anyhow!("Failed to read certificate file {} err: {}", path.display(), e))?;
+            let cert = reqwest::Certificate::from_pem(cert_pem.as_bytes())
+                .map_err(|e| anyhow::anyhow!("Failed to parse certificate file {} err: {}", path.display(), e))?;
+            client_builder = client_builder.add_root_certificate(cert);
+        }
+
+        client_builder.build()
+            .map_err(|e| anyhow::anyhow!("Failed to build client with cert {:?} err: {}", cert_path, e))
+    }
+
+    let client = build_client(cert).await?;
+    let identity = database_identity(&config, database, server, &client).await?;
 
-    let builder = reqwest::Client::new().delete(format!("{}/v1/database/{}", config.get_host_url(server)?, identity));
+    let builder = client.delete(format!("{}/v1/database/{}", config.get_host_url(server)?, identity));
     let auth_header = get_auth_header(&mut config, false, server, !force).await?;
     let builder = add_auth_header_opt(builder, &auth_header);
     builder.send().await?.error_for_status()?;
diff --git a/crates/cli/src/subcommands/login.rs b/crates/cli/src/subcommands/login.rs
index 8e2568b4..1ac9e62f 100644
--- a/crates/cli/src/subcommands/login.rs
+++ b/crates/cli/src/subcommands/login.rs
@@ -31,6 +31,14 @@ pub fn cli() -> Command {
                 .group("login-method")
                 .help("Bypass the login flow and use a login token directly"),
         )
+        .arg(
+            Arg::new("cert")
+                .long("cert")
+                .value_name("FILE")
+                .action(clap::ArgAction::Set)
+                .value_parser(clap::value_parser!(std::path::PathBuf))
+                .help("Path to the server’s self-signed certificate or the CA certificate (PEM format) which signed it, to trust the server."),
+        )
         .about("Manage your login to the SpacetimeDB CLI")
 }
 
@@ -53,7 +61,18 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     let spacetimedb_token: Option<&String> = args.get_one("spacetimedb-token");
     let host: &String = args.get_one("auth-host").unwrap();
     let host = Url::parse(host)?;
+    // XXX: specifying an url for the server below, instead of an existing nickname, will cause 'login' to
+    // succeed but you might wrongly assume like I did in https://github.com/clockworklabs/SpacetimeDB/issues/2512
+    // that any subsequent commands like `spacetime publish` will use that server that you specified
+    // but instead they won't, they'll use a default 127.0.0.1:3000(http) server instead
+    // because the url you used to login isn't saved in ~/.config/spacetime/cli.toml
+    // only the (login)spacetimedb_token is, and to select a default or add a new server
+    // to the list you've to use `spacetime server help`
+    // so let's warn, but allow this behavior.
     let server_issued_login: Option<&String> = args.get_one("server");
+    if let Some(server) = server_issued_login {
+        eprintln!("WARNING: the server that you specified here as '{}' isn't the one that will be used by commands like 'spacetime publish' but instead it's the one listed on 'spacetime server list' as the default (3 stars) that will be used, eg. 127.0.0.1:3000 if you haven't manually added any via 'spacetime server add'.\n",server);//extra new line
+    }//if
 
     if let Some(token) = spacetimedb_token {
         config.set_spacetimedb_token(token.clone());
@@ -61,11 +80,14 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
         return Ok(());
     }
 
+    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
     if let Some(server) = server_issued_login {
         let host = Url::parse(&config.get_host_url(Some(server))?)?;
-        spacetimedb_token_cached(&mut config, &host, true).await?;
+        //config.protocol=host.scheme();
+        //eprintln!("!!!!! scheme: '{:#?}', host: '{}', config: '{:#?}'", config.protocol(Some(server)), host, config);
+        spacetimedb_token_cached(&mut config, &host, true, cert).await?;
     } else {
-        spacetimedb_token_cached(&mut config, &host, false).await?;
+        spacetimedb_token_cached(&mut config, &host, false, cert).await?;
     }
 
     Ok(())
@@ -98,7 +120,7 @@ async fn exec_show(config: Config, args: &ArgMatches) -> Result<(), anyhow::Erro
     Ok(())
 }
 
-async fn spacetimedb_token_cached(config: &mut Config, host: &Url, direct_login: bool) -> anyhow::Result<String> {
+async fn spacetimedb_token_cached(config: &mut Config, host: &Url, direct_login: bool, cert: Option<&std::path::Path>) -> anyhow::Result<String> {
     // Currently, this token does not expire. However, it will at some point in the future. When that happens,
     // this code will need to happen before any request to a spacetimedb server, rather than at the end of the login flow here.
     if let Some(token) = config.spacetimedb_token() {
@@ -106,17 +128,19 @@ async fn spacetimedb_token_cached(config: &mut Config, host: &Url, direct_login:
         println!("If you want to log out, use spacetime logout.");
         Ok(token.clone())
     } else {
-        spacetimedb_login_force(config, host, direct_login).await
+        spacetimedb_login_force(config, host, direct_login, cert).await
     }
 }
 
-pub async fn spacetimedb_login_force(config: &mut Config, host: &Url, direct_login: bool) -> anyhow::Result<String> {
+pub async fn spacetimedb_login_force(config: &mut Config, host: &Url, direct_login: bool, cert: Option<&std::path::Path>) -> anyhow::Result<String> {
     let token = if direct_login {
-        let token = spacetimedb_direct_login(host).await?;
+        println!("We will log in directly to your target server.");
+        let token = spacetimedb_direct_login(host, cert).await?;
         println!("We have logged in directly to your target server.");
         println!("WARNING: This login will NOT work for any other servers.");
         token
     } else {
+        println!("We will log in NON-directly to your target server.");
         let session_token = web_login_cached(config, host).await?;
         spacetimedb_login(host, &session_token).await?
     };
@@ -271,8 +295,25 @@ struct LocalLoginResponse {
     pub token: String,
 }
 
-async fn spacetimedb_direct_login(host: &Url) -> Result<String, anyhow::Error> {
-    let client = reqwest::Client::new();
+async fn spacetimedb_direct_login(host: &Url, cert: Option<&std::path::Path>) -> Result<String, anyhow::Error> {
+    pub async fn build_client(cert_path: Option<&std::path::Path>) -> anyhow::Result<reqwest::Client> {
+        let mut client_builder = reqwest::Client::builder();
+
+        if let Some(path) = cert_path {
+            let cert_pem = tokio::fs::read_to_string(path).await
+                .map_err(|e| anyhow::anyhow!("Failed to read certificate file {} err: {}", path.display(), e))?;
+            let cert = reqwest::Certificate::from_pem(cert_pem.as_bytes())
+                .map_err(|e| anyhow::anyhow!("Failed to parse certificate file {} err: {}", path.display(), e))?;
+            client_builder = client_builder.add_root_certificate(cert);
+        }
+
+        client_builder.build()
+            .map_err(|e| anyhow::anyhow!("Failed to build client with cert {:?} err: {}", cert_path, e))
+    }
+
+    //let client = reqwest::Client::new();
+    let client = build_client(cert.as_deref()).await?;
+
     let response: LocalLoginResponse = client
         .post(host.join("/v1/identity")?)
         .send()
diff --git a/crates/cli/src/subcommands/logs.rs b/crates/cli/src/subcommands/logs.rs
index c92a6f01..298588b8 100644
--- a/crates/cli/src/subcommands/logs.rs
+++ b/crates/cli/src/subcommands/logs.rs
@@ -48,6 +48,14 @@ pub fn cli() -> clap::Command {
                 .help("Output format for the logs")
         )
         .arg(common_args::yes())
+        .arg(
+            Arg::new("cert")
+            .long("cert")
+            .value_name("FILE")
+            .action(clap::ArgAction::Set)
+            .value_parser(clap::value_parser!(std::path::PathBuf))
+            .help("Path to the server’s self-signed certificate or CA certificate (PEM format) to trust"),
+        )
         .after_help("Run `spacetime help logs` for more detailed information.\n")
 }
 
@@ -120,7 +128,25 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
 
     let auth_header = get_auth_header(&mut config, false, server, !force).await?;
 
-    let database_identity = database_identity(&config, database, server).await?;
+    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+
+    pub async fn build_client(cert_path: Option<&std::path::Path>) -> anyhow::Result<reqwest::Client> {
+        let mut client_builder = reqwest::Client::builder();
+
+        if let Some(path) = cert_path {
+            let cert_pem = tokio::fs::read_to_string(path).await
+                .map_err(|e| anyhow::anyhow!("Failed to read certificate file {} err: {}", path.display(), e))?;
+            let cert = reqwest::Certificate::from_pem(cert_pem.as_bytes())
+                .map_err(|e| anyhow::anyhow!("Failed to parse certificate file {} err: {}", path.display(), e))?;
+            client_builder = client_builder.add_root_certificate(cert);
+        }
+
+        client_builder.build()
+            .map_err(|e| anyhow::anyhow!("Failed to build client with cert {:?} err: {}", cert_path, e))
+    }
+
+    let client = build_client(cert).await?;
+    let database_identity = database_identity(&config, database, server, &client).await?;
 
     if follow && num_lines.is_none() {
         // We typically don't want logs from the very beginning if we're also following.
@@ -130,7 +156,7 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
 
     let host_url = config.get_host_url(server)?;
 
-    let builder = reqwest::Client::new().get(format!("{}/v1/database/{}/logs", host_url, database_identity));
+    let builder = client.get(format!("{}/v1/database/{}/logs", host_url, database_identity));
     let builder = add_auth_header_opt(builder, &auth_header);
     let mut res = builder.query(&query_parms).send().await?;
     let status = res.status();
diff --git a/crates/cli/src/subcommands/publish.rs b/crates/cli/src/subcommands/publish.rs
index 65cdf343..80a8068f 100644
--- a/crates/cli/src/subcommands/publish.rs
+++ b/crates/cli/src/subcommands/publish.rs
@@ -63,6 +63,14 @@ i.e. only lowercase ASCII letters and numbers, separated by dashes."),
         .arg(common_args::server()
                 .help("The nickname, domain name or URL of the server to host the database."),
         )
+        .arg(
+            Arg::new("cert")
+                .long("cert")
+                .value_name("FILE")
+                .action(Set)
+                .value_parser(clap::value_parser!(std::path::PathBuf))
+                .help("Path to the server’s self-signed certificate or the CA certificate (PEM format) which signed it, to trust the server."),
+        )
         .arg(
             common_args::yes()
         )
@@ -79,6 +87,9 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     let wasm_file = args.get_one::<PathBuf>("wasm_file");
     let database_host = config.get_host_url(server)?;
     let build_options = args.get_one::<String>("build_options").unwrap();
+    //let cert_path = args.get_one::<String>("cert").map(PathBuf::from);
+    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+
 
     // If the user didn't specify an identity and we didn't specify an anonymous identity, then
     // we want to use the default identity
@@ -86,7 +97,25 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     //  easily create a new identity with an email
     let auth_header = get_auth_header(&mut config, anon_identity, server, !force).await?;
 
-    let client = reqwest::Client::new();
+    //use reqwest::Client;
+    //use std::path::Path;
+    pub async fn build_client(cert_path: Option<&std::path::Path>) -> anyhow::Result<reqwest::Client> {
+        let mut client_builder = reqwest::Client::builder();
+
+        if let Some(path) = cert_path {
+            let cert_pem = tokio::fs::read_to_string(path).await
+                .map_err(|e| anyhow::anyhow!("Failed to read certificate file {} err: {}", path.display(), e))?;
+            let cert = reqwest::Certificate::from_pem(cert_pem.as_bytes())
+                .map_err(|e| anyhow::anyhow!("Failed to parse certificate file {} err: {}", path.display(), e))?;
+            client_builder = client_builder.add_root_certificate(cert);
+        }
+
+        client_builder.build()
+            .map_err(|e| anyhow::anyhow!("Failed to build client with cert {:?} err: {}", cert_path, e))
+    }
+
+    //let client = reqwest::Client::new();
+    let client = build_client(cert).await?;
 
     // If a domain or identity was provided, we should locally make sure it looks correct and
     let mut builder = if let Some(name_or_identity) = name_or_identity {
@@ -119,7 +148,17 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
         let url = Url::parse(&database_host)?;
         url.host_str().unwrap_or("<default>").to_string()
     };
-    if server_address != "localhost" && server_address != "127.0.0.1" {
+
+    use std::net::IpAddr;
+    fn is_local_address(address: &str) -> bool {
+        if let Ok(IpAddr::V4(ipv4)) = address.parse::<IpAddr>() {
+            ipv4.is_loopback() // Check if the address is a loopback address
+        } else {
+            address.eq_ignore_ascii_case("localhost") // or 'false'
+        }
+    }
+    //if server_address != "localhost" && server_address != "127.0.0.1" {
+    if !is_local_address(&server_address) {
         println!("You are about to publish to a non-local server: {}", server_address);
         if !y_or_n(force, "Are you sure you want to proceed?")? {
             println!("Aborting");
diff --git a/crates/cli/src/subcommands/server.rs b/crates/cli/src/subcommands/server.rs
index 611919a6..3f8c6bcf 100644
--- a/crates/cli/src/subcommands/server.rs
+++ b/crates/cli/src/subcommands/server.rs
@@ -10,6 +10,7 @@ use tabled::{
     settings::{object::Columns, Alignment, Modify, Style},
     Table, Tabled,
 };
+use std::path::Path;
 
 pub fn cli() -> Command {
     Command::new("server")
@@ -53,6 +54,14 @@ fn get_subcommands() -> Vec<Command> {
                     .help("Skip fingerprinting the server")
                     .long("no-fingerprint")
                     .action(ArgAction::SetTrue),
+            )
+            .arg(
+                clap::Arg::new("cert")
+                .long("cert")
+                .help("Path to a PEM-encoded CA certificate for TLS verification, ie. treated as if it were in the cert trust store.")
+                .value_name("FILE")
+                .value_parser(clap::value_parser!(std::path::PathBuf))
+                .required(false),
             ),
         Command::new("remove")
             .about("Remove a saved server configuration")
@@ -69,6 +78,14 @@ fn get_subcommands() -> Vec<Command> {
                     .required(true)
                     .help("The nickname, host name or URL of the server"),
             )
+            .arg(
+                clap::Arg::new("cert")
+                .long("cert")
+                .help("Path to a PEM-encoded CA certificate for TLS verification, ie. treated as if it were in the cert trust store.")
+                .value_name("FILE")
+                .value_parser(clap::value_parser!(std::path::PathBuf))
+                .required(false),
+            )
             .arg(common_args::yes()),
         Command::new("ping")
             .about("Checks to see if a SpacetimeDB host is online")
@@ -76,6 +93,14 @@ fn get_subcommands() -> Vec<Command> {
                 Arg::new("server")
                     .required(true)
                     .help("The nickname, host name or URL of the server to ping"),
+            )
+            .arg(
+                clap::Arg::new("cert")
+                .long("cert")
+                .help("Path to a PEM-encoded CA certificate for TLS verification, ie. treated as if it were in the cert trust store.")
+                .value_name("FILE")
+                .value_parser(clap::value_parser!(std::path::PathBuf))
+                .required(false),
             ),
         Command::new("edit")
             .about("Update a saved server's nickname, host name or protocol")
@@ -100,6 +125,14 @@ fn get_subcommands() -> Vec<Command> {
                     .long("no-fingerprint")
                     .action(ArgAction::SetTrue),
             )
+            .arg(
+                clap::Arg::new("cert")
+                .long("cert")
+                .help("Path to a PEM-encoded CA certificate for TLS verification, ie. treated as if it were in the cert trust store.")
+                .value_name("FILE")
+                .value_parser(clap::value_parser!(std::path::PathBuf))
+                .required(false),
+            )
             .arg(common_args::yes()),
         Command::new("clear")
             .about("Deletes all data from all local databases")
@@ -195,6 +228,11 @@ pub async fn exec_add(mut config: Config, args: &ArgMatches) -> Result<(), anyho
     let nickname = args.get_one::<String>("name");
     let default = *args.get_one::<bool>("default").unwrap();
     let no_fingerprint = *args.get_one::<bool>("no-fingerprint").unwrap();
+    let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+
+    if no_fingerprint && cert_path.is_some() {
+        eprintln!("WARNING: --cert ignored while using --no-fingerprint");
+    }
 
     let (host, protocol) = host_or_url_to_host_and_protocol(url);
     let protocol = protocol.ok_or_else(|| anyhow::anyhow!("Invalid url: {}", url))?;
@@ -204,12 +242,13 @@ pub async fn exec_add(mut config: Config, args: &ArgMatches) -> Result<(), anyho
     let fingerprint = if no_fingerprint {
         None
     } else {
-        let fingerprint = spacetime_server_fingerprint(url).await.with_context(|| {
+        let fingerprint = spacetime_server_fingerprint(url, cert_path).await.with_context(|| {
             format!(
                 "Unable to retrieve fingerprint for server: {url}
 Is the server running?
 Add a server without retrieving its fingerprint with:
-\tspacetime server add --url {url} --no-fingerprint",
+\tspacetime server add --url {url} --no-fingerprint
+or provide a trusted --cert."
             )
         })?;
         println!("For server {}, got fingerprint:\n{}", url, fingerprint);
@@ -224,7 +263,6 @@ Add a server without retrieving its fingerprint with:
 
     println!("Host: {}", host);
     println!("Protocol: {}", protocol);
-
     config.save();
 
     Ok(())
@@ -240,25 +278,45 @@ pub async fn exec_remove(mut config: Config, args: &ArgMatches) -> Result<(), an
     Ok(())
 }
 
-async fn update_server_fingerprint(config: &mut Config, server: Option<&str>) -> Result<bool, anyhow::Error> {
-    let url = config.get_host_url(server)?;
-    let nick_or_host = config.server_nick_or_host(server)?;
-    let new_fing = spacetime_server_fingerprint(&url)
+async fn update_server_fingerprint(
+    config: &mut Config,
+    server: Option<&str>,
+    cert_path: Option<&Path>,
+    protocol: Option<&str>,
+) -> Result<bool, anyhow::Error> {
+    let (host, proto, nick_or_host) = match server {
+        Some(s) => {
+            let (h, p) = host_or_url_to_host_and_protocol(s);
+            let p = p.or(protocol).ok_or_else(|| {
+                anyhow::anyhow!(
+                    "Protocol not specified and server {} is ambiguous",
+                    h
+                )
+            })?;
+            (h.to_string(), p.to_string(), s.to_string())
+        }
+        None => {
+            let url = config.get_host_url(None)?;
+            let (h, p) = host_or_url_to_host_and_protocol(&url);
+            let p = p.ok_or_else(|| anyhow::anyhow!("Default server has no protocol"))?;
+            let nick = config.server_nick_or_host(None)?.to_string();
+            (h.to_string(), p.to_string(), nick)
+        }
+    };
+    let url = format!("{}://{}", proto, host);
+    let new_fing = spacetime_server_fingerprint(&url, cert_path)
         .await
         .context("Error fetching server fingerprint")?;
-    if let Some(saved_fing) = config.server_fingerprint(server)? {
+    if let Some(saved_fing) = config.server_fingerprint(Some(&host), Some(&proto))? {
         if saved_fing == new_fing {
             println!("Fingerprint is unchanged for server {}:\n{}", nick_or_host, saved_fing);
-
             Ok(false)
         } else {
             println!(
                 "Fingerprint has changed for server {}.\nWas:\n{}\nNew:\n{}",
                 nick_or_host, saved_fing, new_fing
             );
-
-            config.set_server_fingerprint(server, new_fing)?;
-
+            config.set_server_fingerprint(Some(&host), new_fing)?;
             Ok(true)
         }
     } else {
@@ -266,9 +324,7 @@ async fn update_server_fingerprint(config: &mut Config, server: Option<&str>) ->
             "No saved fingerprint for server {}. New fingerprint:\n{}",
             nick_or_host, new_fing
         );
-
-        config.set_server_fingerprint(server, new_fing)?;
-
+        config.set_server_fingerprint(Some(&host), new_fing)?;
         Ok(true)
     }
 }
@@ -276,8 +332,10 @@ async fn update_server_fingerprint(config: &mut Config, server: Option<&str>) ->
 pub async fn exec_fingerprint(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::Error> {
     let server = args.get_one::<String>("server").unwrap().as_str();
     let force = args.get_flag("force");
+    let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
 
-    if update_server_fingerprint(&mut config, Some(server)).await? {
+    let (host, protocol) = host_or_url_to_host_and_protocol(server);
+    if update_server_fingerprint(&mut config, Some(host), cert_path, protocol).await? {
         if !y_or_n(force, "Continue?")? {
             anyhow::bail!("Aborted");
         }
@@ -291,8 +349,27 @@ pub async fn exec_fingerprint(mut config: Config, args: &ArgMatches) -> Result<(
 pub async fn exec_ping(config: Config, args: &ArgMatches) -> Result<(), anyhow::Error> {
     let server = args.get_one::<String>("server").unwrap().as_str();
     let url = config.get_host_url(Some(server))?;
+    let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+
+    async fn build_client(cert_path: Option<&std::path::Path>) -> anyhow::Result<reqwest::Client> {
+        let mut client_builder = reqwest::Client::builder();
+
+        if let Some(path) = cert_path {
+            let cert_pem = tokio::fs::read_to_string(path)
+                .await
+                .map_err(|e| anyhow::anyhow!("Failed to read certificate file {} err: {}", path.display(), e))?;
+            let cert = reqwest::Certificate::from_pem(cert_pem.as_bytes())
+                .map_err(|e| anyhow::anyhow!("Failed to parse certificate file {} err: {}", path.display(), e))?;
+            client_builder = client_builder.add_root_certificate(cert);
+        }
+
+        client_builder
+            .build()
+            .map_err(|e| anyhow::anyhow!("Failed to build client with cert {:?} err: {}", cert_path, e))
+    }
 
-    let builder = reqwest::Client::new().get(format!("{}/v1/ping", url).as_str());
+    let client = build_client(cert_path).await?;
+    let builder = client.get(format!("{}/v1/ping", url).as_str());
     let response = builder.send().await?;
 
     match response.status() {
@@ -342,6 +419,7 @@ pub async fn exec_edit(mut config: Config, args: &ArgMatches) -> Result<(), anyh
         println!("Changing host from {} to {}", old_host, new_host);
     }
     if let (Some(new_proto), Some(old_proto)) = (new_proto, old_proto) {
+        //FIXME: Changing protocol from https to https
         println!("Changing protocol from {} to {}", old_proto, new_proto);
     }
 
@@ -351,7 +429,8 @@ pub async fn exec_edit(mut config: Config, args: &ArgMatches) -> Result<(), anyh
         if no_fingerprint {
             config.delete_server_fingerprint(Some(&new_url))?;
         } else {
-            update_server_fingerprint(&mut config, Some(&new_url)).await?;
+            let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+            update_server_fingerprint(&mut config, Some(&new_url), cert_path, new_proto).await?;
         }
     }
 
diff --git a/crates/cli/src/subcommands/sql.rs b/crates/cli/src/subcommands/sql.rs
index 8e6cac17..252cc39f 100644
--- a/crates/cli/src/subcommands/sql.rs
+++ b/crates/cli/src/subcommands/sql.rs
@@ -37,6 +37,14 @@ pub fn cli() -> clap::Command {
         .arg(common_args::anonymous())
         .arg(common_args::server().help("The nickname, host name or URL of the server hosting the database"))
         .arg(common_args::yes())
+        .arg(
+            Arg::new("cert")
+            .long("cert")
+            .value_name("FILE")
+            .action(clap::ArgAction::Set)
+            .value_parser(clap::value_parser!(std::path::PathBuf))
+            .help("Path to the server’s self-signed certificate or CA certificate (PEM format) to trust"),
+        )
 }
 
 pub(crate) async fn parse_req(mut config: Config, args: &ArgMatches) -> Result<Connection, anyhow::Error> {
@@ -45,10 +53,11 @@ pub(crate) async fn parse_req(mut config: Config, args: &ArgMatches) -> Result<C
     let database_name_or_identity = args.get_one::<String>("database").unwrap();
     let anon_identity = args.get_flag("anon_identity");
 
+    let client = reqwest::Client::new();//TODO: see where this is for 'spacetime sql'
     Ok(Connection {
         host: config.get_host_url(server)?,
         auth_header: get_auth_header(&mut config, anon_identity, server, !force).await?,
-        database_identity: database_identity(&config, database_name_or_identity, server).await?,
+        database_identity: database_identity(&config, database_name_or_identity, server, &client).await?,
         database: database_name_or_identity.to_string(),
     })
 }
diff --git a/crates/cli/src/util.rs b/crates/cli/src/util.rs
index 20e0591c..1fcfa214 100644
--- a/crates/cli/src/util.rs
+++ b/crates/cli/src/util.rs
@@ -17,11 +17,12 @@ pub async fn database_identity(
     config: &Config,
     name_or_identity: &str,
     server: Option<&str>,
+    client: &reqwest::Client,
 ) -> Result<Identity, anyhow::Error> {
     if let Ok(identity) = Identity::from_hex(name_or_identity) {
         return Ok(identity);
     }
-    spacetime_dns(config, name_or_identity, server)
+    spacetime_dns(config, name_or_identity, server, client)
         .await?
         .with_context(|| format!("the dns resolution of `{name_or_identity}` failed."))
 }
@@ -111,8 +112,9 @@ pub async fn spacetime_dns(
     config: &Config,
     domain: &str,
     server: Option<&str>,
+    client: &reqwest::Client,
 ) -> Result<Option<Identity>, anyhow::Error> {
-    let client = reqwest::Client::new();
+    //let client = reqwest::Client::new();
     let url = format!("{}/v1/database/{}/identity", config.get_host_url(server)?, domain);
     let Some(res) = client.get(url).send().await?.found() else {
         return Ok(None);
@@ -123,8 +125,20 @@ pub async fn spacetime_dns(
         .context("identity endpoint did not return an identity")
 }
 
-pub async fn spacetime_server_fingerprint(url: &str) -> anyhow::Result<String> {
-    let builder = reqwest::Client::new().get(format!("{}/v1/identity/public-key", url).as_str());
+pub async fn spacetime_server_fingerprint(url: &str, cert_path: Option<&Path>) -> anyhow::Result<String> {
+    let mut builder = reqwest::Client::builder();
+    if let Some(path) = cert_path {
+        if !url.starts_with("https") {
+            eprintln!("WARNING: Non-https url '{url}' but --cert was specified.");
+        }
+        let cert_pem = std::fs::read_to_string(path)
+            .with_context(|| format!("Failed to read certificate file: {}", path.display()))?;
+        let cert = reqwest::Certificate::from_pem(cert_pem.as_bytes())
+            .map_err(|e| anyhow::anyhow!("Invalid certificate: {}", e))?;
+        builder = builder.add_root_certificate(cert);
+    }
+    let client = builder.build().map_err(|e| anyhow::anyhow!("Failed to build client: {}", e))?;
+    let builder = client.get(format!("{}/v1/identity/public-key", url).as_str());
     let res = builder.send().await?.error_for_status()?;
     let fingerprint = res.text().await?;
     Ok(fingerprint)
@@ -314,9 +328,9 @@ pub async fn get_login_token_or_log_in(
 
     if full_login {
         let host = Url::parse(DEFAULT_AUTH_HOST)?;
-        spacetimedb_login_force(config, &host, false).await
+        spacetimedb_login_force(config, &host, false, None/*TODO*/).await
     } else {
         let host = Url::parse(&config.get_host_url(target_server)?)?;
-        spacetimedb_login_force(config, &host, true).await
+        spacetimedb_login_force(config, &host, true, None/*TODO*/).await
     }
 }
diff --git a/crates/sdk/Cargo.toml b/crates/sdk/Cargo.toml
index 9daa2a98..739b7ccf 100644
--- a/crates/sdk/Cargo.toml
+++ b/crates/sdk/Cargo.toml
@@ -29,6 +29,10 @@ prometheus.workspace = true
 rand.workspace = true
 tokio.workspace = true
 tokio-tungstenite.workspace = true
+rustls = "0.23"
+rustls-pemfile = "2.2.0"
+#tokio-rustls="0.24"
+native-tls = "0.2"  # Explicitly add for Connector::NativeTls
 
 [dev-dependencies]
 # for quickstart-chat and cursive-chat examples
diff --git a/crates/sdk/examples/quickstart-chat/main.rs b/crates/sdk/examples/quickstart-chat/main.rs
index e04ff9cb..e2b0a5cf 100644
--- a/crates/sdk/examples/quickstart-chat/main.rs
+++ b/crates/sdk/examples/quickstart-chat/main.rs
@@ -5,11 +5,20 @@ use module_bindings::*;
 
 use spacetimedb_sdk::{credentials, DbContext, Error, Event, Identity, Status, Table, TableWithPrimaryKey};
 
+use std::path::PathBuf;
+
+
 // ## Define the main function
 
 fn main() {
-    // Connect to the database
-    let ctx = connect_to_db();
+    // ### Parse command-line arguments for --cert into a PathBuf
+    let args: Vec<String> = std::env::args().collect();
+    let cert_path: Option<PathBuf> = args.iter()
+        .position(|arg| arg == "--cert")
+        .map(|i| args.get(i + 1).expect("Missing certificate path after --cert"))
+        .map(|s| PathBuf::from(s));
+    // Connect to the database with optional cert
+    let ctx = connect_to_db(cert_path);
 
     // Register callbacks to run in response to database events.
     register_callbacks(&ctx);
@@ -26,15 +35,21 @@ fn main() {
 
 // ## Connect to the database
 
-/// The URI of the SpacetimeDB instance hosting our chat module.
-const HOST: &str = "http://localhost:3000";
+/// The host and port, without scheme, of the SpacetimeDB instance hosting our chat module.
+const HOST_PORT: &str = "localhost:3000";
+//const HOST_PORT: &str = "127.1.2.3:6543";
 
 /// The module name we chose when we published our module.
 const DB_NAME: &str = "quickstart-chat";
 
 /// Load credentials from a file and connect to the database.
-fn connect_to_db() -> DbConnection {
-    DbConnection::builder()
+fn connect_to_db(cert_path: Option<PathBuf>) -> DbConnection {
+    // ### Construct URI with scheme based on cert presence
+    let scheme = if cert_path.is_some() { "https" } else { "http" };
+    let uri = format!("{}://{}", scheme, HOST_PORT);
+
+//    let mut builder=
+        DbConnection::builder()
         // Register our `on_connect` callback, which will save our auth token.
         .on_connect(on_connected)
         // Register our `on_connect_error` callback, which will print a message, then exit the process.
@@ -48,7 +63,17 @@ fn connect_to_db() -> DbConnection {
         // Set the database name we chose when we called `spacetime publish`.
         .with_module_name(DB_NAME)
         // Set the URI of the SpacetimeDB host that's running our database.
-        .with_uri(HOST)
+        .with_uri(&uri)
+//;    // ### Add trusted cert if provided
+//    if let Some(cert_path) = cert_path {
+//    //XXX: we don't wanna do this(that's why it's accepting Option instead):
+//        builder = builder.with_trusted_cert(cert_path);
+//    }
+//     // Finalize configuration and connect!
+//     builder.build()
+//         .expect("Failed to connect")
+        // ### Add trusted cert if provided
+        .with_trusted_cert(cert_path)
         // Finalize configuration and connect!
         .build()
         .expect("Failed to connect")
diff --git a/crates/sdk/src/db_connection.rs b/crates/sdk/src/db_connection.rs
index e1e4133e..9c6a300b 100644
--- a/crates/sdk/src/db_connection.rs
+++ b/crates/sdk/src/db_connection.rs
@@ -748,6 +748,8 @@ pub struct DbConnectionBuilder<M: SpacetimeModule> {
     on_disconnect: Option<OnDisconnectCallback<M>>,
 
     params: WsParams,
+
+    trusted_cert: Option<std::path::PathBuf>,
 }
 
 /// This process's global connection ID, which will be attacked to all connections it makes.
@@ -794,6 +796,7 @@ impl<M: SpacetimeModule> DbConnectionBuilder<M> {
             on_connect_error: None,
             on_disconnect: None,
             params: <_>::default(),
+            trusted_cert: None,
         }
     }
 
@@ -841,6 +844,7 @@ but you must call one of them, or else the connection will never progress.
                 self.token.as_deref(),
                 get_connection_id(),
                 self.params,
+                self.trusted_cert.as_ref(),
             ))
         })
         .map_err(|source| crate::Error::FailedToConnect {
@@ -892,6 +896,15 @@ but you must call one of them, or else the connection will never progress.
         self
     }
 
+//    pub fn with_trusted_cert(mut self, cert: impl Into<std::path::PathBuf>) -> Self {
+//        self.trusted_cert = Some(cert.into());
+//        self
+//    }
+    pub fn with_trusted_cert(mut self, cert: Option<impl Into<std::path::PathBuf>>) -> Self {
+        self.trusted_cert = cert.map(|c| c.into());
+        self
+    }
+
     /// Set the name or identity of the remote module.
     pub fn with_module_name(mut self, name_or_identity: impl Into<String>) -> Self {
         self.module_name = Some(name_or_identity.into());
diff --git a/crates/sdk/src/websocket.rs b/crates/sdk/src/websocket.rs
index 436520d5..ac21fa7b 100644
--- a/crates/sdk/src/websocket.rs
+++ b/crates/sdk/src/websocket.rs
@@ -21,10 +21,11 @@ use tokio::task::JoinHandle;
 use tokio::time::Instant;
 use tokio::{net::TcpStream, runtime};
 use tokio_tungstenite::{
-    connect_async_with_config,
+    //connect_async_with_config,
     tungstenite::client::IntoClientRequest,
     tungstenite::protocol::{Message as WebSocketMessage, WebSocketConfig},
-    MaybeTlsStream, WebSocketStream,
+    MaybeTlsStream,
+    WebSocketStream,
 };
 
 use crate::metrics::CLIENT_METRICS;
@@ -207,19 +208,85 @@ impl WsConnection {
         token: Option<&str>,
         connection_id: ConnectionId,
         params: WsParams,
+        trusted_cert: Option<&std::path::PathBuf>, // Changed to borrow PathBuf
     ) -> Result<Self, WsError> {
         let req = make_request(host, db_name, token, connection_id, params)?;
 
         // Grab the URI for error-reporting.
         let uri = req.uri().clone();
 
-        let (sock, _): (WebSocketStream<MaybeTlsStream<TcpStream>>, _) = connect_async_with_config(
+        let host = uri.clone(); //shadow, and it's thus wss:// not https://
+        use native_tls::Certificate;
+        use native_tls::TlsConnector;
+        use std::sync::Arc;
+        use tokio::net::TcpStream;
+        use tokio_tungstenite::{client_async_tls_with_config, Connector, MaybeTlsStream, WebSocketStream};
+
+        let host_str = host.host().ok_or(WsError::UriError(UriError::InvalidUri {
+            source: Arc::new("No host in URI".parse::<Uri>().unwrap_err().into()),
+        }))?;
+        let port = host.port_u16().ok_or(WsError::UriError(UriError::InvalidUri {
+            source: Arc::new("No port specified in URI".parse::<Uri>().unwrap_err().into()),
+        }))?;
+        if port == 0 {
+            //|| port > 65535 {
+            return Err(WsError::UriError(UriError::InvalidUri {
+                source: Arc::new(format!("Invalid port: {}", port).parse::<Uri>().unwrap_err().into()),
+            }));
+        }
+
+        let tcp_stream = TcpStream::connect((host_str, port))
+            .await
+            .map_err(|source| WsError::Tungstenite {
+                uri: uri.clone(),
+                source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(source)),
+            })?;
+
+        let connector = if host.scheme_str() == Some("wss") {
+            let mut builder = TlsConnector::builder();
+            if let Some(cert_path) = trusted_cert {
+                let cert_pem = std::fs::read_to_string(cert_path).map_err(|e| WsError::Tungstenite {
+                    uri: uri.clone(),
+                    source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                        e.kind(),
+                        format!("Failed to read cert file '{}': {}", cert_path.display(), e),
+                    ))),
+                })?;
+                let cert = Certificate::from_pem(cert_pem.as_bytes()).map_err(|e| WsError::Tungstenite {
+                    uri: uri.clone(),
+                    source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                        std::io::ErrorKind::InvalidData,
+                        format!("Failed to parse PEM cert file '{}': {}", cert_path.display(), e),
+                    ))),
+                })?;
+                builder.add_root_certificate(cert);
+            } else {
+                println!("Didn't add trusted cert file {:?}", trusted_cert);
+            }
+            let tls_connector = builder.build().map_err(|e| WsError::Tungstenite {
+                uri: uri.clone(),
+                source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                    std::io::ErrorKind::Other,
+                    e,
+                ))),
+            })?;
+            Some(Connector::NativeTls(tls_connector))
+        } else {
+            //This is probably just ws:// ie. from http:// aka plaintext non-TLS
+            //println!("!!! Unexpected non-wss:// scheme, is: {}", uri);
+            None
+        };
+
+        let (sock, _): (WebSocketStream<MaybeTlsStream<TcpStream>>, _) = client_async_tls_with_config(
+//        let (sock, _): (WebSocketStream<MaybeTlsStream<TcpStream>>, _) = connect_async_with_config(
             req,
+            tcp_stream,
             // TODO(kim): In order to be able to replicate module WASM blobs,
             // `cloud-next` cannot have message / frame size limits. That's
             // obviously a bad default for all other clients, though.
             Some(WebSocketConfig::default().max_frame_size(None).max_message_size(None)),
-            false,
+            connector
+//            false,
         )
         .await
         .map_err(|source| WsError::Tungstenite {
@@ -231,7 +298,7 @@ impl WsConnection {
             connection_id,
             sock,
         })
-    }
+    } //connect(
 
     pub(crate) fn parse_response(bytes: &[u8]) -> Result<ServerMessage<BsatnFormat>, WsError> {
         let (compression, bytes) = bytes.split_first().ok_or(WsError::EmptyMessage)?;
diff --git a/crates/standalone/Cargo.toml b/crates/standalone/Cargo.toml
index 5207edf4..61a191de 100644
--- a/crates/standalone/Cargo.toml
+++ b/crates/standalone/Cargo.toml
@@ -29,6 +29,15 @@ spacetimedb-paths.workspace = true
 anyhow.workspace = true
 async-trait.workspace = true
 axum.workspace = true
+
+# Add this for TLS support
+#axum-server = "0.6"  # Compatible with axum 0.7.9
+#axum-server = "0.7"  # Compatible with axum 0.7.9
+axum-server = { version = "0.7.2", features = ["tls-rustls"] }
+
+ring = "0.17"  # explicitly add this for the CryptoProvider, even tho it's included transitively.
+rustls= { version="0.23", default-features = true, features=[ "ring" ] }
+
 clap = { workspace = true, features = ["derive", "string"] }
 dirs.workspace = true
 futures.workspace = true
diff --git a/crates/standalone/src/subcommands/start.rs b/crates/standalone/src/subcommands/start.rs
index d74267c6..89740907 100644
--- a/crates/standalone/src/subcommands/start.rs
+++ b/crates/standalone/src/subcommands/start.rs
@@ -13,7 +13,7 @@ use spacetimedb_client_api::routes::database::DatabaseRoutes;
 use spacetimedb_client_api::routes::router;
 use spacetimedb_paths::cli::{PrivKeyPath, PubKeyPath};
 use spacetimedb_paths::server::ServerDataDir;
-use tokio::net::TcpListener;
+//use tokio::net::TcpListener;
 
 pub fn cli() -> clap::Command {
     clap::Command::new("start")
@@ -67,6 +67,9 @@ pub fn cli() -> clap::Command {
         .arg(Arg::new("in_memory").long("in-memory").action(SetTrue).help(
             "If specified the database will run entirely in memory. After the process exits all data will be lost.",
         ))
+        .arg(Arg::new("ssl").long("ssl").alias("tls").alias("https").alias("secure").action(clap::ArgAction::SetTrue).help("enables the standalone server to listen in SSL mode, ie. use https instead of http to connect to it. Aliases --tls, --ssl, --secure, or --https."))
+        .arg(Arg::new("cert").long("cert").requires("ssl").value_name("FILE").help("--cert cert.pem: The server sends this to clients during the TLS handshake. ie. server's public key, which if it's self-signed then this is the file that you pass to clients via --cert when talking to the server from a client(or the cli), or if signed by a local CA then pass that CA's pub cert to your clients instead, in order to can trust this server from a client connection. Otherwise, you don't have to pass anything to clients if this cert was signed by a public CA like Let's Encrypt."))
+        .arg(Arg::new("key").long("key").requires("ssl").value_name("FILE").help("--key key.pem: The server keeps this private to decrypt and sign responses. ie. the server's private key"))
     // .after_help("Run `spacetime help start` for more detailed information.")
 }
 
@@ -143,13 +146,39 @@ pub async fn exec(args: &ArgMatches) -> anyhow::Result<()> {
     let extra = axum::Router::new().nest("/health", spacetimedb_client_api::routes::health::router());
     let service = router(&ctx, db_routes, extra).with_state(ctx);
 
-    let tcp = TcpListener::bind(listen_addr).await?;
-    socket2::SockRef::from(&tcp).set_nodelay(true)?;
-    log::debug!("Starting SpacetimeDB listening on {}", tcp.local_addr().unwrap());
-    axum::serve(tcp, service).await?;
+//    let tcp = TcpListener::bind(listen_addr).await?;
+//    socket2::SockRef::from(&tcp).set_nodelay(true)?;
+//    log::debug!("Starting SpacetimeDB listening on {}", tcp.local_addr().unwrap());
+//    axum::serve(tcp, service).await?;
+    use std::net::SocketAddr;
+    let addr: SocketAddr = listen_addr.parse()?;
+    if args.get_flag("ssl") {
+        let cert_path = args.get_one::<String>("cert").context("Missing --cert for SSL")?;
+        let key_path = args.get_one::<String>("key").context("Missing --key for SSL")?;
+        // Install the default CryptoProvider at the start of the function
+        // This only needs to happen once per process, so it's safe to call here
+        use rustls::crypto::ring::default_provider;  // Add this
+        use rustls::crypto::CryptoProvider;          // Add this
+        CryptoProvider::install_default(default_provider())
+            .expect("Failed to install default CryptoProvider");
+
+        use axum_server::tls_rustls::RustlsConfig;
+        let tls_config = RustlsConfig::from_pem_file(cert_path, key_path).await?;
+        log::debug!("Starting SpacetimeDB with SSL listening on {}", addr);
+        axum_server::bind_rustls(addr, tls_config)
+            .serve(service.into_make_service())
+            .await?;
+    } else {
+        log::debug!("Starting SpacetimeDB without any ssl (so it's plaintext) listening on {}", addr);
+        axum_server::bind(addr)
+            .serve(service.into_make_service())
+            .await?;
+    }
+
     Ok(())
 }
 
+#[allow(dead_code)]
 fn banner() {
     println!(
         r#"
