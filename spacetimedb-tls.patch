Adds ability to listen as https via TLS 1.3 for SpacetimeDB standalone server with self-signed or CA-signed certs, and allows clients(rust, cli) to pass --cert with a trusted cert (like server's self-signed cert or CA's public cert) to not fail signature check.

Currently limited to TLS 1.3 only, but can be changed in source code to allow TLS 1.2 also.

Future updates should be here: https://github.com/dare3path/spacetimedb-tls-patch
While this is still a work in progress, proof-of-concept patch, it works as intended so far that I'm aware of: so the rust client and all cli commands that I'm aware of accept --cert, though they already worked as TLS clients before(ie. if you server cert was signed by a known CA, otherwise you need --cert).

This patch is already an upstream _draft_ PR here:
https://github.com/clockworklabs/SpacetimeDB/pull/2598
it's meant to remain as a draft, never-to-be-merged mainly because actual devs can do this in a better way, so it's only meant to be an example, working, proof-of-concept patch.

patch is to be applied on latest master, currently:
commit 651f79d22cc4bb1c3c996ef2436186501a5d83bd (origin/master, origin/HEAD, master)


The features that this patch confers are as follows:

======
the spacetime standalone server can listen for incoming TLS connections if you use the --ssl arg, but plaintext ones(like without this patch) aren't accepted unless you stop it and start it without the --ssl arg.

clients already could connect to it via TLS, however the server's cert must've been signed by a trusted(in root store) CA (certificate authority) already, however you can use --cert as mentioned below:
======
You can use --cert for most cli commands(including the rust quickstart-chat example) to add a public certificate to trust (ie. as if it were part of the cert trust store) which can thus be either the server's public cert, or the CA's public cert which is the CA that signed the server's public cert. This way, the client knows the server's public cert is trusted and will connect successfully rather than fail with untrusted signature.
======
These subcommands support --cert (to add a trusted cert file(public) to the client to can authenticate the server):
spacetime server add
spacetime server edit
spacetime server fingerprint
spacetime server ping
spacetime publish
spacetime login
spacetime logs
spacetime delete
spacetime sql
spacetime describe
spacetime subscribe
spacetime call
spacetime start  (this requires passing --key and --ssl also)
spacetime rename
spacetime list
spacetime energy balance
======
These subcommands consider the protocol(eg. https or http) as a unique identifier along with the host and port:
$ spacetime server set-default
$ spacetime server add
$ spacetime server remove
$ spacetime server edit
$ spacetime server fingerprint
$ spacetime server ping

ie. you can have these:

$ spacetime server list
WARNING: This command is UNSTABLE and subject to breaking changes.

 DEFAULT  HOSTNAME                   PROTOCOL  NICKNAME  
          maincloud.spacetimedb.com  https     maincloud 
          127.0.0.1:3000             http      local     
          127.0.0.1:3001             http      local2    
          127.0.0.1:3000             https     slocal    
          127.0.0.1:3001             https     slocal2   

======
You get a warning when using `spacetime login --server-issued-login server` that this `server` isn't the one that cli commands like `spacetime publish`(with no args) will use, but it's the 3 star default one in `spacetime server list` instead.
======
FIXME: the changes in config.rs are supremely hacky, since the original code disregarded protocol as uniquely identifying in addition to the server+port in the list of `spacetime server list`, so there are functions that take only host:port and assume there's only one in the list where in fact now they can be two or more: one for each proto (http, https)
//But seems this is so due to the inability to run more than one spacetimedb (standalone)server per user, since the .pid file is kept in /home/user/.local/share/spacetime/data/spacetime.pid for any/all running instances and thus prevents running more than 1 instance. Unless, --data-dir is specified, then can have multiple instances after all, hmm...
======
avoids OOM if you pass --cert /dev/zero
======


diff --git a/Cargo.lock b/Cargo.lock
index 5b15f068..7e74cb9a 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -194,6 +194,12 @@ dependencies = [
  "derive_arbitrary",
 ]
 
+[[package]]
+name = "arc-swap"
+version = "1.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "69f7f8c3906b62b754cd5326047894316021dcfe5a194c8ea52bdd94934a3457"
+
 [[package]]
 name = "arrayref"
 version = "0.3.9"
@@ -292,6 +298,29 @@ version = "1.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26"
 
+[[package]]
+name = "aws-lc-rs"
+version = "1.13.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "19b756939cb2f8dc900aa6dcd505e6e2428e9cae7ff7b028c49e3946efa70878"
+dependencies = [
+ "aws-lc-sys",
+ "zeroize",
+]
+
+[[package]]
+name = "aws-lc-sys"
+version = "0.28.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b9f7720b74ed28ca77f90769a71fd8c637a0137f6fae4ae947e1050229cff57f"
+dependencies = [
+ "bindgen",
+ "cc",
+ "cmake",
+ "dunce",
+ "fs_extra",
+]
+
 [[package]]
 name = "axum"
 version = "0.7.7"
@@ -370,6 +399,28 @@ dependencies = [
  "tracing",
 ]
 
+[[package]]
+name = "axum-server"
+version = "0.7.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "495c05f60d6df0093e8fb6e74aa5846a0ad06abaf96d76166283720bf740f8ab"
+dependencies = [
+ "arc-swap",
+ "bytes",
+ "fs-err 3.1.0",
+ "http 1.1.0",
+ "http-body 1.0.1",
+ "hyper 1.5.0",
+ "hyper-util",
+ "pin-project-lite",
+ "rustls",
+ "rustls-pemfile 2.2.0",
+ "rustls-pki-types",
+ "tokio",
+ "tokio-rustls",
+ "tower-service",
+]
+
 [[package]]
 name = "backtrace"
 version = "0.3.74"
@@ -427,6 +478,29 @@ dependencies = [
  "serde",
 ]
 
+[[package]]
+name = "bindgen"
+version = "0.69.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "271383c67ccabffb7381723dea0672a673f292304fcb45c01cc648c7a8d58088"
+dependencies = [
+ "bitflags 2.6.0",
+ "cexpr",
+ "clang-sys",
+ "itertools 0.12.1",
+ "lazy_static",
+ "lazycell",
+ "log",
+ "prettyplease",
+ "proc-macro2",
+ "quote",
+ "regex",
+ "rustc-hash 1.1.0",
+ "shlex",
+ "syn 2.0.87",
+ "which",
+]
+
 [[package]]
 name = "bit-set"
 version = "0.5.3"
@@ -704,6 +778,15 @@ version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6d43a04d8753f35258c91f8ec639f792891f748a1edbd759cf1dcea3382ad83c"
 
+[[package]]
+name = "cexpr"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766"
+dependencies = [
+ "nom",
+]
+
 [[package]]
 name = "cfg-if"
 version = "1.0.0"
@@ -768,6 +851,17 @@ dependencies = [
  "inout",
 ]
 
+[[package]]
+name = "clang-sys"
+version = "1.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b023947811758c97c59bf9d1c188fd619ad4718dcaa767947df1cadb14f39f4"
+dependencies = [
+ "glob",
+ "libc",
+ "libloading",
+]
+
 [[package]]
 name = "clap"
 version = "3.2.23"
@@ -868,6 +962,15 @@ dependencies = [
  "winapi",
 ]
 
+[[package]]
+name = "cmake"
+version = "0.1.54"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e7caa3f9de89ddbe2c607f4101924c5abec803763ae9534e4f4d7d8f84aa81f0"
+dependencies = [
+ "cc",
+]
+
 [[package]]
 name = "cobs"
 version = "0.2.3"
@@ -1024,7 +1127,7 @@ dependencies = [
  "hashbrown 0.14.5",
  "log",
  "regalloc2",
- "rustc-hash",
+ "rustc-hash 2.0.0",
  "smallvec",
  "target-lexicon",
 ]
@@ -1525,6 +1628,12 @@ dependencies = [
  "shared_child",
 ]
 
+[[package]]
+name = "dunce"
+version = "1.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "92773504d58c093f6de2459af4af33faa518c13451eb8f2b5698ed3d36e7c813"
+
 [[package]]
 name = "educe"
 version = "0.4.23"
@@ -1847,6 +1956,16 @@ dependencies = [
  "autocfg",
 ]
 
+[[package]]
+name = "fs-err"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1f89bda4c2a21204059a977ed3bfe746677dfd137b83c339e702b0ac91d482aa"
+dependencies = [
+ "autocfg",
+ "tokio",
+]
+
 [[package]]
 name = "fs2"
 version = "0.4.3"
@@ -1857,6 +1976,12 @@ dependencies = [
  "winapi",
 ]
 
+[[package]]
+name = "fs_extra"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42703706b716c37f96a77aea830392ad231f44c9e9a67872fa5548707e11b11c"
+
 [[package]]
 name = "fuchsia-cprng"
 version = "0.1.1"
@@ -2901,6 +3026,12 @@ version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
+[[package]]
+name = "lazycell"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55"
+
 [[package]]
 name = "leb128"
 version = "0.2.5"
@@ -2913,6 +3044,16 @@ version = "0.2.162"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "18d287de67fe55fd7e1581fe933d965a5a9477b38e949cfa9f8574ef01506398"
 
+[[package]]
+name = "libloading"
+version = "0.8.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc2f4eb4bc735547cfed7c0a4922cbd04a4655978c09b54f1f7b228750664c34"
+dependencies = [
+ "cfg-if",
+ "windows-targets 0.52.6",
+]
+
 [[package]]
 name = "libm"
 version = "0.2.11"
@@ -3128,6 +3269,12 @@ version = "0.3.17"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"
 
+[[package]]
+name = "minimal-lexical"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"
+
 [[package]]
 name = "miniz_oxide"
 version = "0.8.0"
@@ -3219,6 +3366,16 @@ version = "0.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2bf50223579dc7cdcfb3bfcacf7069ff68243f8c363f62ffa99cf000a6b9c451"
 
+[[package]]
+name = "nom"
+version = "7.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
+dependencies = [
+ "memchr",
+ "minimal-lexical",
+]
+
 [[package]]
 name = "nu-ansi-term"
 version = "0.46.0"
@@ -3817,6 +3974,16 @@ dependencies = [
  "yansi",
 ]
 
+[[package]]
+name = "prettyplease"
+version = "0.2.25"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "64d1ec885c64d0457d564db4ec299b2dae3f9c02808b8ad9c3a089c591b18033"
+dependencies = [
+ "proc-macro2",
+ "syn 2.0.87",
+]
+
 [[package]]
 name = "proc-macro-crate"
 version = "3.2.0"
@@ -4221,7 +4388,7 @@ checksum = "12908dbeb234370af84d0579b9f68258a0f67e201412dd9a2814e6f45b2fc0f0"
 dependencies = [
  "hashbrown 0.14.5",
  "log",
- "rustc-hash",
+ "rustc-hash 2.0.0",
  "slice-group-by",
  "smallvec",
 ]
@@ -4475,6 +4642,12 @@ version = "0.1.24"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"
 
+[[package]]
+name = "rustc-hash"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"
+
 [[package]]
 name = "rustc-hash"
 version = "2.0.0"
@@ -4509,7 +4682,10 @@ version = "0.23.16"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "eee87ff5d9b36712a58574e12e9f0ea80f915a5b0ac518d322b24a465617925e"
 dependencies = [
+ "aws-lc-rs",
+ "log",
  "once_cell",
+ "ring",
  "rustls-pki-types",
  "rustls-webpki",
  "subtle",
@@ -4546,6 +4722,7 @@ version = "0.102.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "64ca1bc8749bd4cf37b5ce386cc146580777b4e8572c7b97baf22c83f444bee9"
 dependencies = [
+ "aws-lc-rs",
  "ring",
  "rustls-pki-types",
  "untrusted",
@@ -5121,7 +5298,7 @@ dependencies = [
  "duct",
  "email_address",
  "flate2",
- "fs-err",
+ "fs-err 2.11.0",
  "futures",
  "http 1.1.0",
  "indicatif",
@@ -5129,6 +5306,7 @@ dependencies = [
  "is-terminal",
  "itertools 0.12.1",
  "mimalloc",
+ "native-tls",
  "percent-encoding",
  "regex",
  "reqwest 0.12.9",
@@ -5325,7 +5503,7 @@ dependencies = [
  "regex",
  "reqwest 0.12.9",
  "rustc-demangle",
- "rustc-hash",
+ "rustc-hash 2.0.0",
  "scopeguard",
  "semver",
  "serde",
@@ -5495,12 +5673,14 @@ dependencies = [
  "blake3",
  "bytes",
  "chrono",
+ "clap 4.5.20",
  "derive_more",
  "enum-as-inner",
  "enum-map",
  "hex",
  "insta",
  "itertools 0.12.1",
+ "native-tls",
  "proptest",
  "proptest-derive",
  "ron",
@@ -5512,6 +5692,7 @@ dependencies = [
  "spacetimedb-primitives",
  "spacetimedb-sats",
  "thiserror 1.0.69",
+ "tokio",
 ]
 
 [[package]]
@@ -5648,6 +5829,7 @@ dependencies = [
 name = "spacetimedb-sdk"
 version = "1.1.0"
 dependencies = [
+ "anyhow",
  "anymap",
  "base64 0.21.7",
  "brotli",
@@ -5659,9 +5841,12 @@ dependencies = [
  "home",
  "http 1.1.0",
  "log",
+ "native-tls",
  "once_cell",
  "prometheus",
  "rand 0.9.0",
+ "rustls",
+ "rustls-pemfile 2.2.0",
  "spacetimedb-client-api-messages",
  "spacetimedb-data-structures",
  "spacetimedb-lib",
@@ -5719,6 +5904,7 @@ dependencies = [
  "anyhow",
  "async-trait",
  "axum",
+ "axum-server",
  "clap 4.5.20",
  "dirs",
  "futures",
@@ -5728,6 +5914,9 @@ dependencies = [
  "once_cell",
  "openssl",
  "prometheus",
+ "ring",
+ "rustls",
+ "rustls-pemfile 2.2.0",
  "scopeguard",
  "serde_json",
  "sled",
@@ -5878,7 +6067,7 @@ checksum = "78ea1056caa9180e7e5727eed1a377d96c9f4615303fa82d2f4c202c64736dee"
 dependencies = [
  "async-trait",
  "educe",
- "fs-err",
+ "fs-err 2.11.0",
  "futures",
  "glob",
  "humantime",
@@ -5936,7 +6125,7 @@ dependencies = [
  "clap 4.5.20",
  "console",
  "derive_more",
- "fs-err",
+ "fs-err 2.11.0",
  "futures",
  "glob",
  "itertools 0.12.1",
diff --git a/crates/cli/Cargo.toml b/crates/cli/Cargo.toml
index 591d80a3..eca986ec 100644
--- a/crates/cli/Cargo.toml
+++ b/crates/cli/Cargo.toml
@@ -74,6 +74,7 @@ wasmbin.workspace = true
 wasmtime.workspace = true
 webbrowser.workspace = true
 clap-markdown.workspace = true
+native-tls = "0.2"
 
 [target.'cfg(not(target_env = "msvc"))'.dependencies]
 tikv-jemallocator = { workspace = true }
diff --git a/crates/cli/src/api.rs b/crates/cli/src/api.rs
index d40b03ee..544a80b6 100644
--- a/crates/cli/src/api.rs
+++ b/crates/cli/src/api.rs
@@ -9,6 +9,8 @@ use spacetimedb_lib::de::serde::DeserializeWrapper;
 use spacetimedb_lib::Identity;
 
 use crate::util::{AuthHeader, ResponseExt};
+use crate::util;
+use std::path::PathBuf;
 
 static APP_USER_AGENT: &str = concat!(env!("CARGO_PKG_NAME"), "/", env!("CARGO_PKG_VERSION"),);
 
@@ -18,6 +20,7 @@ pub struct Connection {
     pub(crate) database_identity: Identity,
     pub(crate) database: String,
     pub(crate) auth_header: AuthHeader,
+    pub(crate) cert_path: Option<PathBuf>, // FIXME: bad idea to put it here? else pass it as arg?
 }
 
 impl Connection {
@@ -34,7 +37,13 @@ impl Connection {
 }
 
 pub fn build_client(con: &Connection) -> Client {
-    let mut builder = Client::builder().user_agent(APP_USER_AGENT);
+    //XXX: alternatively make this async and then make new() async, and ensure callers do .await on it
+    let mut builder = tokio::task::block_in_place(|| {
+        tokio::runtime::Handle::current()
+            .block_on(util::configure_tls(con.cert_path.as_deref()))
+    })
+    .unwrap();
+    builder = builder.user_agent(APP_USER_AGENT);
 
     if let Some(auth_header) = con.auth_header.to_header() {
         let headers = http::HeaderMap::from_iter([(header::AUTHORIZATION, auth_header)]);
@@ -42,7 +51,7 @@ pub fn build_client(con: &Connection) -> Client {
         builder = builder.default_headers(headers);
     }
 
-    builder.build().unwrap()
+    util::build_client_with_context(builder, con.cert_path.as_deref()).unwrap()
 }
 
 pub struct ClientApi {
diff --git a/crates/cli/src/common_args.rs b/crates/cli/src/common_args.rs
index a238ecbf..578d9363 100644
--- a/crates/cli/src/common_args.rs
+++ b/crates/cli/src/common_args.rs
@@ -1,5 +1,6 @@
 use clap::Arg;
 use clap::ArgAction::SetTrue;
+pub use spacetimedb_lib::cert;
 
 pub fn server() -> Arg {
     Arg::new("server")
diff --git a/crates/cli/src/config.rs b/crates/cli/src/config.rs
index 1e709b89..5bf0cf5e 100644
--- a/crates/cli/src/config.rs
+++ b/crates/cli/src/config.rs
@@ -177,21 +177,59 @@ impl RawConfig {
     }
 
     fn find_server(&self, name_or_host: &str) -> anyhow::Result<&ServerConfig> {
+        self.find_server_with_protocol(name_or_host, None)
+    }
+    fn find_server_with_protocol(&self, name_or_host: &str, protocol: Option<&str>) -> anyhow::Result<&ServerConfig> {
+        let mut matches = Vec::new();
         for cfg in &self.server_configs {
-            if cfg.nickname.as_deref() == Some(name_or_host) || cfg.host == name_or_host {
-                return Ok(cfg);
+            if cfg.nickname.as_deref() == Some(name_or_host) {
+                return Ok(cfg); // Nickname is unique
+            }
+            if cfg.host == name_or_host && protocol.map_or(true, |p| cfg.protocol == p) {
+                matches.push(cfg);
             }
         }
-        Err(no_such_server_error(name_or_host))
+        match matches.len() {
+            0 => Err(no_such_server_error(name_or_host)),
+            1 => Ok(matches[0]),
+            _ => Err(anyhow::anyhow!(
+                    "Ambiguous server: {} matches multiple protocols (e.g., {}://{}, {}://{}). Specify nickname or protocol.",
+                    name_or_host,
+                    matches[0].protocol,
+                    name_or_host,
+                    matches[1].protocol,
+                    name_or_host
+            )),
+        }
     }
 
-    fn find_server_mut(&mut self, name_or_host: &str) -> anyhow::Result<&mut ServerConfig> {
-        for cfg in &mut self.server_configs {
-            if cfg.nickname.as_deref() == Some(name_or_host) || cfg.host == name_or_host {
-                return Ok(cfg);
+    fn find_server_with_protocol_mut(&mut self, name_or_host: &str, protocol: Option<&str>) -> anyhow::Result<&mut ServerConfig> {
+        let mut indices = Vec::new();
+        let mut protocols = Vec::new();
+        for (i, cfg) in self.server_configs.iter().enumerate() {
+            if cfg.nickname.as_deref() == Some(name_or_host) {
+                return Ok(&mut self.server_configs[i]);
             }
+            if cfg.host == name_or_host && protocol.map_or(true, |p| cfg.protocol == p) {
+                indices.push(i);
+                protocols.push(&cfg.protocol);
+            }
+        }
+        match indices.len() {
+            0 => Err(no_such_server_error(name_or_host)),
+            1 => Ok(&mut self.server_configs[indices[0]]),
+            _ => Err(anyhow::anyhow!(
+                    "Ambiguous server: {} matches multiple protocols (e.g., {}://{}, {}://{}). Specify nickname or protocol.",
+                    name_or_host,
+                    protocols[0],
+                    name_or_host,
+                    protocols[1],
+                    name_or_host
+            )),
         }
-        Err(no_such_server_error(name_or_host))
+    }
+    fn find_server_mut(&mut self, name_or_host: &str) -> anyhow::Result<&mut ServerConfig> {
+        self.find_server_with_protocol_mut(name_or_host, None)
     }
 
     fn default_server(&self) -> anyhow::Result<&ServerConfig> {
@@ -231,13 +269,10 @@ impl RawConfig {
             }
         }
 
-        if let Ok(cfg) = self.find_server(&host) {
-            if let Some(nick) = &cfg.nickname {
-                if nick == &host {
-                    anyhow::bail!("Server host name is ambiguous with existing server nickname: {}", nick);
-                }
-            }
-            anyhow::bail!("Server already configured for host: {}", host);
+        if self.server_configs.iter().any(|cfg| {
+            cfg.host == host && cfg.protocol == protocol
+        }) {
+            anyhow::bail!("Server already configured for host: {}, proto: {}", host, protocol);
         }
 
         self.server_configs.push(ServerConfig {
@@ -271,47 +306,68 @@ impl RawConfig {
             .map(|cfg| cfg.protocol.as_ref())
     }
 
-    fn set_default_server(&mut self, server: &str) -> anyhow::Result<()> {
+    fn set_default_server(&mut self, server: &str, protocol: Option<&str>) -> anyhow::Result<()> {
         // Check that such a server exists before setting the default.
-        self.find_server(server)
-            .with_context(|| format!("Cannot set default server to unknown server {server}"))?;
+        let cfg = self
+            .find_server_with_protocol(server, protocol)
+            .with_context(|| {
+                if let Some(p) = protocol {
+                    format!("Cannot set default server to unknown server {} with protocol {}", server, p)
+                } else {
+                    format!("Cannot set default server to unknown server {}", server)
+                }
+            })?;
 
-        self.default_server = Some(server.to_string());
+        // Prefer nickname if available, else use host
+        self.default_server = Some(cfg.nickname.clone().unwrap_or_else(|| cfg.host.clone()));
 
         Ok(())
     }
 
     /// Implements `spacetime server remove`.
-    fn remove_server(&mut self, server: &str) -> anyhow::Result<()> {
-        // Have to find the server config manually instead of doing `find_server_mut`
-        // because we need to mutably borrow multiple components of `self`.
-        if let Some(idx) = self
-            .server_configs
-            .iter()
-            .position(|cfg| cfg.nick_or_host_or_url_is(server))
-        {
-            // Actually remove the config.
-            let cfg = self.server_configs.remove(idx);
-
-            // If we're removing the default server,
-            // unset the default server.
-            if let Some(default_server) = &self.default_server {
-                if cfg.nick_or_host_or_url_is(default_server) {
-                    self.default_server = None;
-                }
+    fn remove_server(&mut self, server: &str, protocol: Option<&str>) -> anyhow::Result<()> {
+        let mut indices = Vec::new();
+        let mut protocols = Vec::new();
+        for (i, cfg) in self.server_configs.iter().enumerate() {
+            if cfg.nickname.as_deref() == Some(server) {
+                indices = vec![i];
+                protocols = vec![&cfg.protocol];
+                break; // Nickname is unique
+            }
+            if cfg.host == server && protocol.map_or(true, |p| cfg.protocol == p) {
+                indices.push(i);
+                protocols.push(&cfg.protocol);
             }
+        }
 
-            return Ok(());
+        match indices.len() {
+            0 => Err(no_such_server_error(server)),
+            1 => {
+                let cfg = self.server_configs.remove(indices[0]);
+                if let Some(default_server) = &self.default_server {
+                    if cfg.nickname.as_deref() == Some(default_server) || cfg.host == *default_server {
+                        self.default_server = None;
+                    }
+                }
+                Ok(())
+            }
+            _ => Err(anyhow::anyhow!(
+                    "Ambiguous server: {} matches multiple protocols (e.g., {}://{}, {}://{}). Specify nickname or protocol.",
+                    server,
+                    protocols[0],
+                    server,
+                    protocols[1],
+                    server
+            )),
         }
-        Err(no_such_server_error(server))
     }
 
     /// Return the ECDSA public key in PEM format for the server named by `server`.
     ///
     /// Returns an `Err` if there is no such server configuration.
     /// Returns `None` if the server configuration exists, but does not have a fingerprint saved.
-    fn server_fingerprint(&self, server: &str) -> anyhow::Result<Option<&str>> {
-        self.find_server(server)
+    fn server_fingerprint(&self, server: &str, protocol: Option<&str>) -> anyhow::Result<Option<&str>> {
+        self.find_server_with_protocol(server, protocol)
             .with_context(|| {
                 format!(
                     "No saved fingerprint for server: {server}
@@ -319,7 +375,7 @@ Fetch the server's fingerprint with:
 \tspacetime server fingerprint -s {server}"
                 )
             })
-            .map(|cfg| cfg.ecdsa_public_key.as_deref())
+        .map(|cfg| cfg.ecdsa_public_key.as_deref())
     }
 
     /// Return the ECDSA public key in PEM format for the default server.
@@ -328,7 +384,7 @@ Fetch the server's fingerprint with:
     /// Returns `None` if the server configuration exists, but does not have a fingerprint saved.
     fn default_server_fingerprint(&self) -> anyhow::Result<Option<&str>> {
         if let Some(server) = &self.default_server {
-            self.server_fingerprint(server)
+            self.server_fingerprint(server, None)
         } else {
             Err(anyhow::anyhow!(NO_DEFAULT_SERVER_ERROR_MESSAGE))
         }
@@ -364,6 +420,7 @@ Fetch the server's fingerprint with:
     pub fn edit_server(
         &mut self,
         server: &str,
+        old_protocol: Option<&str>,
         new_nickname: Option<&str>,
         new_host: Option<&str>,
         new_protocol: Option<&str>,
@@ -371,7 +428,7 @@ Fetch the server's fingerprint with:
         // Check if the new nickname or host name would introduce ambiguities between
         // server configurations.
         if let Some(new_nick) = new_nickname {
-            if let Ok(other_server) = self.find_server(new_nick) {
+            if let Ok(other_server) = self.find_server_with_protocol(new_nick, None) {
                 anyhow::bail!(
                     "Nickname {} conflicts with saved configuration for server {}: {}://{}",
                     new_nick,
@@ -382,7 +439,7 @@ Fetch the server's fingerprint with:
             }
         }
         if let Some(new_host) = new_host {
-            if let Ok(other_server) = self.find_server(new_host) {
+            if let Ok(other_server) = self.find_server_with_protocol(new_host, new_protocol) {
                 anyhow::bail!(
                     "Host {} conflicts with saved configuration for server {}: {}://{}",
                     new_host,
@@ -393,7 +450,7 @@ Fetch the server's fingerprint with:
             }
         }
 
-        let cfg = self.find_server_mut(server)?;
+        let cfg = self.find_server_with_protocol_mut(server, old_protocol)?;
         let old_nickname = if let Some(new_nickname) = new_nickname {
             std::mem::replace(&mut cfg.nickname, Some(new_nickname.to_string()))
         } else {
@@ -509,8 +566,8 @@ impl Config {
     /// Callers should call `Config::save` afterwards
     /// to ensure modifications are persisted to disk.
     pub fn set_default_server(&mut self, nickname_or_host_or_url: &str) -> anyhow::Result<()> {
-        let (host, _) = host_or_url_to_host_and_protocol(nickname_or_host_or_url);
-        self.home.set_default_server(host)
+        let (host, proto) = host_or_url_to_host_and_protocol(nickname_or_host_or_url);
+        self.home.set_default_server(host, proto)
     }
 
     /// Delete a `ServerConfig` from the home configuration.
@@ -522,8 +579,8 @@ impl Config {
     /// Callers should call `Config::save` afterwards
     /// to ensure modifications are persisted to disk.
     pub fn remove_server(&mut self, nickname_or_host_or_url: &str) -> anyhow::Result<()> {
-        let (host, _) = host_or_url_to_host_and_protocol(nickname_or_host_or_url);
-        self.home.remove_server(host)
+        let (host, proto) = host_or_url_to_host_and_protocol(nickname_or_host_or_url);
+        self.home.remove_server(host, proto)
     }
 
     /// Get a URL for the specified `server`.
@@ -734,7 +791,7 @@ impl Config {
     }
 
     pub fn server_decoding_key(&self, server: Option<&str>) -> anyhow::Result<DecodingKey> {
-        self.server_fingerprint(server).and_then(|fing| {
+        self.server_fingerprint(server, None).and_then(|fing| {
             if let Some(fing) = fing {
                 DecodingKey::from_ec_pem(fing.as_bytes()).with_context(|| {
                     format!(
@@ -762,10 +819,11 @@ Update the server's fingerprint with:
         }
     }
 
-    pub fn server_fingerprint(&self, server: Option<&str>) -> anyhow::Result<Option<&str>> {
+    pub fn server_fingerprint(&self, server: Option<&str>, protocol: Option<&str>) -> anyhow::Result<Option<&str>> {
         if let Some(server) = server {
-            let (host, _) = host_or_url_to_host_and_protocol(server);
-            self.home.server_fingerprint(host)
+            let (host, _proto) = host_or_url_to_host_and_protocol(server);
+            //FIXME: if _proto exists and one was specified as arg too... or if None as arg, take _proto?
+            self.home.server_fingerprint(host, protocol)
         } else {
             self.home.default_server_fingerprint()
         }
@@ -787,8 +845,8 @@ Update the server's fingerprint with:
         new_host: Option<&str>,
         new_protocol: Option<&str>,
     ) -> anyhow::Result<(Option<String>, Option<String>, Option<String>)> {
-        let (host, _) = host_or_url_to_host_and_protocol(server);
-        self.home.edit_server(host, new_nickname, new_host, new_protocol)
+        let (host, oldproto) = host_or_url_to_host_and_protocol(server);
+        self.home.edit_server(host, oldproto, new_nickname, new_host, new_protocol)
     }
 
     pub fn delete_server_fingerprint(&mut self, server: Option<&str>) -> anyhow::Result<()> {
diff --git a/crates/cli/src/subcommands/call.rs b/crates/cli/src/subcommands/call.rs
index c32a3944..a8375f9e 100644
--- a/crates/cli/src/subcommands/call.rs
+++ b/crates/cli/src/subcommands/call.rs
@@ -30,6 +30,7 @@ pub fn cli() -> clap::Command {
                 .required(true)
                 .help("The name of the reducer to call"),
         )
+        .arg(common_args::cert())
         .arg(Arg::new("arguments").help("arguments formatted as JSON").num_args(1..))
         .arg(common_args::server().help("The nickname, host name or URL of the server hosting the database"))
         .arg(common_args::anonymous())
@@ -42,7 +43,8 @@ pub async fn exec(config: Config, args: &ArgMatches) -> Result<(), Error> {
     let reducer_name = args.get_one::<String>("reducer_name").unwrap();
     let arguments = args.get_many::<String>("arguments");
 
-    let conn = parse_req(config, args).await?;
+    let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+    let conn = parse_req(config, args, cert_path).await?;
     let api = ClientApi::new(conn);
 
     let database_identity = api.con.database_identity;
diff --git a/crates/cli/src/subcommands/delete.rs b/crates/cli/src/subcommands/delete.rs
index e0d5c756..7391bd14 100644
--- a/crates/cli/src/subcommands/delete.rs
+++ b/crates/cli/src/subcommands/delete.rs
@@ -1,6 +1,6 @@
 use crate::common_args;
 use crate::config::Config;
-use crate::util::{add_auth_header_opt, database_identity, get_auth_header};
+use crate::util::{add_auth_header_opt, database_identity, get_auth_header, build_client};
 use clap::{Arg, ArgMatches};
 
 pub fn cli() -> clap::Command {
@@ -13,17 +13,23 @@ pub fn cli() -> clap::Command {
         )
         .arg(common_args::server().help("The nickname, host name or URL of the server hosting the database"))
         .arg(common_args::yes())
+        .arg(common_args::cert())
         .after_help("Run `spacetime help delete` for more detailed information.\n")
 }
 
+
+
 pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::Error> {
     let server = args.get_one::<String>("server").map(|s| s.as_ref());
     let database = args.get_one::<String>("database").unwrap();
     let force = args.get_flag("force");
 
-    let identity = database_identity(&config, database, server).await?;
+    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+
+    let client = build_client(cert).await?;
+    let identity = database_identity(&config, database, server, &client).await?;
 
-    let builder = reqwest::Client::new().delete(format!("{}/v1/database/{}", config.get_host_url(server)?, identity));
+    let builder = client.delete(format!("{}/v1/database/{}", config.get_host_url(server)?, identity));
     let auth_header = get_auth_header(&mut config, false, server, !force).await?;
     let builder = add_auth_header_opt(builder, &auth_header);
     builder.send().await?.error_for_status()?;
diff --git a/crates/cli/src/subcommands/describe.rs b/crates/cli/src/subcommands/describe.rs
index 6f1759ff..fea482d0 100644
--- a/crates/cli/src/subcommands/describe.rs
+++ b/crates/cli/src/subcommands/describe.rs
@@ -40,6 +40,7 @@ pub fn cli() -> clap::Command {
                      give human-readable output.",
                 ),
         )
+        .arg(common_args::cert())
         .arg(common_args::anonymous())
         .arg(common_args::server().help("The nickname, host name or URL of the server hosting the database"))
         .arg(common_args::yes())
@@ -59,8 +60,9 @@ pub async fn exec(config: Config, args: &ArgMatches) -> Result<(), anyhow::Error
     let entity_type = args.get_one::<EntityType>("entity_type");
     let entity = entity_type.zip(entity_name);
     let json = args.get_flag("json");
+    let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
 
-    let conn = parse_req(config, args).await?;
+    let conn = parse_req(config, args, cert_path).await?;
     let api = ClientApi::new(conn);
 
     let module_def = api.module_def().await?;
diff --git a/crates/cli/src/subcommands/dns.rs b/crates/cli/src/subcommands/dns.rs
index 03f4e96b..b75d0d6d 100644
--- a/crates/cli/src/subcommands/dns.rs
+++ b/crates/cli/src/subcommands/dns.rs
@@ -20,6 +20,7 @@ pub fn cli() -> Command {
                 .required(true)
                 .help("The database identity to rename"),
         )
+        .arg(common_args::cert())
         .arg(common_args::server().help("The nickname, host name or URL of the server on which to set the name"))
         .arg(common_args::yes())
         .after_help("Run `spacetime rename --help` for more detailed information.\n")
@@ -33,10 +34,12 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     let token = get_login_token_or_log_in(&mut config, server, !force).await?;
     let identity = decode_identity(&token)?;
     let auth_header = get_auth_header(&mut config, false, server, !force).await?;
+    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
 
     let domain: DomainName = domain.parse()?;
 
-    let builder = reqwest::Client::new()
+    let client = crate::util::build_client(cert).await?;
+    let builder = client
         .post(format!(
             "{}/v1/database/{database_identity}/names",
             config.get_host_url(server)?
diff --git a/crates/cli/src/subcommands/energy.rs b/crates/cli/src/subcommands/energy.rs
index 0d4249e2..a01b03b8 100644
--- a/crates/cli/src/subcommands/energy.rs
+++ b/crates/cli/src/subcommands/energy.rs
@@ -30,6 +30,7 @@ fn get_energy_subcommands() -> Vec<clap::Command> {
             common_args::server()
                 .help("The nickname, host name or URL of the server from which to request balance information"),
         )
+        .arg(common_args::cert())
         .arg(common_args::yes())]
 }
 
@@ -58,8 +59,10 @@ async fn exec_status(mut config: Config, args: &ArgMatches) -> Result<(), anyhow
         let token = get_login_token_or_log_in(&mut config, server, !force).await?;
         util::decode_identity(&token)?
     };
+    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+    let client = crate::util::build_client(cert).await?;
 
-    let status = reqwest::Client::new()
+    let status = client
         .get(format!("{}/v1/energy/{}", config.get_host_url(server)?, identity))
         .send()
         .await?
diff --git a/crates/cli/src/subcommands/list.rs b/crates/cli/src/subcommands/list.rs
index 8080af3c..d048b782 100644
--- a/crates/cli/src/subcommands/list.rs
+++ b/crates/cli/src/subcommands/list.rs
@@ -19,6 +19,7 @@ pub fn cli() -> Command {
             "Lists the databases attached to an identity. {}",
             UNSTABLE_WARNING
         ))
+        .arg(common_args::cert())
         .arg(common_args::server().help("The nickname, host name or URL of the server from which to list databases"))
         .arg(common_args::yes())
 }
@@ -42,7 +43,8 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     let token = get_login_token_or_log_in(&mut config, server, !force).await?;
     let identity = util::decode_identity(&token)?;
 
-    let client = reqwest::Client::new();
+    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+    let client = util::build_client(cert).await?;
     let res = client
         .get(format!(
             "{}/v1/identity/{}/databases",
diff --git a/crates/cli/src/subcommands/login.rs b/crates/cli/src/subcommands/login.rs
index 8e2568b4..d009d122 100644
--- a/crates/cli/src/subcommands/login.rs
+++ b/crates/cli/src/subcommands/login.rs
@@ -1,4 +1,4 @@
-use crate::util::decode_identity;
+use crate::util::{decode_identity, build_client};
 use crate::Config;
 use clap::{Arg, ArgAction, ArgGroup, ArgMatches, Command};
 use reqwest::Url;
@@ -31,6 +31,7 @@ pub fn cli() -> Command {
                 .group("login-method")
                 .help("Bypass the login flow and use a login token directly"),
         )
+        .arg(crate::common_args::cert())
         .about("Manage your login to the SpacetimeDB CLI")
 }
 
@@ -53,7 +54,18 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     let spacetimedb_token: Option<&String> = args.get_one("spacetimedb-token");
     let host: &String = args.get_one("auth-host").unwrap();
     let host = Url::parse(host)?;
+    // XXX: specifying an url for the server below, instead of an existing nickname, will cause 'login' to
+    // succeed but you might wrongly assume like I did in https://github.com/clockworklabs/SpacetimeDB/issues/2512
+    // that any subsequent commands like `spacetime publish` will use that server that you specified
+    // but instead they won't, they'll use a default 127.0.0.1:3000(http) server instead
+    // because the url you used to login isn't saved in ~/.config/spacetime/cli.toml
+    // only the (login)spacetimedb_token is, and to select a default or add a new server
+    // to the list you've to use `spacetime server help`
+    // so let's warn, but allow this behavior.
     let server_issued_login: Option<&String> = args.get_one("server");
+    if let Some(server) = server_issued_login {
+        eprintln!("WARNING: the server that you specified here as '{}' isn't the one that will be used by commands like 'spacetime publish' but instead it's the one listed on 'spacetime server list' as the default (3 stars) that will be used, eg. 127.0.0.1:3000 if you haven't manually added any via 'spacetime server add'.\n",server);//extra new line
+    }//if
 
     if let Some(token) = spacetimedb_token {
         config.set_spacetimedb_token(token.clone());
@@ -61,11 +73,12 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
         return Ok(());
     }
 
+    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
     if let Some(server) = server_issued_login {
         let host = Url::parse(&config.get_host_url(Some(server))?)?;
-        spacetimedb_token_cached(&mut config, &host, true).await?;
+        spacetimedb_token_cached(&mut config, &host, true, cert).await?;
     } else {
-        spacetimedb_token_cached(&mut config, &host, false).await?;
+        spacetimedb_token_cached(&mut config, &host, false, cert).await?;
     }
 
     Ok(())
@@ -98,7 +111,7 @@ async fn exec_show(config: Config, args: &ArgMatches) -> Result<(), anyhow::Erro
     Ok(())
 }
 
-async fn spacetimedb_token_cached(config: &mut Config, host: &Url, direct_login: bool) -> anyhow::Result<String> {
+async fn spacetimedb_token_cached(config: &mut Config, host: &Url, direct_login: bool, cert: Option<&std::path::Path>) -> anyhow::Result<String> {
     // Currently, this token does not expire. However, it will at some point in the future. When that happens,
     // this code will need to happen before any request to a spacetimedb server, rather than at the end of the login flow here.
     if let Some(token) = config.spacetimedb_token() {
@@ -106,17 +119,19 @@ async fn spacetimedb_token_cached(config: &mut Config, host: &Url, direct_login:
         println!("If you want to log out, use spacetime logout.");
         Ok(token.clone())
     } else {
-        spacetimedb_login_force(config, host, direct_login).await
+        spacetimedb_login_force(config, host, direct_login, cert).await
     }
 }
 
-pub async fn spacetimedb_login_force(config: &mut Config, host: &Url, direct_login: bool) -> anyhow::Result<String> {
+pub async fn spacetimedb_login_force(config: &mut Config, host: &Url, direct_login: bool, cert: Option<&std::path::Path>) -> anyhow::Result<String> {
     let token = if direct_login {
-        let token = spacetimedb_direct_login(host).await?;
+        println!("We will log in directly to your target server.");
+        let token = spacetimedb_direct_login(host, cert).await?;
         println!("We have logged in directly to your target server.");
         println!("WARNING: This login will NOT work for any other servers.");
         token
     } else {
+        println!("We will log in NON-directly to your target server.");
         let session_token = web_login_cached(config, host).await?;
         spacetimedb_login(host, &session_token).await?
     };
@@ -271,8 +286,9 @@ struct LocalLoginResponse {
     pub token: String,
 }
 
-async fn spacetimedb_direct_login(host: &Url) -> Result<String, anyhow::Error> {
-    let client = reqwest::Client::new();
+async fn spacetimedb_direct_login(host: &Url, cert: Option<&std::path::Path>) -> Result<String, anyhow::Error> {
+    let client = build_client(cert.as_deref()).await?;
+
     let response: LocalLoginResponse = client
         .post(host.join("/v1/identity")?)
         .send()
diff --git a/crates/cli/src/subcommands/logs.rs b/crates/cli/src/subcommands/logs.rs
index c92a6f01..4f6cb8a6 100644
--- a/crates/cli/src/subcommands/logs.rs
+++ b/crates/cli/src/subcommands/logs.rs
@@ -3,7 +3,7 @@ use std::io::{self, Write};
 
 use crate::common_args;
 use crate::config::Config;
-use crate::util::{add_auth_header_opt, database_identity, get_auth_header};
+use crate::util::{add_auth_header_opt, database_identity, get_auth_header, build_client};
 use clap::{Arg, ArgAction, ArgMatches};
 use futures::{AsyncBufReadExt, TryStreamExt};
 use is_terminal::IsTerminal;
@@ -48,6 +48,7 @@ pub fn cli() -> clap::Command {
                 .help("Output format for the logs")
         )
         .arg(common_args::yes())
+        .arg(common_args::cert())
         .after_help("Run `spacetime help logs` for more detailed information.\n")
 }
 
@@ -120,7 +121,10 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
 
     let auth_header = get_auth_header(&mut config, false, server, !force).await?;
 
-    let database_identity = database_identity(&config, database, server).await?;
+    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+
+    let client = build_client(cert).await?;
+    let database_identity = database_identity(&config, database, server, &client).await?;
 
     if follow && num_lines.is_none() {
         // We typically don't want logs from the very beginning if we're also following.
@@ -130,7 +134,7 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
 
     let host_url = config.get_host_url(server)?;
 
-    let builder = reqwest::Client::new().get(format!("{}/v1/database/{}/logs", host_url, database_identity));
+    let builder = client.get(format!("{}/v1/database/{}/logs", host_url, database_identity));
     let builder = add_auth_header_opt(builder, &auth_header);
     let mut res = builder.query(&query_parms).send().await?;
     let status = res.status();
diff --git a/crates/cli/src/subcommands/publish.rs b/crates/cli/src/subcommands/publish.rs
index 65cdf343..7c6283ef 100644
--- a/crates/cli/src/subcommands/publish.rs
+++ b/crates/cli/src/subcommands/publish.rs
@@ -9,7 +9,7 @@ use std::path::PathBuf;
 
 use crate::config::Config;
 use crate::util::{add_auth_header_opt, get_auth_header, ResponseExt};
-use crate::util::{decode_identity, unauth_error_context, y_or_n};
+use crate::util::{decode_identity, unauth_error_context, y_or_n, build_client};
 use crate::{build, common_args};
 
 pub fn cli() -> clap::Command {
@@ -63,6 +63,7 @@ i.e. only lowercase ASCII letters and numbers, separated by dashes."),
         .arg(common_args::server()
                 .help("The nickname, domain name or URL of the server to host the database."),
         )
+        .arg(common_args::cert())
         .arg(
             common_args::yes()
         )
@@ -79,6 +80,8 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     let wasm_file = args.get_one::<PathBuf>("wasm_file");
     let database_host = config.get_host_url(server)?;
     let build_options = args.get_one::<String>("build_options").unwrap();
+    let cert_path: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+
 
     // If the user didn't specify an identity and we didn't specify an anonymous identity, then
     // we want to use the default identity
@@ -86,7 +89,7 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     //  easily create a new identity with an email
     let auth_header = get_auth_header(&mut config, anon_identity, server, !force).await?;
 
-    let client = reqwest::Client::new();
+    let client = build_client(cert_path).await?;
 
     // If a domain or identity was provided, we should locally make sure it looks correct and
     let mut builder = if let Some(name_or_identity) = name_or_identity {
@@ -119,7 +122,16 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
         let url = Url::parse(&database_host)?;
         url.host_str().unwrap_or("<default>").to_string()
     };
-    if server_address != "localhost" && server_address != "127.0.0.1" {
+
+    use std::net::IpAddr;
+    fn is_local_address(address: &str) -> bool {
+        if let Ok(IpAddr::V4(ipv4)) = address.parse::<IpAddr>() {
+            ipv4.is_loopback() // true if this is `127.0.0.0/8`
+        } else {
+            address.eq_ignore_ascii_case("localhost")
+        }
+    }
+    if !is_local_address(&server_address) {
         println!("You are about to publish to a non-local server: {}", server_address);
         if !y_or_n(force, "Are you sure you want to proceed?")? {
             println!("Aborting");
diff --git a/crates/cli/src/subcommands/server.rs b/crates/cli/src/subcommands/server.rs
index 611919a6..d9d81045 100644
--- a/crates/cli/src/subcommands/server.rs
+++ b/crates/cli/src/subcommands/server.rs
@@ -1,6 +1,6 @@
 use crate::{
     common_args,
-    util::{host_or_url_to_host_and_protocol, spacetime_server_fingerprint, y_or_n, UNSTABLE_WARNING, VALID_PROTOCOLS},
+    util::{host_or_url_to_host_and_protocol, spacetime_server_fingerprint, y_or_n, UNSTABLE_WARNING, VALID_PROTOCOLS, build_client},
     Config,
 };
 use anyhow::Context;
@@ -10,6 +10,7 @@ use tabled::{
     settings::{object::Columns, Alignment, Modify, Style},
     Table, Tabled,
 };
+use std::path::Path;
 
 pub fn cli() -> Command {
     Command::new("server")
@@ -53,7 +54,8 @@ fn get_subcommands() -> Vec<Command> {
                     .help("Skip fingerprinting the server")
                     .long("no-fingerprint")
                     .action(ArgAction::SetTrue),
-            ),
+            )
+            .arg(common_args::cert()),
         Command::new("remove")
             .about("Remove a saved server configuration")
             .arg(
@@ -69,6 +71,7 @@ fn get_subcommands() -> Vec<Command> {
                     .required(true)
                     .help("The nickname, host name or URL of the server"),
             )
+            .arg(common_args::cert())
             .arg(common_args::yes()),
         Command::new("ping")
             .about("Checks to see if a SpacetimeDB host is online")
@@ -76,7 +79,8 @@ fn get_subcommands() -> Vec<Command> {
                 Arg::new("server")
                     .required(true)
                     .help("The nickname, host name or URL of the server to ping"),
-            ),
+            )
+            .arg(common_args::cert()),
         Command::new("edit")
             .about("Update a saved server's nickname, host name or protocol")
             .arg(
@@ -100,6 +104,7 @@ fn get_subcommands() -> Vec<Command> {
                     .long("no-fingerprint")
                     .action(ArgAction::SetTrue),
             )
+            .arg(common_args::cert())
             .arg(common_args::yes()),
         Command::new("clear")
             .about("Deletes all data from all local databases")
@@ -195,6 +200,11 @@ pub async fn exec_add(mut config: Config, args: &ArgMatches) -> Result<(), anyho
     let nickname = args.get_one::<String>("name");
     let default = *args.get_one::<bool>("default").unwrap();
     let no_fingerprint = *args.get_one::<bool>("no-fingerprint").unwrap();
+    let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+
+    if no_fingerprint && cert_path.is_some() {
+        eprintln!("WARNING: --cert ignored while using --no-fingerprint");
+    }
 
     let (host, protocol) = host_or_url_to_host_and_protocol(url);
     let protocol = protocol.ok_or_else(|| anyhow::anyhow!("Invalid url: {}", url))?;
@@ -204,12 +214,13 @@ pub async fn exec_add(mut config: Config, args: &ArgMatches) -> Result<(), anyho
     let fingerprint = if no_fingerprint {
         None
     } else {
-        let fingerprint = spacetime_server_fingerprint(url).await.with_context(|| {
+        let fingerprint = spacetime_server_fingerprint(url, cert_path).await.with_context(|| {
             format!(
                 "Unable to retrieve fingerprint for server: {url}
 Is the server running?
 Add a server without retrieving its fingerprint with:
-\tspacetime server add --url {url} --no-fingerprint",
+\tspacetime server add --url {url} --no-fingerprint
+or provide a trusted --cert."
             )
         })?;
         println!("For server {}, got fingerprint:\n{}", url, fingerprint);
@@ -224,7 +235,6 @@ Add a server without retrieving its fingerprint with:
 
     println!("Host: {}", host);
     println!("Protocol: {}", protocol);
-
     config.save();
 
     Ok(())
@@ -240,25 +250,51 @@ pub async fn exec_remove(mut config: Config, args: &ArgMatches) -> Result<(), an
     Ok(())
 }
 
-async fn update_server_fingerprint(config: &mut Config, server: Option<&str>) -> Result<bool, anyhow::Error> {
-    let url = config.get_host_url(server)?;
-    let nick_or_host = config.server_nick_or_host(server)?;
-    let new_fing = spacetime_server_fingerprint(&url)
+async fn update_server_fingerprint(
+    config: &mut Config,
+    server: Option<&str>,
+    cert_path: Option<&Path>,
+    protocol: Option<&str>,
+) -> Result<bool, anyhow::Error> {
+    let (host, proto, nick_or_host) = match server {
+        Some(s) => {
+            let (h, p) = host_or_url_to_host_and_protocol(s);
+            if p.is_none() && !s.contains(':') && !s.contains('/') {
+                // Nickname case: fetch URL from config
+                let url = config.get_host_url(Some(s))?;
+                let (h_url, p_url) = host_or_url_to_host_and_protocol(&url);
+                let p_url = p_url.ok_or_else(|| anyhow::anyhow!("Server {} has no protocol", s))?;
+                (h_url.to_string(), p_url.to_string(), s.to_string())
+            } else {
+                // Host or URL case
+                let p = p.or(protocol).ok_or_else(|| {
+                    anyhow::anyhow!("Protocol not specified and server {} is ambiguous", h)
+                })?;
+                (h.to_string(), p.to_string(), s.to_string())
+            }
+        }
+        None => {
+            let url = config.get_host_url(None)?;
+            let (h, p) = host_or_url_to_host_and_protocol(&url);
+            let p = p.ok_or_else(|| anyhow::anyhow!("Default server has no protocol"))?;
+            let nick = config.server_nick_or_host(None)?.to_string();
+            (h.to_string(), p.to_string(), nick)
+        }
+    };
+    let url = format!("{}://{}", proto, host);
+    let new_fing = spacetime_server_fingerprint(&url, cert_path)
         .await
         .context("Error fetching server fingerprint")?;
-    if let Some(saved_fing) = config.server_fingerprint(server)? {
+    if let Some(saved_fing) = config.server_fingerprint(Some(&host), Some(&proto))? {
         if saved_fing == new_fing {
             println!("Fingerprint is unchanged for server {}:\n{}", nick_or_host, saved_fing);
-
             Ok(false)
         } else {
             println!(
                 "Fingerprint has changed for server {}.\nWas:\n{}\nNew:\n{}",
                 nick_or_host, saved_fing, new_fing
             );
-
-            config.set_server_fingerprint(server, new_fing)?;
-
+            config.set_server_fingerprint(Some(&host), new_fing)?;
             Ok(true)
         }
     } else {
@@ -266,9 +302,7 @@ async fn update_server_fingerprint(config: &mut Config, server: Option<&str>) ->
             "No saved fingerprint for server {}. New fingerprint:\n{}",
             nick_or_host, new_fing
         );
-
-        config.set_server_fingerprint(server, new_fing)?;
-
+        config.set_server_fingerprint(Some(&host), new_fing)?;
         Ok(true)
     }
 }
@@ -276,8 +310,10 @@ async fn update_server_fingerprint(config: &mut Config, server: Option<&str>) ->
 pub async fn exec_fingerprint(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::Error> {
     let server = args.get_one::<String>("server").unwrap().as_str();
     let force = args.get_flag("force");
+    let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
 
-    if update_server_fingerprint(&mut config, Some(server)).await? {
+    let (host, protocol) = host_or_url_to_host_and_protocol(server);
+    if update_server_fingerprint(&mut config, Some(host), cert_path, protocol).await? {
         if !y_or_n(force, "Continue?")? {
             anyhow::bail!("Aborted");
         }
@@ -291,8 +327,10 @@ pub async fn exec_fingerprint(mut config: Config, args: &ArgMatches) -> Result<(
 pub async fn exec_ping(config: Config, args: &ArgMatches) -> Result<(), anyhow::Error> {
     let server = args.get_one::<String>("server").unwrap().as_str();
     let url = config.get_host_url(Some(server))?;
+    let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
 
-    let builder = reqwest::Client::new().get(format!("{}/v1/ping", url).as_str());
+    let client = build_client(cert_path).await?;
+    let builder = client.get(format!("{}/v1/ping", url).as_str());
     let response = builder.send().await?;
 
     match response.status() {
@@ -342,6 +380,7 @@ pub async fn exec_edit(mut config: Config, args: &ArgMatches) -> Result<(), anyh
         println!("Changing host from {} to {}", old_host, new_host);
     }
     if let (Some(new_proto), Some(old_proto)) = (new_proto, old_proto) {
+        //FIXME: Changing protocol from https to https
         println!("Changing protocol from {} to {}", old_proto, new_proto);
     }
 
@@ -351,7 +390,8 @@ pub async fn exec_edit(mut config: Config, args: &ArgMatches) -> Result<(), anyh
         if no_fingerprint {
             config.delete_server_fingerprint(Some(&new_url))?;
         } else {
-            update_server_fingerprint(&mut config, Some(&new_url)).await?;
+            let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+            update_server_fingerprint(&mut config, Some(&new_url), cert_path, new_proto).await?;
         }
     }
 
diff --git a/crates/cli/src/subcommands/sql.rs b/crates/cli/src/subcommands/sql.rs
index 8e6cac17..f0fe745d 100644
--- a/crates/cli/src/subcommands/sql.rs
+++ b/crates/cli/src/subcommands/sql.rs
@@ -1,16 +1,18 @@
 use std::fmt;
 use std::fmt::Write;
 use std::time::{Duration, Instant};
+use std::path::Path;
 
 use crate::api::{from_json_seed, ClientApi, Connection, SqlStmtResult, StmtStats};
 use crate::common_args;
 use crate::config::Config;
-use crate::util::{database_identity, get_auth_header, ResponseExt, UNSTABLE_WARNING};
+use crate::util::{database_identity, get_auth_header, ResponseExt, UNSTABLE_WARNING, build_client};
 use anyhow::Context;
 use clap::{Arg, ArgAction, ArgMatches};
 use reqwest::RequestBuilder;
 use spacetimedb_lib::de::serde::SeedWrapper;
 use spacetimedb_lib::sats::{satn, ProductType, ProductValue, Typespace};
+use std::path::PathBuf;
 
 pub fn cli() -> clap::Command {
     clap::Command::new("sql")
@@ -37,19 +39,23 @@ pub fn cli() -> clap::Command {
         .arg(common_args::anonymous())
         .arg(common_args::server().help("The nickname, host name or URL of the server hosting the database"))
         .arg(common_args::yes())
+        .arg(common_args::cert())
 }
 
-pub(crate) async fn parse_req(mut config: Config, args: &ArgMatches) -> Result<Connection, anyhow::Error> {
+pub(crate) async fn parse_req(mut config: Config, args: &ArgMatches, cert_path: Option<&Path>) -> Result<Connection, anyhow::Error> {
     let server = args.get_one::<String>("server").map(|s| s.as_ref());
     let force = args.get_flag("force");
     let database_name_or_identity = args.get_one::<String>("database").unwrap();
     let anon_identity = args.get_flag("anon_identity");
 
+    let client = build_client(cert_path).await?;
+
     Ok(Connection {
         host: config.get_host_url(server)?,
         auth_header: get_auth_header(&mut config, anon_identity, server, !force).await?,
-        database_identity: database_identity(&config, database_name_or_identity, server).await?,
+        database_identity: database_identity(&config, database_name_or_identity, server, &client).await?,
         database: database_name_or_identity.to_string(),
+        cert_path: cert_path.map(PathBuf::from),
     })
 }
 
@@ -171,15 +177,16 @@ fn stmt_result_to_table(stmt_result: &SqlStmtResult) -> anyhow::Result<(StmtStat
 
 pub async fn exec(config: Config, args: &ArgMatches) -> Result<(), anyhow::Error> {
     eprintln!("{}\n", UNSTABLE_WARNING);
+    let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
     let interactive = args.get_one::<bool>("interactive").unwrap_or(&false);
     if *interactive {
-        let con = parse_req(config, args).await?;
+        let con = parse_req(config, args, cert_path).await?;
 
         crate::repl::exec(con).await?;
     } else {
         let query = args.get_one::<String>("query").unwrap();
 
-        let con = parse_req(config, args).await?;
+        let con = parse_req(config, args, cert_path).await?;
         let api = ClientApi::new(con);
 
         run_sql(api.sql(), query, false).await?;
diff --git a/crates/cli/src/subcommands/subscribe.rs b/crates/cli/src/subcommands/subscribe.rs
index 6eb2039c..f14082b5 100644
--- a/crates/cli/src/subcommands/subscribe.rs
+++ b/crates/cli/src/subcommands/subscribe.rs
@@ -17,7 +17,7 @@ use tokio_tungstenite::tungstenite::Message as WsMessage;
 use crate::api::ClientApi;
 use crate::common_args;
 use crate::sql::parse_req;
-use crate::util::UNSTABLE_WARNING;
+use crate::util::{self, UNSTABLE_WARNING};
 use crate::Config;
 
 pub fn cli() -> clap::Command {
@@ -66,6 +66,7 @@ pub fn cli() -> clap::Command {
                 .action(ArgAction::SetTrue)
                 .help("Print the initial update for the queries."),
         )
+        .arg(common_args::cert())
         .arg(common_args::anonymous())
         .arg(common_args::yes())
         .arg(common_args::server().help("The nickname, host name or URL of the server hosting the database"))
@@ -132,7 +133,8 @@ pub async fn exec(config: Config, args: &ArgMatches) -> Result<(), anyhow::Error
     let timeout = args.get_one::<u32>("timeout").copied();
     let print_initial_update = args.get_flag("print_initial_update");
 
-    let conn = parse_req(config, args).await?;
+    let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+    let conn = parse_req(config, args, cert_path).await?;
     let api = ClientApi::new(conn);
     let module_def = api.module_def().await?;
 
@@ -158,7 +160,19 @@ pub async fn exec(config: Config, args: &ArgMatches) -> Result<(), anyhow::Error
     if let Some(auth_header) = api.con.auth_header.to_header() {
         req.headers_mut().insert(header::AUTHORIZATION, auth_header);
     }
-    let (mut ws, _) = tokio_tungstenite::connect_async(req).await?;
+
+    // Configure TLS with cert_path
+    let connector = {
+        // Changed: Use native-tls like websocket.rs
+        let mut builder = native_tls::TlsConnector::builder();
+        if let Some(cert) = util::load_root_cert(api.con.cert_path.as_deref()).await? {
+            builder.add_root_certificate(cert);
+        }
+        let tls_connector = builder.build().context("Failed to build TLS connector")?;
+        Some(tokio_tungstenite::Connector::NativeTls(tls_connector))
+    };
+
+    let (mut ws, _) = tokio_tungstenite::connect_async_tls_with_config(req, None, false, connector).await?;
 
     let task = async {
         subscribe(&mut ws, queries.cloned().map(Into::into).collect()).await?;
diff --git a/crates/cli/src/util.rs b/crates/cli/src/util.rs
index 20e0591c..6181206d 100644
--- a/crates/cli/src/util.rs
+++ b/crates/cli/src/util.rs
@@ -9,6 +9,7 @@ use std::path::Path;
 
 use crate::config::Config;
 use crate::login::{spacetimedb_login_force, DEFAULT_AUTH_HOST};
+pub use spacetimedb_lib::load_root_cert;
 
 pub const UNSTABLE_WARNING: &str = "WARNING: This command is UNSTABLE and subject to breaking changes.";
 
@@ -17,11 +18,12 @@ pub async fn database_identity(
     config: &Config,
     name_or_identity: &str,
     server: Option<&str>,
+    client: &reqwest::Client,
 ) -> Result<Identity, anyhow::Error> {
     if let Ok(identity) = Identity::from_hex(name_or_identity) {
         return Ok(identity);
     }
-    spacetime_dns(config, name_or_identity, server)
+    spacetime_dns(config, name_or_identity, server, client)
         .await?
         .with_context(|| format!("the dns resolution of `{name_or_identity}` failed."))
 }
@@ -106,13 +108,37 @@ impl ResponseExt for reqwest::Response {
     }
 }
 
+
+pub async fn configure_tls(cert_path: Option<&Path>) -> anyhow::Result<reqwest::ClientBuilder> {
+    let mut client_builder = reqwest::Client::builder();
+    if let Some(cert) = load_root_cert(cert_path).await? {
+        let path:String=cert_path.map_or("<unexpected empty path>".to_string(), |p| p.display().to_string());
+        let reqwest_cert = reqwest::Certificate::from_der(&cert.to_der()
+            .context(format!("Failed to convert certificate to DER for: {}", path))?)
+            .context(format!("Invalid certificate: {}", path))?;
+        client_builder = client_builder.add_root_certificate(reqwest_cert);
+    }
+    Ok(client_builder)
+}
+
+pub fn build_client_with_context(builder: reqwest::ClientBuilder, cert_path: Option<&Path>) -> anyhow::Result<reqwest::Client> {
+    builder
+        .build()
+        .context(format!("Failed to build client with cert {:?}", cert_path))
+}
+
+pub async fn build_client(cert_path: Option<&Path>) -> anyhow::Result<reqwest::Client> {
+    let builder = configure_tls(cert_path).await?;
+    build_client_with_context(builder, cert_path)
+}
+
 /// Converts a name to a database identity.
 pub async fn spacetime_dns(
     config: &Config,
     domain: &str,
     server: Option<&str>,
+    client: &reqwest::Client,
 ) -> Result<Option<Identity>, anyhow::Error> {
-    let client = reqwest::Client::new();
     let url = format!("{}/v1/database/{}/identity", config.get_host_url(server)?, domain);
     let Some(res) = client.get(url).send().await?.found() else {
         return Ok(None);
@@ -123,8 +149,15 @@ pub async fn spacetime_dns(
         .context("identity endpoint did not return an identity")
 }
 
-pub async fn spacetime_server_fingerprint(url: &str) -> anyhow::Result<String> {
-    let builder = reqwest::Client::new().get(format!("{}/v1/identity/public-key", url).as_str());
+pub async fn spacetime_server_fingerprint(url: &str, cert_path: Option<&Path>) -> anyhow::Result<String> {
+    if let Some(_path) = cert_path {
+        if !url.starts_with("https") {
+            eprintln!("WARNING: Non-https url '{url}' but --cert was specified.");
+        }
+    }
+    let builder = configure_tls(cert_path).await?;
+    let client = builder.build().map_err(|e| anyhow::anyhow!("Failed to build client: {}", e))?;
+    let builder = client.get(format!("{}/v1/identity/public-key", url).as_str());
     let res = builder.send().await?.error_for_status()?;
     let fingerprint = res.text().await?;
     Ok(fingerprint)
@@ -314,9 +347,9 @@ pub async fn get_login_token_or_log_in(
 
     if full_login {
         let host = Url::parse(DEFAULT_AUTH_HOST)?;
-        spacetimedb_login_force(config, &host, false).await
+        spacetimedb_login_force(config, &host, false, None/*TODO*/).await
     } else {
         let host = Url::parse(&config.get_host_url(target_server)?)?;
-        spacetimedb_login_force(config, &host, true).await
+        spacetimedb_login_force(config, &host, true, None/*TODO*/).await
     }
 }
diff --git a/crates/lib/Cargo.toml b/crates/lib/Cargo.toml
index 417af799..01c26eb2 100644
--- a/crates/lib/Cargo.toml
+++ b/crates/lib/Cargo.toml
@@ -42,6 +42,9 @@ serde = { workspace = true, optional = true }
 thiserror.workspace = true
 blake3.workspace = true
 enum-map = { workspace = true, optional = true }
+tokio.workspace = true
+native-tls = "0.2"
+clap.workspace = true
 
 # For the 'proptest' feature.
 proptest = { workspace = true, optional = true }
diff --git a/crates/lib/src/lib.rs b/crates/lib/src/lib.rs
index f1963db6..583ddbee 100644
--- a/crates/lib/src/lib.rs
+++ b/crates/lib/src/lib.rs
@@ -384,3 +384,52 @@ pub fn resolved_type_via_v9<T: SpacetimeType>() -> AlgebraicType {
         .resolve_refs()
         .expect("recursive types not supported")
 }
+
+pub async fn load_root_cert(cert_path: Option<&std::path::Path>) -> anyhow::Result<Option<native_tls::Certificate>> {
+    if let Some(path) = cert_path {
+        // Open file asynchronously
+        use tokio::fs::File;
+        use tokio::io::{AsyncReadExt, BufReader};
+        let file = File::open(path)
+            .await
+            .context(format!("Failed to open certificate file: {}", path.display()))?;
+
+        // Limit read to 1MiB (1,048,576 bytes)
+        // otherwise you'd pass /dev/zero and oom
+        const MAX_CERT_SIZE: u64 = 1_048_576;
+        let mut reader = BufReader::new(file).take(MAX_CERT_SIZE);
+        let mut cert_pem = String::new();
+
+        // Read up to 1MiB into cert_pem
+        reader
+            .read_to_string(&mut cert_pem)
+            .await
+            .context(format!("Failed to read certificate file: {}", path.display()))?;
+
+        // Check if we hit the limit (more data remains)
+        if reader.limit() == 0 && reader.get_ref().get_ref().metadata().await.is_ok() {
+            anyhow::bail!("Certificate file too large (>1MiB): {}", path.display());
+        }
+
+        // Parse PEM
+        let cert = native_tls::Certificate::from_pem(cert_pem.as_bytes())
+            .context(format!("Failed to parse PEM certificate: {}", path.display()))?;
+
+        eprintln!("Added trusted certificate from {} for a new TLS connection.", path.display());
+        Ok(Some(cert))
+    } else {
+        eprintln!("No trusted certificate specified via --cert for this new connection, thus if you used local CA or self-signed server certificate, you may get an error like '(unable to get local issuer certificate)' next.");
+        Ok(None)
+    }
+}
+
+pub fn cert() -> clap::Arg {
+    clap::Arg::new("cert")
+        .long("cert")
+        .value_name("FILE")
+        .action(clap::ArgAction::Set)
+        .value_parser(clap::value_parser!(std::path::PathBuf))
+        .required(false)
+        .help("Path to the server’s self-signed certificate or CA certificate (PEM format) to trust during this command (ie. as if it were part of your system's cert root store)")
+}
+
diff --git a/crates/sdk/Cargo.toml b/crates/sdk/Cargo.toml
index 9daa2a98..2d95cbbe 100644
--- a/crates/sdk/Cargo.toml
+++ b/crates/sdk/Cargo.toml
@@ -29,6 +29,10 @@ prometheus.workspace = true
 rand.workspace = true
 tokio.workspace = true
 tokio-tungstenite.workspace = true
+rustls = "0.23"
+rustls-pemfile = "2.2.0"
+native-tls = "0.2"  # Explicitly add for Connector::NativeTls
+anyhow="1.0"
 
 [dev-dependencies]
 # for quickstart-chat and cursive-chat examples
diff --git a/crates/sdk/examples/quickstart-chat/main.rs b/crates/sdk/examples/quickstart-chat/main.rs
index e04ff9cb..25cc5d5b 100644
--- a/crates/sdk/examples/quickstart-chat/main.rs
+++ b/crates/sdk/examples/quickstart-chat/main.rs
@@ -5,11 +5,20 @@ use module_bindings::*;
 
 use spacetimedb_sdk::{credentials, DbContext, Error, Event, Identity, Status, Table, TableWithPrimaryKey};
 
+use std::path::PathBuf;
+
+
 // ## Define the main function
 
 fn main() {
-    // Connect to the database
-    let ctx = connect_to_db();
+    // ### Parse command-line arguments for --cert into a PathBuf
+    let args: Vec<String> = std::env::args().collect();
+    let cert_path: Option<PathBuf> = args.iter()
+        .position(|arg| arg == "--cert")
+        .map(|i| args.get(i + 1).expect("Missing certificate path after --cert"))
+        .map(|s| PathBuf::from(s));
+    // Connect to the database with optional cert
+    let ctx = connect_to_db(cert_path);
 
     // Register callbacks to run in response to database events.
     register_callbacks(&ctx);
@@ -26,14 +35,19 @@ fn main() {
 
 // ## Connect to the database
 
-/// The URI of the SpacetimeDB instance hosting our chat module.
-const HOST: &str = "http://localhost:3000";
+/// The host and port, without scheme, of the SpacetimeDB instance hosting our chat module.
+const HOST_PORT: &str = "localhost:3000";
 
 /// The module name we chose when we published our module.
 const DB_NAME: &str = "quickstart-chat";
 
 /// Load credentials from a file and connect to the database.
-fn connect_to_db() -> DbConnection {
+fn connect_to_db(cert_path: Option<PathBuf>) -> DbConnection {
+    // ### Construct URI with scheme based on cert presence
+    let scheme = if cert_path.is_some() { "https" } else { "http" };
+    let uri = format!("{}://{}", scheme, HOST_PORT);
+
+//    let mut builder=
     DbConnection::builder()
         // Register our `on_connect` callback, which will save our auth token.
         .on_connect(on_connected)
@@ -48,7 +62,17 @@ fn connect_to_db() -> DbConnection {
         // Set the database name we chose when we called `spacetime publish`.
         .with_module_name(DB_NAME)
         // Set the URI of the SpacetimeDB host that's running our database.
-        .with_uri(HOST)
+        .with_uri(&uri)
+//;    // ### Add trusted cert if provided
+//    if let Some(cert_path) = cert_path {
+//    //XXX: we don't wanna do this(that's why it's accepting Option instead):
+//        builder = builder.with_trusted_cert(cert_path);
+//    }
+//     // Finalize configuration and connect!
+//     builder.build()
+//         .expect("Failed to connect")
+        // ### Add trusted cert if provided
+        .with_trusted_cert(cert_path)
         // Finalize configuration and connect!
         .build()
         .expect("Failed to connect")
diff --git a/crates/sdk/src/db_connection.rs b/crates/sdk/src/db_connection.rs
index e1e4133e..fbc2dd57 100644
--- a/crates/sdk/src/db_connection.rs
+++ b/crates/sdk/src/db_connection.rs
@@ -748,6 +748,8 @@ pub struct DbConnectionBuilder<M: SpacetimeModule> {
     on_disconnect: Option<OnDisconnectCallback<M>>,
 
     params: WsParams,
+
+    trusted_cert: Option<std::path::PathBuf>,
 }
 
 /// This process's global connection ID, which will be attacked to all connections it makes.
@@ -794,6 +796,7 @@ impl<M: SpacetimeModule> DbConnectionBuilder<M> {
             on_connect_error: None,
             on_disconnect: None,
             params: <_>::default(),
+            trusted_cert: None,
         }
     }
 
@@ -841,6 +844,7 @@ but you must call one of them, or else the connection will never progress.
                 self.token.as_deref(),
                 get_connection_id(),
                 self.params,
+                self.trusted_cert.as_ref(),
             ))
         })
         .map_err(|source| crate::Error::FailedToConnect {
@@ -892,6 +896,11 @@ but you must call one of them, or else the connection will never progress.
         self
     }
 
+    pub fn with_trusted_cert(mut self, cert: Option<impl Into<std::path::PathBuf>>) -> Self {
+        self.trusted_cert = cert.map(|c| c.into());
+        self
+    }
+
     /// Set the name or identity of the remote module.
     pub fn with_module_name(mut self, name_or_identity: impl Into<String>) -> Self {
         self.module_name = Some(name_or_identity.into());
diff --git a/crates/sdk/src/websocket.rs b/crates/sdk/src/websocket.rs
index 436520d5..90148b84 100644
--- a/crates/sdk/src/websocket.rs
+++ b/crates/sdk/src/websocket.rs
@@ -21,10 +21,10 @@ use tokio::task::JoinHandle;
 use tokio::time::Instant;
 use tokio::{net::TcpStream, runtime};
 use tokio_tungstenite::{
-    connect_async_with_config,
     tungstenite::client::IntoClientRequest,
     tungstenite::protocol::{Message as WebSocketMessage, WebSocketConfig},
-    MaybeTlsStream, WebSocketStream,
+    MaybeTlsStream,
+    WebSocketStream,
 };
 
 use crate::metrics::CLIENT_METRICS;
@@ -90,6 +90,18 @@ pub(crate) struct WsConnection {
     sock: WebSocketStream<MaybeTlsStream<TcpStream>>,
 }
 
+impl From<anyhow::Error> for WsError {
+    fn from(err: anyhow::Error) -> Self {
+        WsError::Tungstenite {
+            uri: Uri::default(), // Fallback; context provides real URI
+            source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                std::io::ErrorKind::Other,
+                err.to_string(),
+            ))),
+        }
+    }
+}
+
 fn parse_scheme(scheme: Option<Scheme>) -> Result<Scheme, UriError> {
     Ok(match scheme {
         Some(s) => match s.as_str() {
@@ -207,19 +219,68 @@ impl WsConnection {
         token: Option<&str>,
         connection_id: ConnectionId,
         params: WsParams,
+        trusted_cert: Option<&std::path::PathBuf>,
     ) -> Result<Self, WsError> {
         let req = make_request(host, db_name, token, connection_id, params)?;
 
         // Grab the URI for error-reporting.
         let uri = req.uri().clone();
 
-        let (sock, _): (WebSocketStream<MaybeTlsStream<TcpStream>>, _) = connect_async_with_config(
+        let host = uri.clone(); //shadow, and it's thus wss:// not https://
+        use native_tls::TlsConnector;
+        use std::sync::Arc;
+        use tokio::net::TcpStream;
+        use tokio_tungstenite::{client_async_tls_with_config, Connector, MaybeTlsStream, WebSocketStream};
+
+        let host_str = host.host().ok_or(WsError::UriError(UriError::InvalidUri {
+            source: Arc::new("No host in URI".parse::<Uri>().unwrap_err().into()),
+        }))?;
+        let port = host.port_u16().ok_or(WsError::UriError(UriError::InvalidUri {
+            source: Arc::new("No port specified in URI".parse::<Uri>().unwrap_err().into()),
+        }))?;
+        if port == 0 { // || port > 65535 { //it's u16
+            return Err(WsError::UriError(UriError::InvalidUri {
+                source: Arc::new(format!("Invalid port: {}", port).parse::<Uri>().unwrap_err().into()),
+            }));
+        }
+
+        let tcp_stream = TcpStream::connect((host_str, port))
+            .await
+            .map_err(|source| WsError::Tungstenite {
+                uri: uri.clone(),
+                source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(source)),
+            })?;
+
+        let connector = if host.scheme_str() == Some("wss") {
+            //FIXME: --cert implies wss, or do we want to allow --cert even for ws instead of error-ing!
+            let mut builder = TlsConnector::builder();
+            if let Some(cert_path) = trusted_cert {
+                if let Some(cert) = spacetimedb_lib::load_root_cert(Some(cert_path.as_path())).await? {
+                    builder.add_root_certificate(cert);
+                }
+            }
+            let tls_connector = builder.build().map_err(|e| WsError::Tungstenite {
+                uri: uri.clone(),
+                source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                    std::io::ErrorKind::Other,
+                    e,
+                ))),
+            })?;
+            Some(Connector::NativeTls(tls_connector))
+        } else {
+            //This is probably just ws:// ie. from http:// aka plaintext non-TLS
+            //eprintln!("!!! Unexpected non-wss:// scheme, is: {}", uri);
+            None
+        };
+
+        let (sock, _): (WebSocketStream<MaybeTlsStream<TcpStream>>, _) = client_async_tls_with_config(
             req,
+            tcp_stream,
             // TODO(kim): In order to be able to replicate module WASM blobs,
             // `cloud-next` cannot have message / frame size limits. That's
             // obviously a bad default for all other clients, though.
             Some(WebSocketConfig::default().max_frame_size(None).max_message_size(None)),
-            false,
+            connector
         )
         .await
         .map_err(|source| WsError::Tungstenite {
@@ -231,7 +292,7 @@ impl WsConnection {
             connection_id,
             sock,
         })
-    }
+    } //connect(
 
     pub(crate) fn parse_response(bytes: &[u8]) -> Result<ServerMessage<BsatnFormat>, WsError> {
         let (compression, bytes) = bytes.split_first().ok_or(WsError::EmptyMessage)?;
diff --git a/crates/standalone/Cargo.toml b/crates/standalone/Cargo.toml
index 5207edf4..beef27b7 100644
--- a/crates/standalone/Cargo.toml
+++ b/crates/standalone/Cargo.toml
@@ -29,6 +29,16 @@ spacetimedb-paths.workspace = true
 anyhow.workspace = true
 async-trait.workspace = true
 axum.workspace = true
+
+# Add this for TLS support
+#axum-server = "0.6"  # Compatible with axum 0.7.9
+#axum-server = "0.7"  # Compatible with axum 0.7.9
+axum-server = { version = "0.7.2", features = ["tls-rustls"] }
+
+ring = "0.17"  # explicitly add this for the CryptoProvider, even tho it's included transitively.
+rustls= { version="0.23", default-features = true, features=[ "ring" ] }
+rustls-pemfile = "2.2"
+
 clap = { workspace = true, features = ["derive", "string"] }
 dirs.workspace = true
 futures.workspace = true
diff --git a/crates/standalone/src/subcommands/start.rs b/crates/standalone/src/subcommands/start.rs
index d74267c6..fd3e2ae3 100644
--- a/crates/standalone/src/subcommands/start.rs
+++ b/crates/standalone/src/subcommands/start.rs
@@ -1,4 +1,9 @@
 use std::sync::Arc;
+use std::path::Path;
+use std::path::PathBuf;
+use tokio::io::AsyncReadExt;
+use rustls::pki_types::{CertificateDer, PrivateKeyDer};
+use rustls::pki_types::PrivatePkcs8KeyDer;
 
 use crate::StandaloneEnv;
 use anyhow::Context;
@@ -13,7 +18,6 @@ use spacetimedb_client_api::routes::database::DatabaseRoutes;
 use spacetimedb_client_api::routes::router;
 use spacetimedb_paths::cli::{PrivKeyPath, PubKeyPath};
 use spacetimedb_paths::server::ServerDataDir;
-use tokio::net::TcpListener;
 
 pub fn cli() -> clap::Command {
     clap::Command::new("start")
@@ -67,9 +71,136 @@ pub fn cli() -> clap::Command {
         .arg(Arg::new("in_memory").long("in-memory").action(SetTrue).help(
             "If specified the database will run entirely in memory. After the process exits all data will be lost.",
         ))
+        .arg(Arg::new("ssl").long("ssl").alias("tls").alias("https").alias("secure").action(clap::ArgAction::SetTrue).help("enables the standalone server to listen in SSL mode, ie. use https instead of http to connect to it. Aliases --tls, --ssl, --secure, or --https."))
+        .arg(
+            spacetimedb_lib::cert()
+            .requires("ssl")
+            .help("--cert server.crt: The server sends this to clients during the TLS handshake. ie. server's certificate which contains its public key, which if it's self-signed then this is the file that you must pass to clients via --cert when talking to the server from a client(or the cli), or if signed by a local CA then pass that CA's cert to your clients instead, in order to can trust this server from a client connection. Otherwise, you don't have to pass anything to clients if this cert was signed by a public CA like Let's Encrypt.")
+        )
+        .arg(Arg::new("key").long("key").requires("ssl").value_name("FILE")
+            .action(clap::ArgAction::Set)
+            .value_parser(clap::value_parser!(PathBuf))
+            .help("--key server.key: The server's private key used to decrypt and sign responses."))
     // .after_help("Run `spacetime help start` for more detailed information.")
 }
 
+/// Asynchronously reads a file with a maximum size limit of 1 MiB.
+async fn read_file_limited(path: &Path) -> anyhow::Result<Vec<u8>> {
+    const MAX_SIZE: usize = 1_048_576; // 1 MiB
+
+    let file = tokio::fs::File::open(path)
+        .await
+        .map_err(|e| anyhow::anyhow!("Failed to open file {}: {}", path.display(), e))?;
+    let metadata = file
+        .metadata()
+        .await
+        .map_err(|e| anyhow::anyhow!("Failed to read metadata for {}: {}", path.display(), e))?;
+
+    if metadata.len() > MAX_SIZE as u64 {
+        return Err(anyhow::anyhow!(
+            "File {} exceeds maximum size of {} bytes",
+            path.display(),
+            MAX_SIZE
+        ));
+    }
+
+    let mut reader = tokio::io::BufReader::new(file);
+    let mut data = Vec::with_capacity(metadata.len() as usize);
+    reader
+        .read_to_end(&mut data)
+        .await
+        .map_err(|e| anyhow::anyhow!("Failed to read file {}: {}", path.display(), e))?;
+
+    Ok(data)
+}
+
+/// Loads certificates from a PEM file.
+async fn load_certs(file_path: &Path) -> anyhow::Result<Vec<CertificateDer<'static>>> {
+    let data = read_file_limited(file_path).await?;
+    let certs: Vec<CertificateDer<'static>> = rustls_pemfile::certs(&mut std::io::Cursor::new(data))
+        .collect::<Result<Vec<_>, _>>()
+        .map_err(|e| anyhow::anyhow!("Failed to parse certificates from {}: {:?}", file_path.display(), e))?;
+    match certs.len() {
+        0 => Err(anyhow::anyhow!("No certificates found in file {}", file_path.display())),
+        1 => Ok(certs),
+        _ => Err(anyhow::anyhow!("Multiple certificates found in file {}; only one certificate is expected.", file_path.display())),
+    }
+}
+
+/// Loads a private key from a PEM file.
+async fn load_private_key(file_path: &Path) -> anyhow::Result<PrivateKeyDer<'static>> {
+    let data = read_file_limited(file_path).await?;
+    let keys: Vec<PrivatePkcs8KeyDer<'static>> = rustls_pemfile::pkcs8_private_keys(&mut std::io::Cursor::new(data))
+        .collect::<Result<Vec<_>, _>>()
+        .map_err(|e| anyhow::anyhow!("Failed to parse private keys from {}: {:?}", file_path.display(), e))?;
+    match keys.len() {
+        0 => Err(anyhow::anyhow!("No private key found in file {}", file_path.display())),
+        1 => Ok(PrivateKeyDer::Pkcs8(keys.into_iter().next().unwrap())),
+        _ => Err(anyhow::anyhow!("Multiple private keys found in file {}; only one private key is expected.", file_path.display())),
+    }
+}
+
+/// Creates a custom CryptoProvider with specific cipher suites.
+fn custom_crypto_provider() -> rustls::crypto::CryptoProvider {
+    use rustls::crypto::ring::default_provider;
+    use rustls::crypto::ring::cipher_suite;
+    use rustls::crypto::ring::kx_group;
+
+    let cipher_suites = vec![
+        // TLS 1.3
+        // test with: $ openssl s_client -connect 127.0.0.1:3000 -tls1_3
+        cipher_suite::TLS13_AES_256_GCM_SHA384,
+        cipher_suite::TLS13_AES_128_GCM_SHA256,
+        cipher_suite::TLS13_CHACHA20_POLY1305_SHA256,
+        // TLS 1.2
+        // these are ignored if builder_with_protocol_versions() below doesn't contain TLS 1.2
+        // test with: $ openssl s_client -connect 127.0.0.1:3000 -tls1_2
+        cipher_suite::TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+        cipher_suite::TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+        cipher_suite::TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+        cipher_suite::TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+        cipher_suite::TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+        cipher_suite::TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
+    ];
+
+    // (KX) groups used in TLS handshakes to negotiate the shared secret between client and server.
+    let kx_groups = vec![
+        kx_group::X25519,
+        /*
+           X25519:
+
+           An elliptic curve Diffie-Hellman (ECDH) key exchange algorithm based on Curve25519.
+           Known for high security, speed, and resistance to side-channel attacks.
+           Commonly used in modern TLS (1.2 and 1.3) due to its efficiency and forward secrecy.
+           Preferred by many clients (e.g., browsers) for TLS 1.3 handshakes.
+           */
+        kx_group::SECP256R1,
+        /*
+           SECP256R1 (aka NIST P-256):
+
+           An elliptic curve standardized by NIST, using a 256-bit prime field.
+           Widely supported across TLS 1.2 and 1.3, especially in enterprise environments.
+           Slightly less performant than X25519 but trusted due to long-standing use.
+           Common in certificates signed by older CAs or legacy systems.
+           */
+        kx_group::SECP384R1,
+        /*
+           SECP384R1 (aka NIST P-384):
+
+           Another NIST elliptic curve, using a 384-bit prime field for higher security.
+           Offers stronger cryptographic strength than SECP256R1, at the cost of slower performance.
+           Used in TLS 1.2 and 1.3 when higher assurance is needed (e.g., government systems).
+           Less common than X25519 or SECP256R1 due to computational overhead.
+           */
+    ];
+
+    rustls::crypto::CryptoProvider {
+        cipher_suites,
+        kx_groups,
+        ..default_provider()
+    }
+}
+
 pub async fn exec(args: &ArgMatches) -> anyhow::Result<()> {
     let listen_addr = args.get_one::<String>("listen_addr").unwrap();
     let cert_dir = args.get_one::<spacetimedb_paths::cli::ConfigDir>("jwt_key_dir");
@@ -143,10 +274,49 @@ pub async fn exec(args: &ArgMatches) -> anyhow::Result<()> {
     let extra = axum::Router::new().nest("/health", spacetimedb_client_api::routes::health::router());
     let service = router(&ctx, db_routes, extra).with_state(ctx);
 
-    let tcp = TcpListener::bind(listen_addr).await?;
-    socket2::SockRef::from(&tcp).set_nodelay(true)?;
-    log::debug!("Starting SpacetimeDB listening on {}", tcp.local_addr().unwrap());
-    axum::serve(tcp, service).await?;
+    use std::net::SocketAddr;
+    let addr: SocketAddr = listen_addr.parse()?;
+
+    if args.get_flag("ssl") {
+        // Install custom CryptoProvider at the start
+        rustls::crypto::CryptoProvider::install_default(custom_crypto_provider())
+            .map_err(|e| anyhow::anyhow!("Failed to install custom CryptoProvider: {:?}", e))?;
+
+        let cert_path: &Path = args.get_one::<PathBuf>("cert").context("Missing --cert for SSL")?.as_path();
+        let key_path: &Path = args.get_one::<PathBuf>("key").context("Missing --key for SSL")?.as_path();
+
+        // Load certificate and private key with file size limit
+        let cert_chain = load_certs(cert_path).await?;
+        let private_key = load_private_key(key_path).await?;
+
+        // Create ServerConfig with secure settings
+        let config=
+            rustls::ServerConfig::builder_with_protocol_versions(&[
+                &rustls::version::TLS13,
+//                &rustls::version::TLS12,
+            ])
+//            rustls::ServerConfig::builder() // using this instead, wouldn't restrict proto versions.
+            .with_no_client_auth()
+            .with_single_cert(cert_chain, private_key)
+            .map_err(|e| anyhow::anyhow!("Failed to set certificates from files pub:'{}', priv:'{}', err: {}", cert_path.display(), key_path.display(), e))?;
+
+        // Use axum_server with custom config
+        let tls_config = axum_server::tls_rustls::RustlsConfig::from_config(Arc::new(config));
+
+        log::info!(
+            "Starting SpacetimeDB with SSL on {}.",
+            addr,
+        );
+        axum_server::bind_rustls(addr, tls_config)
+            .serve(service.into_make_service())
+            .await?;
+    } else {
+        log::debug!("Starting SpacetimeDB without any ssl (so it's plaintext) listening on {}", addr);
+        axum_server::bind(addr)
+            .serve(service.into_make_service())
+            .await?;
+    }
+
     Ok(())
 }
 
