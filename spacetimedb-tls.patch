Adds ability to listen as https via TLS 1.3 for SpacetimeDB standalone server with self-signed or CA-signed certs, and allows clients(rust, cli) to pass --cert with a trusted cert (like server's self-signed cert or CA's public cert) to not fail signature check. Can now do mTLS too, optionally, which means clients can be authenticated(by the server) by providing their cert to the server.

Currently limited to TLS 1.3 only, but can be changed in source code to allow TLS 1.2 also.

Future updates should be here: https://github.com/dare3path/spacetimedb-tls-patch
While this is still a work in progress, proof-of-concept patch, it works as intended so far that I'm aware of: so the rust client and all cli commands that I'm aware of accept --cert, though they already worked as TLS clients before(ie. if you server cert was signed by a known CA, otherwise you need --cert).

An earlier version(not updated there anymore) of this patch is already an upstream _draft_ PR here:
https://github.com/clockworklabs/SpacetimeDB/pull/2598
it's meant to remain as a draft, never-to-be-merged mainly because actual devs can do this in a better way, so it's only meant to be an example, working, proof-of-concept patch.

patch is to be applied on latest master, currently:
commit 0f70e6330403fde4b9096afd0a098f2f2d34e786 (upstream/master, upstream/HEAD, master)
Date:   Fri May 2 12:51:48 2025 -0700

a copy of this patch is on https://github.com/dare3path/SpacetimeDB/tree/ssl_for_standalone_server_NOT_in_PR
(^ git diff master)
it's usually rebased on master.
This branch may be more up to date than this patch.

Requirements:
* the `Cargo.toml` from the repo's root dir has a `[patch.crates-io]` section for a couple of repos which means these need to be cloned and patched locally and modify the `Cargo.toml` paths in there to point to where they are locally. This enables stuff like sanitizing the private keys and avoiding some obscure connection errors(like getting ChannelClosed instead of the actual error).


The features that this patch confers are as follows:

======
the spacetime standalone server can listen for incoming TLS connections if you use the --ssl arg, but plaintext ones(like without this patch) aren't accepted unless you stop it and start it without the --ssl arg.

clients already could connect to it via TLS, however the server's cert must've been signed by a trusted(in root store) CA (certificate authority) already, however you can use --cert as mentioned below:
======
You can use --cert for most cli commands(including the rust quickstart-chat example) to add a public certificate to trust (ie. as if it were part of the cert trust store) which can thus be either the server's public cert, or the CA's public cert which is the CA that signed the server's public cert. This way, the client knows the server's public cert is trusted and will connect successfully rather than fail with untrusted signature.
======
These subcommands support --cert (to add a trusted cert file(public) to the client to can authenticate the server):
spacetime server add
spacetime server edit
spacetime server fingerprint
spacetime server ping
spacetime publish
spacetime login
spacetime logs
spacetime delete
spacetime sql
spacetime describe
spacetime subscribe
spacetime call
spacetime start  (this requires passing --key and --ssl also)
spacetime rename
spacetime list
spacetime energy balance
======
These subcommands consider the protocol(eg. https or http) as a unique identifier along with the host and port:
$ spacetime server set-default
$ spacetime server add
$ spacetime server remove
$ spacetime server edit
$ spacetime server fingerprint
$ spacetime server ping

ie. you can have these:

$ spacetime server list
WARNING: This command is UNSTABLE and subject to breaking changes.

 DEFAULT  HOSTNAME                   PROTOCOL  NICKNAME  
          maincloud.spacetimedb.com  https     maincloud 
          127.0.0.1:3000             http      local     
          127.0.0.1:3001             http      local2    
          127.0.0.1:3000             https     slocal    
          127.0.0.1:3001             https     slocal2   

======
You get a warning when using `spacetime login --server-issued-login server` that this `server` isn't the one that cli commands like `spacetime publish`(with no args) will use, but it's the 3 star default one in `spacetime server list` instead.
======
FIXME: the changes in config.rs are supremely hacky, since the original code disregarded protocol as uniquely identifying in addition to the server+port in the list of `spacetime server list`, so there are functions that take only host:port and assume there's only one in the list where in fact now they can be two or more: one for each proto (http, https)
//But seems this is so due to the inability to run more than one spacetimedb (standalone)server per user, since the .pid file is kept in /home/user/.local/share/spacetime/data/spacetime.pid for any/all running instances and thus prevents running more than 1 instance. Unless, --data-dir is specified, then can have multiple instances after all, hmm...
======
avoids OOM if you pass --cert /dev/zero
======
added mutual TLS (mTLS) support
which means, clients can provide a cert to identify themselves, if server used --client-cert arg
to pass the cert file/chain that server will use to check client-provided certs for authentication.
Clients must then use --client-cert and --client-key to pass their cert/private key to cli commands.

Note that: $ spacetime start --help
has a similar feature for identities (ie. after you're already talking to the server, the spacetimedb one,
as opposed to the TLS "handshaking" part of it which is prior and this patch addresses)

      --jwt-pub-key-path <jwt_pub_key_path>    The path to the public jwt key for verifying identities
      --jwt-priv-key-path <jwt_priv_key_path>  The path to the private jwt key for issuing identities

so if that jwt isn't enough for you, then you want this mTLS patch, perhaps in addition to it.
======



diff --git a/Cargo.lock b/Cargo.lock
index 78e77fd7b..ae2deacce 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -194,6 +194,12 @@ dependencies = [
  "derive_arbitrary",
 ]
 
+[[package]]
+name = "arc-swap"
+version = "1.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "69f7f8c3906b62b754cd5326047894316021dcfe5a194c8ea52bdd94934a3457"
+
 [[package]]
 name = "arrayref"
 version = "0.3.9"
@@ -206,6 +212,45 @@ version = "0.7.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50"
 
+[[package]]
+name = "asn1-rs"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "56624a96882bb8c26d61312ae18cb45868e5a9992ea73c58e45c3101e56a1e60"
+dependencies = [
+ "asn1-rs-derive",
+ "asn1-rs-impl",
+ "displaydoc",
+ "nom",
+ "num-traits",
+ "rusticata-macros",
+ "thiserror 2.0.11",
+ "time",
+]
+
+[[package]]
+name = "asn1-rs-derive"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3109e49b1e4909e9db6515a30c633684d68cdeaa252f215214cb4fa1a5bfee2c"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.87",
+ "synstructure 0.13.1",
+]
+
+[[package]]
+name = "asn1-rs-impl"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7b18050c2cd6fe86c3a76584ef5e0baf286d038cda203eb6223df2cc413565f7"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.87",
+]
+
 [[package]]
 name = "async-stream"
 version = "0.3.6"
@@ -292,6 +337,29 @@ version = "1.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26"
 
+[[package]]
+name = "aws-lc-rs"
+version = "1.13.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "19b756939cb2f8dc900aa6dcd505e6e2428e9cae7ff7b028c49e3946efa70878"
+dependencies = [
+ "aws-lc-sys",
+ "zeroize",
+]
+
+[[package]]
+name = "aws-lc-sys"
+version = "0.28.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b9f7720b74ed28ca77f90769a71fd8c637a0137f6fae4ae947e1050229cff57f"
+dependencies = [
+ "bindgen",
+ "cc",
+ "cmake",
+ "dunce",
+ "fs_extra",
+]
+
 [[package]]
 name = "axum"
 version = "0.7.7"
@@ -305,7 +373,7 @@ dependencies = [
  "http 1.1.0",
  "http-body 1.0.1",
  "http-body-util",
- "hyper 1.5.0",
+ "hyper 1.6.0",
  "hyper-util",
  "itoa",
  "matchit",
@@ -370,6 +438,28 @@ dependencies = [
  "tracing",
 ]
 
+[[package]]
+name = "axum-server"
+version = "0.7.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "495c05f60d6df0093e8fb6e74aa5846a0ad06abaf96d76166283720bf740f8ab"
+dependencies = [
+ "arc-swap",
+ "bytes",
+ "fs-err 3.1.0",
+ "http 1.1.0",
+ "http-body 1.0.1",
+ "hyper 1.6.0",
+ "hyper-util",
+ "pin-project-lite",
+ "rustls",
+ "rustls-pemfile 2.2.0",
+ "rustls-pki-types",
+ "tokio",
+ "tokio-rustls",
+ "tower-service",
+]
+
 [[package]]
 name = "backtrace"
 version = "0.3.74"
@@ -427,6 +517,29 @@ dependencies = [
  "serde",
 ]
 
+[[package]]
+name = "bindgen"
+version = "0.69.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "271383c67ccabffb7381723dea0672a673f292304fcb45c01cc648c7a8d58088"
+dependencies = [
+ "bitflags 2.6.0",
+ "cexpr",
+ "clang-sys",
+ "itertools 0.12.1",
+ "lazy_static",
+ "lazycell",
+ "log",
+ "prettyplease",
+ "proc-macro2",
+ "quote",
+ "regex",
+ "rustc-hash 1.1.0",
+ "shlex",
+ "syn 2.0.87",
+ "which",
+]
+
 [[package]]
 name = "bit-set"
 version = "0.5.3"
@@ -689,9 +802,9 @@ checksum = "37b2a672a2cb129a2e41c10b1224bb368f9f37a2b16b612598138befd7b37eb5"
 
 [[package]]
 name = "cc"
-version = "1.2.0"
+version = "1.2.20"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1aeb932158bd710538c73702db6945cb68a8fb08c519e6e12706b94263b36db8"
+checksum = "04da6a0d40b948dfc4fa8f5bbf402b0fc1a64a28dbf7d12ffd683550f2c1b63a"
 dependencies = [
  "jobserver",
  "libc",
@@ -704,6 +817,15 @@ version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6d43a04d8753f35258c91f8ec639f792891f748a1edbd759cf1dcea3382ad83c"
 
+[[package]]
+name = "cexpr"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766"
+dependencies = [
+ "nom",
+]
+
 [[package]]
 name = "cfg-if"
 version = "1.0.0"
@@ -768,6 +890,17 @@ dependencies = [
  "inout",
 ]
 
+[[package]]
+name = "clang-sys"
+version = "1.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b023947811758c97c59bf9d1c188fd619ad4718dcaa767947df1cadb14f39f4"
+dependencies = [
+ "glob",
+ "libc",
+ "libloading",
+]
+
 [[package]]
 name = "clap"
 version = "3.2.23"
@@ -868,6 +1001,15 @@ dependencies = [
  "winapi",
 ]
 
+[[package]]
+name = "cmake"
+version = "0.1.54"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e7caa3f9de89ddbe2c607f4101924c5abec803763ae9534e4f4d7d8f84aa81f0"
+dependencies = [
+ "cc",
+]
+
 [[package]]
 name = "cobs"
 version = "0.2.3"
@@ -1024,7 +1166,7 @@ dependencies = [
  "hashbrown 0.14.5",
  "log",
  "regalloc2",
- "rustc-hash",
+ "rustc-hash 2.0.0",
  "smallvec",
  "target-lexicon",
 ]
@@ -1407,6 +1549,20 @@ version = "0.1.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "da692b8d1080ea3045efaab14434d40468c3d8657e42abddfffca87b428f4c1b"
 
+[[package]]
+name = "der-parser"
+version = "10.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "07da5016415d5a3c4dd39b11ed26f915f52fc4e0dc197d87908bc916e51bc1a6"
+dependencies = [
+ "asn1-rs",
+ "displaydoc",
+ "nom",
+ "num-bigint",
+ "num-traits",
+ "rusticata-macros",
+]
+
 [[package]]
 name = "deranged"
 version = "0.3.11"
@@ -1534,6 +1690,12 @@ dependencies = [
  "shared_child",
 ]
 
+[[package]]
+name = "dunce"
+version = "1.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "92773504d58c093f6de2459af4af33faa518c13451eb8f2b5698ed3d36e7c813"
+
 [[package]]
 name = "educe"
 version = "0.4.23"
@@ -1856,6 +2018,16 @@ dependencies = [
  "autocfg",
 ]
 
+[[package]]
+name = "fs-err"
+version = "3.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1f89bda4c2a21204059a977ed3bfe746677dfd137b83c339e702b0ac91d482aa"
+dependencies = [
+ "autocfg",
+ "tokio",
+]
+
 [[package]]
 name = "fs2"
 version = "0.4.3"
@@ -1866,6 +2038,12 @@ dependencies = [
  "winapi",
 ]
 
+[[package]]
+name = "fs_extra"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42703706b716c37f96a77aea830392ad231f44c9e9a67872fa5548707e11b11c"
+
 [[package]]
 name = "fuchsia-cprng"
 version = "0.1.1"
@@ -2339,9 +2517,9 @@ dependencies = [
 
 [[package]]
 name = "hyper"
-version = "1.5.0"
+version = "1.6.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbbff0a806a4728c99295b254c8838933b5b082d75e3cb70c8dab21fdfbcfa9a"
+checksum = "cc2b571658e38e0c01b1fdca3bbbe93c00d3d71693ff2770043f8c29bc7d6f80"
 dependencies = [
  "bytes",
  "futures-channel",
@@ -2366,7 +2544,7 @@ checksum = "08afdbb5c31130e3034af566421053ab03787c640246a446327f550d11bcb333"
 dependencies = [
  "futures-util",
  "http 1.1.0",
- "hyper 1.5.0",
+ "hyper 1.6.0",
  "hyper-util",
  "rustls",
  "rustls-pki-types",
@@ -2396,7 +2574,7 @@ checksum = "70206fc6890eaca9fde8a0bf71caa2ddfc9fe045ac9e5c70df101a7dbde866e0"
 dependencies = [
  "bytes",
  "http-body-util",
- "hyper 1.5.0",
+ "hyper 1.6.0",
  "hyper-util",
  "native-tls",
  "tokio",
@@ -2406,16 +2584,15 @@ dependencies = [
 
 [[package]]
 name = "hyper-util"
-version = "0.1.10"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "df2dcfbe0677734ab2f3ffa7fa7bfd4706bfdc1ef393f2ee30184aed67e631b4"
+version = "0.1.11"
 dependencies = [
  "bytes",
  "futures-channel",
  "futures-util",
  "http 1.1.0",
  "http-body 1.0.1",
- "hyper 1.5.0",
+ "hyper 1.6.0",
+ "libc",
  "pin-project-lite",
  "socket2",
  "tokio",
@@ -2911,6 +3088,12 @@ version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
+[[package]]
+name = "lazycell"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55"
+
 [[package]]
 name = "leb128"
 version = "0.2.5"
@@ -2919,9 +3102,19 @@ checksum = "884e2677b40cc8c339eaefcb701c32ef1fd2493d71118dc0ca4b6a736c93bd67"
 
 [[package]]
 name = "libc"
-version = "0.2.162"
+version = "0.2.172"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d750af042f7ef4f724306de029d18836c26c1765a54a6a3f094cbd23a7267ffa"
+
+[[package]]
+name = "libloading"
+version = "0.8.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "18d287de67fe55fd7e1581fe933d965a5a9477b38e949cfa9f8574ef01506398"
+checksum = "fc2f4eb4bc735547cfed7c0a4922cbd04a4655978c09b54f1f7b228750664c34"
+dependencies = [
+ "cfg-if",
+ "windows-targets 0.52.6",
+]
 
 [[package]]
 name = "libm"
@@ -3138,6 +3331,12 @@ version = "0.3.17"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"
 
+[[package]]
+name = "minimal-lexical"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"
+
 [[package]]
 name = "miniz_oxide"
 version = "0.8.0"
@@ -3192,7 +3391,7 @@ dependencies = [
  "openssl-probe",
  "openssl-sys",
  "schannel",
- "security-framework",
+ "security-framework 2.11.1",
  "security-framework-sys",
  "tempfile",
 ]
@@ -3229,6 +3428,16 @@ version = "0.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2bf50223579dc7cdcfb3bfcacf7069ff68243f8c363f62ffa99cf000a6b9c451"
 
+[[package]]
+name = "nom"
+version = "7.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
+dependencies = [
+ "memchr",
+ "minimal-lexical",
+]
+
 [[package]]
 name = "nu-ansi-term"
 version = "0.46.0"
@@ -3400,6 +3609,15 @@ dependencies = [
  "memchr",
 ]
 
+[[package]]
+name = "oid-registry"
+version = "0.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "12f40cff3dde1b6087cc5d5f5d4d65712f34016a03ed60e9c08dcc392736b5b7"
+dependencies = [
+ "asn1-rs",
+]
+
 [[package]]
 name = "once_cell"
 version = "1.20.2"
@@ -3833,6 +4051,16 @@ dependencies = [
  "yansi",
 ]
 
+[[package]]
+name = "prettyplease"
+version = "0.2.25"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "64d1ec885c64d0457d564db4ec299b2dae3f9c02808b8ad9c3a089c591b18033"
+dependencies = [
+ "proc-macro2",
+ "syn 2.0.87",
+]
+
 [[package]]
 name = "proc-macro-crate"
 version = "3.2.0"
@@ -4237,7 +4465,7 @@ checksum = "12908dbeb234370af84d0579b9f68258a0f67e201412dd9a2814e6f45b2fc0f0"
 dependencies = [
  "hashbrown 0.14.5",
  "log",
- "rustc-hash",
+ "rustc-hash 2.0.0",
  "slice-group-by",
  "smallvec",
 ]
@@ -4359,7 +4587,7 @@ dependencies = [
  "http 1.1.0",
  "http-body 1.0.1",
  "http-body-util",
- "hyper 1.5.0",
+ "hyper 1.6.0",
  "hyper-rustls",
  "hyper-tls 0.6.0",
  "hyper-util",
@@ -4400,17 +4628,15 @@ dependencies = [
 
 [[package]]
 name = "ring"
-version = "0.17.8"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c17fa4cb658e3583423e915b9f3acc01cceaee1860e33d59ebae66adc3a2dc0d"
+version = "0.17.14"
 dependencies = [
  "cc",
  "cfg-if",
  "getrandom 0.2.15",
  "libc",
- "spin",
  "untrusted",
  "windows-sys 0.52.0",
+ "zeroize",
 ]
 
 [[package]]
@@ -4491,6 +4717,12 @@ version = "0.1.24"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"
 
+[[package]]
+name = "rustc-hash"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"
+
 [[package]]
 name = "rustc-hash"
 version = "2.0.0"
@@ -4506,6 +4738,15 @@ dependencies = [
  "semver",
 ]
 
+[[package]]
+name = "rusticata-macros"
+version = "4.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "faf0c4a6ece9950b9abdb62b1cfcf2a68b3b67a10ba445b3bb85be2a293d0632"
+dependencies = [
+ "nom",
+]
+
 [[package]]
 name = "rustix"
 version = "0.38.40"
@@ -4521,17 +4762,30 @@ dependencies = [
 
 [[package]]
 name = "rustls"
-version = "0.23.16"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "eee87ff5d9b36712a58574e12e9f0ea80f915a5b0ac518d322b24a465617925e"
+version = "0.23.26"
 dependencies = [
+ "aws-lc-rs",
+ "log",
  "once_cell",
+ "ring",
  "rustls-pki-types",
  "rustls-webpki",
  "subtle",
  "zeroize",
 ]
 
+[[package]]
+name = "rustls-native-certs"
+version = "0.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7fcff2dd52b58a8d98a70243663a0d234c4e2b79235637849d15913394a247d3"
+dependencies = [
+ "openssl-probe",
+ "rustls-pki-types",
+ "schannel",
+ "security-framework 3.2.0",
+]
+
 [[package]]
 name = "rustls-pemfile"
 version = "1.0.4"
@@ -4552,16 +4806,18 @@ dependencies = [
 
 [[package]]
 name = "rustls-pki-types"
-version = "1.10.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "16f1201b3c9a7ee8039bcadc17b7e605e2945b27eee7631788c1bd2b0643674b"
+version = "1.11.0"
+dependencies = [
+ "zeroize",
+]
 
 [[package]]
 name = "rustls-webpki"
-version = "0.102.8"
+version = "0.103.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "64ca1bc8749bd4cf37b5ce386cc146580777b4e8572c7b97baf22c83f444bee9"
+checksum = "fef8b8769aaccf73098557a87cd1816b4f9c7c16811c9c77142aa695c16f2c03"
 dependencies = [
+ "aws-lc-rs",
  "ring",
  "rustls-pki-types",
  "untrusted",
@@ -4689,11 +4945,24 @@ dependencies = [
  "security-framework-sys",
 ]
 
+[[package]]
+name = "security-framework"
+version = "3.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "271720403f46ca04f7ba6f55d438f8bd878d6b8ca0a1046e8228c4145bcbb316"
+dependencies = [
+ "bitflags 2.6.0",
+ "core-foundation 0.10.0",
+ "core-foundation-sys",
+ "libc",
+ "security-framework-sys",
+]
+
 [[package]]
 name = "security-framework-sys"
-version = "2.12.1"
+version = "2.14.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fa39c7303dc58b5543c94d22c1766b0d31f2ee58306363ea622b10bbc075eaa2"
+checksum = "49db231d56a190491cb4aeda9527f1ad45345af50b0851622a7adb8c03b01c32"
 dependencies = [
  "core-foundation-sys",
  "libc",
@@ -5009,9 +5278,9 @@ dependencies = [
 
 [[package]]
 name = "socket2"
-version = "0.5.7"
+version = "0.5.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ce305eb0b4296696835b71df73eb912e0f1ffd2556a501fcede6e0c50349191c"
+checksum = "4f5fd57c80058a56cf5c777ab8a126398ece8e442983605d280a44ce79d0edef"
 dependencies = [
  "libc",
  "windows-sys 0.52.0",
@@ -5137,20 +5406,24 @@ dependencies = [
  "duct",
  "email_address",
  "flate2",
- "fs-err",
+ "fs-err 2.11.0",
  "futures",
  "http 1.1.0",
  "indicatif",
  "is-terminal",
  "itertools 0.12.1",
  "mimalloc",
+ "native-tls",
  "percent-encoding",
  "regex",
  "reqwest 0.12.9",
+ "rustls-pemfile 2.2.0",
+ "rustls-pki-types",
  "rustyline",
  "serde",
  "serde_json",
  "serde_with",
+ "sha2",
  "slab",
  "spacetimedb-auth",
  "spacetimedb-client-api-messages",
@@ -5179,6 +5452,8 @@ dependencies = [
  "wasmbin",
  "webbrowser",
  "windows-sys 0.59.0",
+ "x509-parser",
+ "zeroize",
 ]
 
 [[package]]
@@ -5197,7 +5472,7 @@ dependencies = [
  "futures",
  "headers",
  "http 1.1.0",
- "hyper 1.5.0",
+ "hyper 1.6.0",
  "hyper-util",
  "itoa",
  "jemalloc_pprof",
@@ -5260,7 +5535,7 @@ version = "1.1.1"
 dependencies = [
  "anyhow",
  "convert_case 0.6.0",
- "fs-err",
+ "fs-err 2.11.0",
  "insta",
  "itertools 0.12.1",
  "regex",
@@ -5335,7 +5610,7 @@ dependencies = [
  "hashbrown 0.15.1",
  "hex",
  "hostname",
- "hyper 1.5.0",
+ "hyper 1.6.0",
  "imara-diff",
  "indexmap 2.6.0",
  "itertools 0.12.1",
@@ -5357,7 +5632,7 @@ dependencies = [
  "regex",
  "reqwest 0.12.9",
  "rustc-demangle",
- "rustc-hash",
+ "rustc-hash 2.0.0",
  "scopeguard",
  "semver",
  "serde",
@@ -5527,15 +5802,21 @@ dependencies = [
  "blake3",
  "bytes",
  "chrono",
+ "clap 4.5.20",
  "derive_more",
  "enum-as-inner",
  "enum-map",
  "hex",
+ "hyper 1.6.0",
  "insta",
  "itertools 0.12.1",
+ "native-tls",
+ "openssl",
  "proptest",
  "proptest-derive",
+ "reqwest 0.12.9",
  "ron",
+ "rustls-pki-types",
  "serde",
  "serde_json",
  "spacetimedb-bindings-macro",
@@ -5543,7 +5824,10 @@ dependencies = [
  "spacetimedb-metrics",
  "spacetimedb-primitives",
  "spacetimedb-sats",
+ "tempfile",
  "thiserror 1.0.69",
+ "tokio",
+ "zeroize",
 ]
 
 [[package]]
@@ -5680,10 +5964,12 @@ dependencies = [
 name = "spacetimedb-sdk"
 version = "1.1.1"
 dependencies = [
+ "anyhow",
  "anymap",
  "base64 0.21.7",
  "brotli",
  "bytes",
+ "clap 4.5.20",
  "cursive",
  "futures",
  "futures-channel",
@@ -5691,9 +5977,13 @@ dependencies = [
  "home",
  "http 1.1.0",
  "log",
+ "native-tls",
  "once_cell",
  "prometheus",
  "rand 0.9.0",
+ "rustls",
+ "rustls-pemfile 2.2.0",
+ "rustls-pki-types",
  "spacetimedb-client-api-messages",
  "spacetimedb-data-structures",
  "spacetimedb-lib",
@@ -5703,6 +5993,7 @@ dependencies = [
  "thiserror 1.0.69",
  "tokio",
  "tokio-tungstenite",
+ "zeroize",
 ]
 
 [[package]]
@@ -5751,6 +6042,7 @@ dependencies = [
  "anyhow",
  "async-trait",
  "axum",
+ "axum-server",
  "clap 4.5.20",
  "dirs",
  "futures",
@@ -5761,8 +6053,14 @@ dependencies = [
  "openssl",
  "parse-size",
  "prometheus",
+ "ring",
+ "rustls",
+ "rustls-native-certs",
+ "rustls-pemfile 2.2.0",
+ "rustls-pki-types",
  "scopeguard",
  "serde_json",
+ "sha2",
  "sled",
  "socket2",
  "spacetimedb-client-api",
@@ -5779,6 +6077,8 @@ dependencies = [
  "toml 0.8.19",
  "tower-http",
  "tracing",
+ "x509-parser",
+ "zeroize",
 ]
 
 [[package]]
@@ -5893,12 +6193,6 @@ dependencies = [
  "typed-arena",
 ]
 
-[[package]]
-name = "spin"
-version = "0.9.8"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6980e8d7511241f8acf4aebddbb1ff938df5eebe98691418c4468d0b72a96a67"
-
 [[package]]
 name = "sptr"
 version = "0.3.2"
@@ -5913,7 +6207,7 @@ checksum = "78ea1056caa9180e7e5727eed1a377d96c9f4615303fa82d2f4c202c64736dee"
 dependencies = [
  "async-trait",
  "educe",
- "fs-err",
+ "fs-err 2.11.0",
  "futures",
  "glob",
  "humantime",
@@ -5971,7 +6265,7 @@ dependencies = [
  "clap 4.5.20",
  "console",
  "derive_more",
- "fs-err",
+ "fs-err 2.11.0",
  "futures",
  "glob",
  "itertools 0.12.1",
@@ -7903,6 +8197,23 @@ dependencies = [
  "tap",
 ]
 
+[[package]]
+name = "x509-parser"
+version = "0.17.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4569f339c0c402346d4a75a9e39cf8dad310e287eef1ff56d4c68e5067f53460"
+dependencies = [
+ "asn1-rs",
+ "data-encoding",
+ "der-parser",
+ "lazy_static",
+ "nom",
+ "oid-registry",
+ "rusticata-macros",
+ "thiserror 2.0.11",
+ "time",
+]
+
 [[package]]
 name = "xattr"
 version = "1.3.1"
diff --git a/Cargo.toml b/Cargo.toml
index 296e4d58a..cd5ebbb51 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -66,7 +66,8 @@ lto = "thin"
 
 [profile.dev]
 opt-level = 0
-debug = true
+debug = 1
+#debug = true #FIXME: put this back
 debug-assertions = true
 overflow-checks = true
 lto = false
@@ -130,7 +131,12 @@ arrayvec = "0.7.2"
 async-stream = "0.3.6"
 async-trait = "0.1.68"
 axum = { version = "0.7", features = ["tracing"] }
+axum-server = { version = "0.7.2", features = ["tls-rustls"] }
 axum-extra = { version = "0.9", features = ["typed-header"] }
+#rustls-platform-verifier = "0.5"
+x509-parser = "0.17"
+sha2="0.10.8"
+rustls-native-certs = "0.8"
 backtrace = "0.3.66"
 base64 = "0.21.2"
 bigdecimal = "0.4.7"
@@ -180,8 +186,9 @@ home = "0.5"
 hostname = "^0.3"
 http = "1.0"
 humantime = "2.1.0"
-hyper = "1.0"
-hyper-util = { version = "0.1", features = ["tokio"] }
+hyper = "1.6"
+hyper-util = { version = "0.1.11", features = ["tokio"] }
+zeroize = { version="1.8.1", features=["alloc"] }
 imara-diff = "0.1.3"
 indexmap = "2.0.0"
 indicatif = "0.17"
@@ -217,7 +224,13 @@ rand = "0.9"
 rayon = "1.8"
 rayon-core = "1.11.0"
 regex = "1"
-reqwest = { version = "0.12", features = ["stream", "json"] }
+reqwest = { version = "0.12", features = ["stream", "json", "native-tls"] }
+rustls-pemfile = "2.2"
+#rustls = "0.23"
+rustls= { version="0.23", default-features = true, features=[ "ring" ] }
+native-tls = "0.2"  # Explicitly add for Connector::NativeTls
+#XXX: using 'my_fork' feature ensures the current crate uses the dep from the fork and allows that fork to control any extra features like tracing.
+ring = { version= "0.17.14", default-features = true, features = ["my_fork"] }  # explicitly add this for the CryptoProvider, even tho it's included transitively. +  we need the trace feature
 ron = "0.8"
 rusqlite = { version = "0.29.0", features = ["bundled", "column_decltype"] }
 rust_decimal = { version = "1.29.1", features = ["db-tokio-postgres"] }
@@ -288,6 +301,27 @@ tikv-jemalloc-ctl = { version = "0.6.0", features = ["stats"] }
 jemalloc_pprof = { version = "0.7", features = ["symbolize", "flamegraph"] }
 zstd-framed = { version = "0.1.1", features = ["tokio"] }
 
+
+rustls-pki-types = { version = "1.11.0", features = ["my_fork"] }
+#XXX: using 'my_fork' feature ensures the current crate uses the dep from the fork and allows that fork to control any extra features like tracing.
+#rustls-pki-types = { path= "/home/user/SOURCE/github/modified_forks/pki-types", features = ["trace_drop_and_zeroize"] } #don't use this path= way, because it compiles external client/server projects but they're incomplete, unless u add the patch section to them too.
+#and then in things like ./crates/standalone/Cargo.toml doing:
+#rustls-pki-types.workspace=true
+#will make any dep's use of this pki-types crate enable this 'trace_drop_and_zeroize' feature,
+#so it's like it's enabled globally for all Cargo.toml(s) that use this workspace's pki-types (as shown 2 lines above).
+#but this also requires the [patch.crates-io] section below in-here! because only that modded fork of pki-types has that exact trace_drop_and_zeroize feature.
+#sample output after this is done:
+#$ cargo tree -f "{p} {f}" | grep pki-types
+#│   │   └── rustls-pki-types v1.11.0 (/home/user/SOURCE/github/modified_forks/pki-types) alloc,default,std,trace_drop_and_zeroize
+#    │   ├── axum-server v0.7.2 arc-swap,default,rustls,rustls-pemfile,rustls-pki-types,tls-rustls,tls-rustls-no-provider,tokio-rustls
+#    │   │   │   ├── rustls-pki-types v1.11.0 (/home/user/SOURCE/github/modified_forks/pki-types) alloc,default,std,trace_drop_and_zeroize (*)
+#    │   │   │   │   ├── rustls-pki-types v1.11.0 (/home/user/SOURCE/github/modified_forks/pki-types) alloc,default,std,trace_drop_and_zeroize (*)
+#    │   │   ├── rustls-pki-types v1.11.0 (/home/user/SOURCE/github/modified_forks/pki-types) alloc,default,std,trace_drop_and_zeroize (*)
+#    │   │   │   ├── rustls-pki-types v1.11.0 (/home/user/SOURCE/github/modified_forks/pki-types) alloc,default,std,trace_drop_and_zeroize (*)
+#    │   │   └── rustls-pki-types v1.11.0 (/home/user/SOURCE/github/modified_forks/pki-types) alloc,default,std,trace_drop_and_zeroize (*)
+#    │   ├── rustls-pki-types v1.11.0 (/home/user/SOURCE/github/modified_forks/pki-types) alloc,default,std,trace_drop_and_zeroize (*)
+#
+
 # Vendor the openssl we rely on, rather than depend on a
 # potentially very old system version.
 openssl = { version = "0.10", features = ["vendored"] }
@@ -319,3 +353,81 @@ features = [
   "broadcast",
   "ondemand",
 ]
+
+#XXX: caveat: this patch section must exist in client/server external repos, even tho it works for those within this repo, in ./crates/sdk/... otherwise you'll get these errors:
+#/home/user/SOURCE/my/quickstart-chat/client
+#$ cargo build
+#    Updating crates.io index
+#error: failed to select a version for `rustls-pki-types`.
+#    ... required by package `spacetimedb-lib v1.1.1 (/home/user/SOURCE/SpacetimeDB/crates/lib)`
+#    ... which satisfies path dependency `spacetimedb-lib` (locked to 1.1.1) of package `spacetimedb-sdk v1.1.1 (/home/user/SOURCE/SpacetimeDB/crates/sdk)`
+#    ... which satisfies path dependency `spacetimedb-sdk` (locked to 1.1.1) of package `client v0.1.0 (/home/user/SOURCE/my/quickstart-chat/client)`
+#versions that meet the requirements `^1.11` are: 1.11.0
+#
+#the package `spacetimedb-lib` depends on `rustls-pki-types`, with features: `trace_drop_and_zeroize` but `rustls-pki-types` does not have these features.
+#
+#
+#failed to select a version for `rustls-pki-types` which could resolve this conflict
+#
+#"The core problem is that the [patch.crates-io] section in the SpacetimeDB workspace’s root Cargo.toml (at /home/user/SOURCE/SpacetimeDB/Cargo.toml) doesn’t apply to the quickstart-chat projects (server and client) because they are in a separate workspace or standalone Cargo.toml. This causes the rustls-pki-types dependency to resolve to the upstream v1.11.0, which lacks trace_drop_and_zeroize, resulting in the compile error(from above)"
+[patch.crates-io]
+#A version that has zeroize, because 1.12.0 or so, isn't yet released.
+#Patched to have zeroize() method but doesn't zeroize on drop(this isn't enough for our uses!):
+#rustls-pki-types = { git = "https://github.com/rustls/pki-types.git", rev = "b59e08d49911b10c423d25bd9040cfbe5a6042ff" }
+
+#Patched to zeroize on drop(good for us):
+rustls-pki-types = { path = "/home/user/SOURCE/github/modified_forks/pki-types" }
+#XXX: if you're not me, you'll want this instead (or clone this locally in a path and change the path above to reflect where u've cloned it):
+#rustls-pki-types = { git = "https://github.com/dare3path/pki-types", branch="zeroize_on_drop" }
+#^ it's indirectly used though.
+#Without this here in patch section(ie. in case i used path= directly in the [dependencies] section above, but none here(no patched crate mentioned here) in patch section), then not all deps will use it, like:
+#/home/user/SOURCE/SpacetimeDB
+#$ cargo tree|grep -i pki
+#│   │   └── rustls-pki-types v1.11.0
+#├── rustls-pki-types v1.11.0 (/home/user/SOURCE/github/modified_forks/pki-types)
+#│       ├── rustls-pki-types v1.11.0 (/home/user/SOURCE/github/modified_forks/pki-types) (*)
+#    │   │   │   ├── rustls-pki-types v1.11.0
+#    │   │   │   ├── rustls-webpki v0.103.1
+#    │   │   │   │   ├── rustls-pki-types v1.11.0
+#    │   │   ├── rustls-pki-types v1.11.0
+#    │   │   │   ├── rustls-pki-types v1.11.0
+#    │   │   └── rustls-pki-types v1.11.0
+#    │   ├── rustls-pki-types v1.11.0 (/home/user/SOURCE/github/modified_forks/pki-types) (*)
+#but with it, it's all:
+#$ cargo tree|grep -i pki
+#│   │   └── rustls-pki-types v1.11.0 (/home/user/SOURCE/github/modified_forks/pki-types)
+#├── rustls-pki-types v1.11.0 (/home/user/SOURCE/github/modified_forks/pki-types) (*)
+#│       ├── rustls-pki-types v1.11.0 (/home/user/SOURCE/github/modified_forks/pki-types) (*)
+#    │   │   │   ├── rustls-pki-types v1.11.0 (/home/user/SOURCE/github/modified_forks/pki-types) (*)
+#    │   │   │   ├── rustls-webpki v0.103.1
+#    │   │   │   │   ├── rustls-pki-types v1.11.0 (/home/user/SOURCE/github/modified_forks/pki-types) (*)
+#    │   │   ├── rustls-pki-types v1.11.0 (/home/user/SOURCE/github/modified_forks/pki-types) (*)
+#    │   │   │   ├── rustls-pki-types v1.11.0 (/home/user/SOURCE/github/modified_forks/pki-types) (*)
+#    │   │   └── rustls-pki-types v1.11.0 (/home/user/SOURCE/github/modified_forks/pki-types) (*)
+#    │   ├── rustls-pki-types v1.11.0 (/home/user/SOURCE/github/modified_forks/pki-types) (*)
+
+
+
+#XXX: can comment out this 'rustls' patch line, as it's not needed, even tho it's brought up to date with its modded deps(ring, rcgen)
+# a rustls that uses same pki-types patch.crates-io section from above and also enables pki-types' feature trace_drop_and_zeroize
+rustls = { path = "/home/user/SOURCE/github/modified_forks/rustls/rustls" }
+#XXX: if you're not me, you'll want this instead (or clone this locally in a path and change the path above to reflect where u've cloned it):
+#rustls = { git = "fixes_due_to_Drop_impls_in_dep_crates", branch="fixes_due_to_Drop_impls_in_dep_crates" }
+#so rustls's Cargo.toml is modded to look like this:
+## pki-types = { package = "rustls-pki-types", version = "1.11", features = ["alloc","trace_drop_and_zeroize"] }
+##...
+## ppatch.crates-io]
+## rustls-pki-types = { path = "/home/user/SOURCE/github/modified_forks/pki-types" } #patched with ./zeroize_on_drop.patch
+#this ^ (rustls hack) isn't needed if using the above inclusion of rustls-pki-types as dep here and .workspace=true in any Cargo.toml that has deps that use it.
+
+#patched to not obscure connection errors behind ChannelClosed:
+hyper-util = { path="/home/user/SOURCE/github/modified_forks/hyper-util" }
+#XXX: if you're not me, you'll want this instead (or clone this locally in a path and change the path above to reflect where u've cloned it):
+#hyper-util = { git="https://github.com/dare3path/hyper-util", branch="fix_ChannelClosed_race" }
+
+#The current branch(TLS+mTLS) which added these changes to spacetimedb is also available as patch in: https://github.com/dare3path/spacetimedb-tls-patch  and if you want to use quickstart-chat example (client+server) with it, you might want to look at repo: https://github.com/dare3path/quickstart-chat
+
+# patched to zeroize private keys on drop:
+ring = { path = "/home/user/SOURCE/github/modified_forks/ring" }
+#XXX: if you're not me, you'll want this instead (or clone this locally in a path and change the path above to reflect where u've cloned it):
+#ring = { git="https://github.com/dare3path/ring", branch="zeroize_on_drop" }
diff --git a/crates/cli/Cargo.toml b/crates/cli/Cargo.toml
index 6f9d29020..70346cd15 100644
--- a/crates/cli/Cargo.toml
+++ b/crates/cli/Cargo.toml
@@ -69,11 +69,20 @@ tokio.workspace = true
 tokio-tungstenite.workspace = true
 toml.workspace = true
 toml_edit.workspace = true
-tracing = { workspace = true, features = ["release_max_level_off"] }
+tracing = { workspace = true } #, features = ["release_max_level_off"] }
 walkdir.workspace = true
 wasmbin.workspace = true
 webbrowser.workspace = true
 clap-markdown.workspace = true
+#native-tls = "0.2"
+native-tls.workspace=true
+x509-parser.workspace=true
+sha2.workspace=true
+#hyper.workspace=true
+rustls-pemfile.workspace=true
+#This pki-types crate is actually a dep of pemfile above, but we want a feature enabled, so:
+rustls-pki-types.workspace=true #needed here, to enable its 'trace_drop_and_zeroize' feature
+zeroize.workspace=true
 
 [target.'cfg(not(target_env = "msvc"))'.dependencies]
 tikv-jemallocator = { workspace = true }
diff --git a/crates/cli/src/api.rs b/crates/cli/src/api.rs
index d40b03ee8..cce80b6cb 100644
--- a/crates/cli/src/api.rs
+++ b/crates/cli/src/api.rs
@@ -8,7 +8,11 @@ use spacetimedb_lib::db::raw_def::v9::RawModuleDefV9;
 use spacetimedb_lib::de::serde::DeserializeWrapper;
 use spacetimedb_lib::Identity;
 
-use crate::util::{AuthHeader, ResponseExt};
+use crate::util::{AuthHeader, ResponseExt,
+map_request_error // fn and macro
+};
+use crate::util;
+use std::path::PathBuf;
 
 static APP_USER_AGENT: &str = concat!(env!("CARGO_PKG_NAME"), "/", env!("CARGO_PKG_VERSION"),);
 
@@ -18,6 +22,11 @@ pub struct Connection {
     pub(crate) database_identity: Identity,
     pub(crate) database: String,
     pub(crate) auth_header: AuthHeader,
+    // FIXME: bad idea to put these next ones here? else pass'em as arg?
+    pub(crate) trust_server_cert_path: Option<PathBuf>,
+    pub(crate) client_cert_path: Option<PathBuf>,
+    pub(crate) client_key_path: Option<PathBuf>,
+    pub(crate) trust_system: bool,
 }
 
 impl Connection {
@@ -34,7 +43,22 @@ impl Connection {
 }
 
 pub fn build_client(con: &Connection) -> Client {
-    let mut builder = Client::builder().user_agent(APP_USER_AGENT);
+    let trust_server_cert_path=con.trust_server_cert_path.as_deref();
+    let client_cert_path=con.client_cert_path.as_deref();
+    let client_key_path=con.client_key_path.as_deref();
+    let trust_system=con.trust_system;
+    //XXX: alternatively make this async and then make new() async, and ensure callers do .await on it
+    let mut builder = tokio::task::block_in_place(|| {
+        tokio::runtime::Handle::current()
+            .block_on(util::configure_tls(
+                    trust_server_cert_path,
+                    client_cert_path,
+                    client_key_path,
+                    trust_system
+                    ))
+    })
+    .unwrap();
+    builder = builder.user_agent(APP_USER_AGENT);
 
     if let Some(auth_header) = con.auth_header.to_header() {
         let headers = http::HeaderMap::from_iter([(header::AUTHORIZATION, auth_header)]);
@@ -42,7 +66,15 @@ pub fn build_client(con: &Connection) -> Client {
         builder = builder.default_headers(headers);
     }
 
-    builder.build().unwrap()
+    map_request_error!(
+        util::build_client_with_context(builder,
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ), con.host, client_cert_path, client_key_path
+    )
+    .unwrap()
 }
 
 pub struct ClientApi {
diff --git a/crates/cli/src/common_args.rs b/crates/cli/src/common_args.rs
index a238ecbf0..4ff8d27d2 100644
--- a/crates/cli/src/common_args.rs
+++ b/crates/cli/src/common_args.rs
@@ -1,5 +1,6 @@
 use clap::Arg;
 use clap::ArgAction::SetTrue;
+pub use spacetimedb_lib::{no_trust_system_root_store, trust_system_root_store, trust_server_cert, client_key, client_cert};
 
 pub fn server() -> Arg {
     Arg::new("server")
diff --git a/crates/cli/src/config.rs b/crates/cli/src/config.rs
index 1e709b892..5bf0cf5ea 100644
--- a/crates/cli/src/config.rs
+++ b/crates/cli/src/config.rs
@@ -177,21 +177,59 @@ impl RawConfig {
     }
 
     fn find_server(&self, name_or_host: &str) -> anyhow::Result<&ServerConfig> {
+        self.find_server_with_protocol(name_or_host, None)
+    }
+    fn find_server_with_protocol(&self, name_or_host: &str, protocol: Option<&str>) -> anyhow::Result<&ServerConfig> {
+        let mut matches = Vec::new();
         for cfg in &self.server_configs {
-            if cfg.nickname.as_deref() == Some(name_or_host) || cfg.host == name_or_host {
-                return Ok(cfg);
+            if cfg.nickname.as_deref() == Some(name_or_host) {
+                return Ok(cfg); // Nickname is unique
+            }
+            if cfg.host == name_or_host && protocol.map_or(true, |p| cfg.protocol == p) {
+                matches.push(cfg);
             }
         }
-        Err(no_such_server_error(name_or_host))
+        match matches.len() {
+            0 => Err(no_such_server_error(name_or_host)),
+            1 => Ok(matches[0]),
+            _ => Err(anyhow::anyhow!(
+                    "Ambiguous server: {} matches multiple protocols (e.g., {}://{}, {}://{}). Specify nickname or protocol.",
+                    name_or_host,
+                    matches[0].protocol,
+                    name_or_host,
+                    matches[1].protocol,
+                    name_or_host
+            )),
+        }
     }
 
-    fn find_server_mut(&mut self, name_or_host: &str) -> anyhow::Result<&mut ServerConfig> {
-        for cfg in &mut self.server_configs {
-            if cfg.nickname.as_deref() == Some(name_or_host) || cfg.host == name_or_host {
-                return Ok(cfg);
+    fn find_server_with_protocol_mut(&mut self, name_or_host: &str, protocol: Option<&str>) -> anyhow::Result<&mut ServerConfig> {
+        let mut indices = Vec::new();
+        let mut protocols = Vec::new();
+        for (i, cfg) in self.server_configs.iter().enumerate() {
+            if cfg.nickname.as_deref() == Some(name_or_host) {
+                return Ok(&mut self.server_configs[i]);
             }
+            if cfg.host == name_or_host && protocol.map_or(true, |p| cfg.protocol == p) {
+                indices.push(i);
+                protocols.push(&cfg.protocol);
+            }
+        }
+        match indices.len() {
+            0 => Err(no_such_server_error(name_or_host)),
+            1 => Ok(&mut self.server_configs[indices[0]]),
+            _ => Err(anyhow::anyhow!(
+                    "Ambiguous server: {} matches multiple protocols (e.g., {}://{}, {}://{}). Specify nickname or protocol.",
+                    name_or_host,
+                    protocols[0],
+                    name_or_host,
+                    protocols[1],
+                    name_or_host
+            )),
         }
-        Err(no_such_server_error(name_or_host))
+    }
+    fn find_server_mut(&mut self, name_or_host: &str) -> anyhow::Result<&mut ServerConfig> {
+        self.find_server_with_protocol_mut(name_or_host, None)
     }
 
     fn default_server(&self) -> anyhow::Result<&ServerConfig> {
@@ -231,13 +269,10 @@ impl RawConfig {
             }
         }
 
-        if let Ok(cfg) = self.find_server(&host) {
-            if let Some(nick) = &cfg.nickname {
-                if nick == &host {
-                    anyhow::bail!("Server host name is ambiguous with existing server nickname: {}", nick);
-                }
-            }
-            anyhow::bail!("Server already configured for host: {}", host);
+        if self.server_configs.iter().any(|cfg| {
+            cfg.host == host && cfg.protocol == protocol
+        }) {
+            anyhow::bail!("Server already configured for host: {}, proto: {}", host, protocol);
         }
 
         self.server_configs.push(ServerConfig {
@@ -271,47 +306,68 @@ impl RawConfig {
             .map(|cfg| cfg.protocol.as_ref())
     }
 
-    fn set_default_server(&mut self, server: &str) -> anyhow::Result<()> {
+    fn set_default_server(&mut self, server: &str, protocol: Option<&str>) -> anyhow::Result<()> {
         // Check that such a server exists before setting the default.
-        self.find_server(server)
-            .with_context(|| format!("Cannot set default server to unknown server {server}"))?;
+        let cfg = self
+            .find_server_with_protocol(server, protocol)
+            .with_context(|| {
+                if let Some(p) = protocol {
+                    format!("Cannot set default server to unknown server {} with protocol {}", server, p)
+                } else {
+                    format!("Cannot set default server to unknown server {}", server)
+                }
+            })?;
 
-        self.default_server = Some(server.to_string());
+        // Prefer nickname if available, else use host
+        self.default_server = Some(cfg.nickname.clone().unwrap_or_else(|| cfg.host.clone()));
 
         Ok(())
     }
 
     /// Implements `spacetime server remove`.
-    fn remove_server(&mut self, server: &str) -> anyhow::Result<()> {
-        // Have to find the server config manually instead of doing `find_server_mut`
-        // because we need to mutably borrow multiple components of `self`.
-        if let Some(idx) = self
-            .server_configs
-            .iter()
-            .position(|cfg| cfg.nick_or_host_or_url_is(server))
-        {
-            // Actually remove the config.
-            let cfg = self.server_configs.remove(idx);
-
-            // If we're removing the default server,
-            // unset the default server.
-            if let Some(default_server) = &self.default_server {
-                if cfg.nick_or_host_or_url_is(default_server) {
-                    self.default_server = None;
-                }
+    fn remove_server(&mut self, server: &str, protocol: Option<&str>) -> anyhow::Result<()> {
+        let mut indices = Vec::new();
+        let mut protocols = Vec::new();
+        for (i, cfg) in self.server_configs.iter().enumerate() {
+            if cfg.nickname.as_deref() == Some(server) {
+                indices = vec![i];
+                protocols = vec![&cfg.protocol];
+                break; // Nickname is unique
+            }
+            if cfg.host == server && protocol.map_or(true, |p| cfg.protocol == p) {
+                indices.push(i);
+                protocols.push(&cfg.protocol);
             }
+        }
 
-            return Ok(());
+        match indices.len() {
+            0 => Err(no_such_server_error(server)),
+            1 => {
+                let cfg = self.server_configs.remove(indices[0]);
+                if let Some(default_server) = &self.default_server {
+                    if cfg.nickname.as_deref() == Some(default_server) || cfg.host == *default_server {
+                        self.default_server = None;
+                    }
+                }
+                Ok(())
+            }
+            _ => Err(anyhow::anyhow!(
+                    "Ambiguous server: {} matches multiple protocols (e.g., {}://{}, {}://{}). Specify nickname or protocol.",
+                    server,
+                    protocols[0],
+                    server,
+                    protocols[1],
+                    server
+            )),
         }
-        Err(no_such_server_error(server))
     }
 
     /// Return the ECDSA public key in PEM format for the server named by `server`.
     ///
     /// Returns an `Err` if there is no such server configuration.
     /// Returns `None` if the server configuration exists, but does not have a fingerprint saved.
-    fn server_fingerprint(&self, server: &str) -> anyhow::Result<Option<&str>> {
-        self.find_server(server)
+    fn server_fingerprint(&self, server: &str, protocol: Option<&str>) -> anyhow::Result<Option<&str>> {
+        self.find_server_with_protocol(server, protocol)
             .with_context(|| {
                 format!(
                     "No saved fingerprint for server: {server}
@@ -319,7 +375,7 @@ Fetch the server's fingerprint with:
 \tspacetime server fingerprint -s {server}"
                 )
             })
-            .map(|cfg| cfg.ecdsa_public_key.as_deref())
+        .map(|cfg| cfg.ecdsa_public_key.as_deref())
     }
 
     /// Return the ECDSA public key in PEM format for the default server.
@@ -328,7 +384,7 @@ Fetch the server's fingerprint with:
     /// Returns `None` if the server configuration exists, but does not have a fingerprint saved.
     fn default_server_fingerprint(&self) -> anyhow::Result<Option<&str>> {
         if let Some(server) = &self.default_server {
-            self.server_fingerprint(server)
+            self.server_fingerprint(server, None)
         } else {
             Err(anyhow::anyhow!(NO_DEFAULT_SERVER_ERROR_MESSAGE))
         }
@@ -364,6 +420,7 @@ Fetch the server's fingerprint with:
     pub fn edit_server(
         &mut self,
         server: &str,
+        old_protocol: Option<&str>,
         new_nickname: Option<&str>,
         new_host: Option<&str>,
         new_protocol: Option<&str>,
@@ -371,7 +428,7 @@ Fetch the server's fingerprint with:
         // Check if the new nickname or host name would introduce ambiguities between
         // server configurations.
         if let Some(new_nick) = new_nickname {
-            if let Ok(other_server) = self.find_server(new_nick) {
+            if let Ok(other_server) = self.find_server_with_protocol(new_nick, None) {
                 anyhow::bail!(
                     "Nickname {} conflicts with saved configuration for server {}: {}://{}",
                     new_nick,
@@ -382,7 +439,7 @@ Fetch the server's fingerprint with:
             }
         }
         if let Some(new_host) = new_host {
-            if let Ok(other_server) = self.find_server(new_host) {
+            if let Ok(other_server) = self.find_server_with_protocol(new_host, new_protocol) {
                 anyhow::bail!(
                     "Host {} conflicts with saved configuration for server {}: {}://{}",
                     new_host,
@@ -393,7 +450,7 @@ Fetch the server's fingerprint with:
             }
         }
 
-        let cfg = self.find_server_mut(server)?;
+        let cfg = self.find_server_with_protocol_mut(server, old_protocol)?;
         let old_nickname = if let Some(new_nickname) = new_nickname {
             std::mem::replace(&mut cfg.nickname, Some(new_nickname.to_string()))
         } else {
@@ -509,8 +566,8 @@ impl Config {
     /// Callers should call `Config::save` afterwards
     /// to ensure modifications are persisted to disk.
     pub fn set_default_server(&mut self, nickname_or_host_or_url: &str) -> anyhow::Result<()> {
-        let (host, _) = host_or_url_to_host_and_protocol(nickname_or_host_or_url);
-        self.home.set_default_server(host)
+        let (host, proto) = host_or_url_to_host_and_protocol(nickname_or_host_or_url);
+        self.home.set_default_server(host, proto)
     }
 
     /// Delete a `ServerConfig` from the home configuration.
@@ -522,8 +579,8 @@ impl Config {
     /// Callers should call `Config::save` afterwards
     /// to ensure modifications are persisted to disk.
     pub fn remove_server(&mut self, nickname_or_host_or_url: &str) -> anyhow::Result<()> {
-        let (host, _) = host_or_url_to_host_and_protocol(nickname_or_host_or_url);
-        self.home.remove_server(host)
+        let (host, proto) = host_or_url_to_host_and_protocol(nickname_or_host_or_url);
+        self.home.remove_server(host, proto)
     }
 
     /// Get a URL for the specified `server`.
@@ -734,7 +791,7 @@ impl Config {
     }
 
     pub fn server_decoding_key(&self, server: Option<&str>) -> anyhow::Result<DecodingKey> {
-        self.server_fingerprint(server).and_then(|fing| {
+        self.server_fingerprint(server, None).and_then(|fing| {
             if let Some(fing) = fing {
                 DecodingKey::from_ec_pem(fing.as_bytes()).with_context(|| {
                     format!(
@@ -762,10 +819,11 @@ Update the server's fingerprint with:
         }
     }
 
-    pub fn server_fingerprint(&self, server: Option<&str>) -> anyhow::Result<Option<&str>> {
+    pub fn server_fingerprint(&self, server: Option<&str>, protocol: Option<&str>) -> anyhow::Result<Option<&str>> {
         if let Some(server) = server {
-            let (host, _) = host_or_url_to_host_and_protocol(server);
-            self.home.server_fingerprint(host)
+            let (host, _proto) = host_or_url_to_host_and_protocol(server);
+            //FIXME: if _proto exists and one was specified as arg too... or if None as arg, take _proto?
+            self.home.server_fingerprint(host, protocol)
         } else {
             self.home.default_server_fingerprint()
         }
@@ -787,8 +845,8 @@ Update the server's fingerprint with:
         new_host: Option<&str>,
         new_protocol: Option<&str>,
     ) -> anyhow::Result<(Option<String>, Option<String>, Option<String>)> {
-        let (host, _) = host_or_url_to_host_and_protocol(server);
-        self.home.edit_server(host, new_nickname, new_host, new_protocol)
+        let (host, oldproto) = host_or_url_to_host_and_protocol(server);
+        self.home.edit_server(host, oldproto, new_nickname, new_host, new_protocol)
     }
 
     pub fn delete_server_fingerprint(&mut self, server: Option<&str>) -> anyhow::Result<()> {
diff --git a/crates/cli/src/subcommands/call.rs b/crates/cli/src/subcommands/call.rs
index c32a3944c..a142056e9 100644
--- a/crates/cli/src/subcommands/call.rs
+++ b/crates/cli/src/subcommands/call.rs
@@ -11,6 +11,7 @@ use spacetimedb_lib::sats::{self, AlgebraicType, Typespace};
 use spacetimedb_lib::{Identity, ProductTypeElement};
 use spacetimedb_schema::def::{ModuleDef, ReducerDef};
 use std::fmt::Write;
+use std::path::{Path, PathBuf};
 
 use super::sql::parse_req;
 
@@ -30,6 +31,14 @@ pub fn cli() -> clap::Command {
                 .required(true)
                 .help("The name of the reducer to call"),
         )
+        //.arg(common_args::cert())
+
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
+
         .arg(Arg::new("arguments").help("arguments formatted as JSON").num_args(1..))
         .arg(common_args::server().help("The nickname, host name or URL of the server hosting the database"))
         .arg(common_args::anonymous())
@@ -42,7 +51,22 @@ pub async fn exec(config: Config, args: &ArgMatches) -> Result<(), Error> {
     let reducer_name = args.get_one::<String>("reducer_name").unwrap();
     let arguments = args.get_many::<String>("arguments");
 
-    let conn = parse_req(config, args).await?;
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+    let conn = parse_req(config, args,
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+    ).await?;
     let api = ClientApi::new(conn);
 
     let database_identity = api.con.database_identity;
diff --git a/crates/cli/src/subcommands/delete.rs b/crates/cli/src/subcommands/delete.rs
index e0d5c7561..3a5f7ecbd 100644
--- a/crates/cli/src/subcommands/delete.rs
+++ b/crates/cli/src/subcommands/delete.rs
@@ -1,7 +1,8 @@
 use crate::common_args;
 use crate::config::Config;
-use crate::util::{add_auth_header_opt, database_identity, get_auth_header};
+use crate::util::{add_auth_header_opt, database_identity, get_auth_header, build_client, map_request_error};
 use clap::{Arg, ArgMatches};
+use std::path::{Path, PathBuf};
 
 pub fn cli() -> clap::Command {
     clap::Command::new("delete")
@@ -13,17 +14,48 @@ pub fn cli() -> clap::Command {
         )
         .arg(common_args::server().help("The nickname, host name or URL of the server hosting the database"))
         .arg(common_args::yes())
+
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
         .after_help("Run `spacetime help delete` for more detailed information.\n")
 }
 
+
+
 pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::Error> {
     let server = args.get_one::<String>("server").map(|s| s.as_ref());
     let database = args.get_one::<String>("database").unwrap();
     let force = args.get_flag("force");
 
-    let identity = database_identity(&config, database, server).await?;
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+    let host = config.get_host_url(server)?;
+    let client = map_request_error!(
+        build_client(
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ).await
+        ,host, client_cert_path, client_key_path)
+        ?;
+    let identity = map_request_error!(
+        database_identity(&config, database, server, &client).await
+        ,host, client_cert_path, client_key_path)
+        ?;
 
-    let builder = reqwest::Client::new().delete(format!("{}/v1/database/{}", config.get_host_url(server)?, identity));
+    let builder = client.delete(format!("{}/v1/database/{}", host, identity));
     let auth_header = get_auth_header(&mut config, false, server, !force).await?;
     let builder = add_auth_header_opt(builder, &auth_header);
     builder.send().await?.error_for_status()?;
diff --git a/crates/cli/src/subcommands/describe.rs b/crates/cli/src/subcommands/describe.rs
index 6f1759ff7..2fbcf5acd 100644
--- a/crates/cli/src/subcommands/describe.rs
+++ b/crates/cli/src/subcommands/describe.rs
@@ -6,6 +6,7 @@ use crate::util::UNSTABLE_WARNING;
 use anyhow::Context;
 use clap::{Arg, ArgAction, ArgMatches};
 use spacetimedb_lib::sats;
+use std::path::{Path, PathBuf};
 
 pub fn cli() -> clap::Command {
     clap::Command::new("describe")
@@ -40,6 +41,12 @@ pub fn cli() -> clap::Command {
                      give human-readable output.",
                 ),
         )
+        //.arg(common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
         .arg(common_args::anonymous())
         .arg(common_args::server().help("The nickname, host name or URL of the server hosting the database"))
         .arg(common_args::yes())
@@ -59,8 +66,23 @@ pub async fn exec(config: Config, args: &ArgMatches) -> Result<(), anyhow::Error
     let entity_type = args.get_one::<EntityType>("entity_type");
     let entity = entity_type.zip(entity_name);
     let json = args.get_flag("json");
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
 
-    let conn = parse_req(config, args).await?;
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+
+    let conn = parse_req(config, args,
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+        ).await?;
     let api = ClientApi::new(conn);
 
     let module_def = api.module_def().await?;
diff --git a/crates/cli/src/subcommands/dns.rs b/crates/cli/src/subcommands/dns.rs
index 03f4e96b3..8ea0b86ad 100644
--- a/crates/cli/src/subcommands/dns.rs
+++ b/crates/cli/src/subcommands/dns.rs
@@ -1,8 +1,9 @@
 use crate::common_args;
 use crate::config::Config;
-use crate::util::{add_auth_header_opt, decode_identity, get_auth_header, get_login_token_or_log_in, ResponseExt};
+use crate::util::{add_auth_header_opt, decode_identity, get_auth_header, get_login_token_or_log_in, ResponseExt, build_client, map_request_error};
 use clap::ArgMatches;
 use clap::{Arg, Command};
+use std::path::{Path, PathBuf};
 
 use spacetimedb_client_api_messages::name::{DomainName, InsertDomainResult};
 
@@ -20,6 +21,12 @@ pub fn cli() -> Command {
                 .required(true)
                 .help("The database identity to rename"),
         )
+        //.arg(common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
         .arg(common_args::server().help("The nickname, host name or URL of the server on which to set the name"))
         .arg(common_args::yes())
         .after_help("Run `spacetime rename --help` for more detailed information.\n")
@@ -33,18 +40,40 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     let token = get_login_token_or_log_in(&mut config, server, !force).await?;
     let identity = decode_identity(&token)?;
     let auth_header = get_auth_header(&mut config, false, server, !force).await?;
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
 
     let domain: DomainName = domain.parse()?;
 
-    let builder = reqwest::Client::new()
+    let host = config.get_host_url(server)?;
+    let client = map_request_error!(
+        build_client(
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ).await
+        , host, client_cert_path, client_key_path)
+        ?;
+    let builder = client
         .post(format!(
             "{}/v1/database/{database_identity}/names",
-            config.get_host_url(server)?
+            host
         ))
         .body(String::from(domain));
     let builder = add_auth_header_opt(builder, &auth_header);
 
-    let result = builder.send().await?.json_or_error().await?;
+    let result = map_request_error!(
+        builder.send().await
+        , host, client_cert_path, client_key_path)
+    ?.json_or_error().await?;
     match result {
         InsertDomainResult::Success {
             domain,
diff --git a/crates/cli/src/subcommands/energy.rs b/crates/cli/src/subcommands/energy.rs
index 0d4249e23..247919cec 100644
--- a/crates/cli/src/subcommands/energy.rs
+++ b/crates/cli/src/subcommands/energy.rs
@@ -3,7 +3,8 @@ use crate::common_args;
 use clap::ArgMatches;
 
 use crate::config::Config;
-use crate::util::{self, get_login_token_or_log_in, UNSTABLE_WARNING};
+use crate::util::{self, get_login_token_or_log_in, UNSTABLE_WARNING, build_client, map_request_error};
+use std::path::{Path, PathBuf};
 
 pub fn cli() -> clap::Command {
     clap::Command::new("energy")
@@ -30,6 +31,12 @@ fn get_energy_subcommands() -> Vec<clap::Command> {
             common_args::server()
                 .help("The nickname, host name or URL of the server from which to request balance information"),
         )
+        //.arg(common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
         .arg(common_args::yes())]
 }
 
@@ -58,11 +65,35 @@ async fn exec_status(mut config: Config, args: &ArgMatches) -> Result<(), anyhow
         let token = get_login_token_or_log_in(&mut config, server, !force).await?;
         util::decode_identity(&token)?
     };
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
 
-    let status = reqwest::Client::new()
-        .get(format!("{}/v1/energy/{}", config.get_host_url(server)?, identity))
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+    let host = config.get_host_url(server)?;
+
+    let client = map_request_error!(
+        build_client(
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ).await
+        ,host, client_cert_path, client_key_path)
+        ?;
+
+    let status = map_request_error!(
+        client
+        .get(format!("{}/v1/energy/{}", host, identity))
         .send()
-        .await?
+        .await
+        ,host, client_cert_path, client_key_path)
+        ?
         .error_for_status()?
         .text()
         .await?;
diff --git a/crates/cli/src/subcommands/list.rs b/crates/cli/src/subcommands/list.rs
index 8080af3c7..be1ec8178 100644
--- a/crates/cli/src/subcommands/list.rs
+++ b/crates/cli/src/subcommands/list.rs
@@ -3,6 +3,7 @@ use crate::util;
 use crate::util::get_login_token_or_log_in;
 use crate::util::ResponseExt;
 use crate::util::UNSTABLE_WARNING;
+use crate::util::map_request_error;
 use crate::Config;
 use anyhow::Context;
 use clap::{ArgMatches, Command};
@@ -12,6 +13,7 @@ use tabled::{
     settings::{object::Columns, Alignment, Modify, Style},
     Table, Tabled,
 };
+use std::path::{Path, PathBuf};
 
 pub fn cli() -> Command {
     Command::new("list")
@@ -19,6 +21,12 @@ pub fn cli() -> Command {
             "Lists the databases attached to an identity. {}",
             UNSTABLE_WARNING
         ))
+        //.arg(common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
         .arg(common_args::server().help("The nickname, host name or URL of the server from which to list databases"))
         .arg(common_args::yes())
 }
@@ -42,16 +50,38 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     let token = get_login_token_or_log_in(&mut config, server, !force).await?;
     let identity = util::decode_identity(&token)?;
 
-    let client = reqwest::Client::new();
-    let res = client
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+    let host = config.get_host_url(server)?;
+    let client = map_request_error!(
+        util::build_client(
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ).await
+        , host, client_cert_path, client_key_path)
+        ?;
+    let res = map_request_error!(
+        client
         .get(format!(
-            "{}/v1/identity/{}/databases",
-            config.get_host_url(server)?,
-            identity
+                "{}/v1/identity/{}/databases",
+                host,
+                identity
         ))
         .bearer_auth(token)
         .send()
-        .await?;
+        .await
+        , host, client_cert_path, client_key_path) 
+        ?;
 
     let result: DatabasesResult = res
         .json_or_error()
diff --git a/crates/cli/src/subcommands/login.rs b/crates/cli/src/subcommands/login.rs
index 8e2568b47..5eafa596d 100644
--- a/crates/cli/src/subcommands/login.rs
+++ b/crates/cli/src/subcommands/login.rs
@@ -1,9 +1,11 @@
-use crate::util::decode_identity;
+use crate::util::{decode_identity, build_client, map_request_error};
 use crate::Config;
 use clap::{Arg, ArgAction, ArgGroup, ArgMatches, Command};
 use reqwest::Url;
 use serde::Deserialize;
 use webbrowser;
+use crate::common_args;
+use std::path::{Path, PathBuf};
 
 pub const DEFAULT_AUTH_HOST: &str = "https://spacetimedb.com";
 
@@ -31,6 +33,12 @@ pub fn cli() -> Command {
                 .group("login-method")
                 .help("Bypass the login flow and use a login token directly"),
         )
+        //.arg(crate::common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
         .about("Manage your login to the SpacetimeDB CLI")
 }
 
@@ -52,8 +60,26 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
 
     let spacetimedb_token: Option<&String> = args.get_one("spacetimedb-token");
     let host: &String = args.get_one("auth-host").unwrap();
-    let host = Url::parse(host)?;
+    let mut host = Url::parse(host)?;
+    // XXX: specifying an url for the server below, instead of an existing nickname, will cause 'login' to
+    // succeed but you might wrongly assume like I did in https://github.com/clockworklabs/SpacetimeDB/issues/2512
+    // that any subsequent commands like `spacetime publish` will use that server that you specified
+    // but instead they won't, they'll use a default 127.0.0.1:3000(http) server instead
+    // because the url you used to login isn't saved in ~/.config/spacetime/cli.toml
+    // only the (login)spacetimedb_token is, and to select a default or add a new server
+    // to the list you've to use `spacetime server help`
+    // so let's warn, but allow this behavior.
     let server_issued_login: Option<&String> = args.get_one("server");
+//    if let Some(server) = server_issued_login {
+//    }//if
+    let sil:bool=
+    if let Some(server) = server_issued_login {
+        host = Url::parse(&config.get_host_url(Some(server))?)?;
+        eprintln!("WARNING: the server that you specified here as '{}'(aka {}) isn't the one that will be used by commands like 'spacetime publish' but instead it's the one listed on 'spacetime server list' as the default (3 stars) that will be used, eg. 127.0.0.1:3000 if you haven't manually added any via 'spacetime server add'.\n",server, host);//extra new line
+        true
+    } else {
+        false
+    };
 
     if let Some(token) = spacetimedb_token {
         config.set_spacetimedb_token(token.clone());
@@ -61,12 +87,25 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
         return Ok(());
     }
 
-    if let Some(server) = server_issued_login {
-        let host = Url::parse(&config.get_host_url(Some(server))?)?;
-        spacetimedb_token_cached(&mut config, &host, true).await?;
-    } else {
-        spacetimedb_token_cached(&mut config, &host, false).await?;
-    }
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+    map_request_error!(
+        spacetimedb_token_cached(&mut config, &host, sil,
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ).await
+        , host.to_string(), client_cert_path, client_key_path)
+        ?;
 
     Ok(())
 }
@@ -98,7 +137,12 @@ async fn exec_show(config: Config, args: &ArgMatches) -> Result<(), anyhow::Erro
     Ok(())
 }
 
-async fn spacetimedb_token_cached(config: &mut Config, host: &Url, direct_login: bool) -> anyhow::Result<String> {
+async fn spacetimedb_token_cached(config: &mut Config, host: &Url, direct_login: bool,
+    trust_server_cert_path: Option<&Path>,
+    client_cert_path: Option<&Path>,
+    client_key_path: Option<&Path>,
+    trust_system: bool,
+    ) -> anyhow::Result<String> {
     // Currently, this token does not expire. However, it will at some point in the future. When that happens,
     // this code will need to happen before any request to a spacetimedb server, rather than at the end of the login flow here.
     if let Some(token) = config.spacetimedb_token() {
@@ -106,17 +150,34 @@ async fn spacetimedb_token_cached(config: &mut Config, host: &Url, direct_login:
         println!("If you want to log out, use spacetime logout.");
         Ok(token.clone())
     } else {
-        spacetimedb_login_force(config, host, direct_login).await
+        spacetimedb_login_force(config, host, direct_login,
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ).await
     }
 }
 
-pub async fn spacetimedb_login_force(config: &mut Config, host: &Url, direct_login: bool) -> anyhow::Result<String> {
+pub async fn spacetimedb_login_force(config: &mut Config, host: &Url, direct_login: bool,
+    trust_server_cert_path: Option<&Path>,
+    client_cert_path: Option<&Path>,
+    client_key_path: Option<&Path>,
+    trust_system: bool,
+) -> anyhow::Result<String> {
     let token = if direct_login {
-        let token = spacetimedb_direct_login(host).await?;
+        println!("We will log in directly to your target server.");
+        let token = spacetimedb_direct_login(host,
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ).await?;
         println!("We have logged in directly to your target server.");
         println!("WARNING: This login will NOT work for any other servers.");
         token
     } else {
+        println!("We will log in NON-directly to your target server.");
         let session_token = web_login_cached(config, host).await?;
         spacetimedb_login(host, &session_token).await?
     };
@@ -271,8 +332,19 @@ struct LocalLoginResponse {
     pub token: String,
 }
 
-async fn spacetimedb_direct_login(host: &Url) -> Result<String, anyhow::Error> {
-    let client = reqwest::Client::new();
+async fn spacetimedb_direct_login(host: &Url,
+    trust_server_cert_path: Option<&Path>,
+    client_cert_path: Option<&Path>,
+    client_key_path: Option<&Path>,
+    trust_system: bool,
+) -> Result<String, anyhow::Error> {
+    let client = build_client(
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+    ).await?;
+
     let response: LocalLoginResponse = client
         .post(host.join("/v1/identity")?)
         .send()
diff --git a/crates/cli/src/subcommands/logs.rs b/crates/cli/src/subcommands/logs.rs
index c92a6f01c..5642675c7 100644
--- a/crates/cli/src/subcommands/logs.rs
+++ b/crates/cli/src/subcommands/logs.rs
@@ -3,12 +3,13 @@ use std::io::{self, Write};
 
 use crate::common_args;
 use crate::config::Config;
-use crate::util::{add_auth_header_opt, database_identity, get_auth_header};
+use crate::util::{add_auth_header_opt, database_identity, get_auth_header, build_client, map_request_error};
 use clap::{Arg, ArgAction, ArgMatches};
 use futures::{AsyncBufReadExt, TryStreamExt};
 use is_terminal::IsTerminal;
 use termcolor::{Color, ColorSpec, WriteColor};
 use tokio::io::AsyncWriteExt;
+use std::path::{Path, PathBuf};
 
 pub fn cli() -> clap::Command {
     clap::Command::new("logs")
@@ -48,6 +49,12 @@ pub fn cli() -> clap::Command {
                 .help("Output format for the logs")
         )
         .arg(common_args::yes())
+        //.arg(common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
         .after_help("Run `spacetime help logs` for more detailed information.\n")
 }
 
@@ -120,7 +127,31 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
 
     let auth_header = get_auth_header(&mut config, false, server, !force).await?;
 
-    let database_identity = database_identity(&config, database, server).await?;
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+    let host_url = config.get_host_url(server)?;
+
+    let client = map_request_error!(
+        build_client(
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ).await
+        , host_url, client_cert_path, client_key_path)
+        ?;
+    let database_identity = map_request_error!(
+        database_identity(&config, database, server, &client).await
+        , host_url, client_cert_path, client_key_path)
+        ?;
 
     if follow && num_lines.is_none() {
         // We typically don't want logs from the very beginning if we're also following.
@@ -128,9 +159,8 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     }
     let query_parms = LogsParams { num_lines, follow };
 
-    let host_url = config.get_host_url(server)?;
 
-    let builder = reqwest::Client::new().get(format!("{}/v1/database/{}/logs", host_url, database_identity));
+    let builder = client.get(format!("{}/v1/database/{}/logs", host_url, database_identity));
     let builder = add_auth_header_opt(builder, &auth_header);
     let mut res = builder.query(&query_parms).send().await?;
     let status = res.status();
diff --git a/crates/cli/src/subcommands/publish.rs b/crates/cli/src/subcommands/publish.rs
index 65cdf343c..473cfcd45 100644
--- a/crates/cli/src/subcommands/publish.rs
+++ b/crates/cli/src/subcommands/publish.rs
@@ -5,11 +5,11 @@ use reqwest::{StatusCode, Url};
 use spacetimedb_client_api_messages::name::PublishOp;
 use spacetimedb_client_api_messages::name::{is_identity, parse_database_name, PublishResult};
 use std::fs;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use crate::config::Config;
 use crate::util::{add_auth_header_opt, get_auth_header, ResponseExt};
-use crate::util::{decode_identity, unauth_error_context, y_or_n};
+use crate::util::{decode_identity, unauth_error_context, y_or_n, build_client, map_request_error};
 use crate::{build, common_args};
 
 pub fn cli() -> clap::Command {
@@ -63,6 +63,12 @@ i.e. only lowercase ASCII letters and numbers, separated by dashes."),
         .arg(common_args::server()
                 .help("The nickname, domain name or URL of the server to host the database."),
         )
+//        .arg(common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
         .arg(
             common_args::yes()
         )
@@ -79,6 +85,17 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     let wasm_file = args.get_one::<PathBuf>("wasm_file");
     let database_host = config.get_host_url(server)?;
     let build_options = args.get_one::<String>("build_options").unwrap();
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+
 
     // If the user didn't specify an identity and we didn't specify an anonymous identity, then
     // we want to use the default identity
@@ -86,7 +103,15 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     //  easily create a new identity with an email
     let auth_header = get_auth_header(&mut config, anon_identity, server, !force).await?;
 
-    let client = reqwest::Client::new();
+    let client = map_request_error!(
+        build_client(
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ).await
+        , database_host, client_cert_path, client_key_path)
+        ?;
 
     // If a domain or identity was provided, we should locally make sure it looks correct and
     let mut builder = if let Some(name_or_identity) = name_or_identity {
@@ -119,7 +144,16 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
         let url = Url::parse(&database_host)?;
         url.host_str().unwrap_or("<default>").to_string()
     };
-    if server_address != "localhost" && server_address != "127.0.0.1" {
+
+    use std::net::IpAddr;
+    fn is_local_address(address: &str) -> bool {
+        if let Ok(IpAddr::V4(ipv4)) = address.parse::<IpAddr>() {
+            ipv4.is_loopback() // true if this is `127.0.0.0/8`
+        } else {
+            address.eq_ignore_ascii_case("localhost")
+        }
+    }
+    if !is_local_address(&server_address) {
         println!("You are about to publish to a non-local server: {}", server_address);
         if !y_or_n(force, "Are you sure you want to proceed?")? {
             println!("Aborting");
@@ -157,7 +191,10 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
 
     builder = add_auth_header_opt(builder, &auth_header);
 
-    let res = builder.body(program_bytes).send().await?;
+    let res = map_request_error!(
+        builder.body(program_bytes).send().await
+        , database_host, client_cert_path, client_key_path)
+        ?;
     if res.status() == StatusCode::UNAUTHORIZED && !anon_identity {
         // If we're not in the `anon_identity` case, then we have already forced the user to log in above (using `get_auth_header`), so this should be safe to unwrap.
         let token = config.spacetimedb_token().unwrap();
diff --git a/crates/cli/src/subcommands/server.rs b/crates/cli/src/subcommands/server.rs
index 611919a63..a3586fd85 100644
--- a/crates/cli/src/subcommands/server.rs
+++ b/crates/cli/src/subcommands/server.rs
@@ -1,6 +1,11 @@
+//use spacetimedb_lib::map_request_error;//this must be at crate level! else func call within macro will fail at compile time.
+//use crate::util::map_request_error;// it's a reimport of spacetimedb_lib::map_request_error
+
 use crate::{
     common_args,
-    util::{host_or_url_to_host_and_protocol, spacetime_server_fingerprint, y_or_n, UNSTABLE_WARNING, VALID_PROTOCOLS},
+    util::{host_or_url_to_host_and_protocol, spacetime_server_fingerprint, y_or_n, UNSTABLE_WARNING, VALID_PROTOCOLS, build_client,
+    map_request_error, // this is macro & fn both
+    },
     Config,
 };
 use anyhow::Context;
@@ -10,6 +15,7 @@ use tabled::{
     settings::{object::Columns, Alignment, Modify, Style},
     Table, Tabled,
 };
+use std::path::{Path, PathBuf};
 
 pub fn cli() -> Command {
     Command::new("server")
@@ -53,8 +59,13 @@ fn get_subcommands() -> Vec<Command> {
                     .help("Skip fingerprinting the server")
                     .long("no-fingerprint")
                     .action(ArgAction::SetTrue),
-            ),
-        Command::new("remove")
+            )
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
+        ,Command::new("remove")
             .about("Remove a saved server configuration")
             .arg(
                 Arg::new("server")
@@ -69,6 +80,11 @@ fn get_subcommands() -> Vec<Command> {
                     .required(true)
                     .help("The nickname, host name or URL of the server"),
             )
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
             .arg(common_args::yes()),
         Command::new("ping")
             .about("Checks to see if a SpacetimeDB host is online")
@@ -76,8 +92,13 @@ fn get_subcommands() -> Vec<Command> {
                 Arg::new("server")
                     .required(true)
                     .help("The nickname, host name or URL of the server to ping"),
-            ),
-        Command::new("edit")
+            )
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
+        ,Command::new("edit")
             .about("Update a saved server's nickname, host name or protocol")
             .arg(
                 Arg::new("server")
@@ -100,6 +121,11 @@ fn get_subcommands() -> Vec<Command> {
                     .long("no-fingerprint")
                     .action(ArgAction::SetTrue),
             )
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
             .arg(common_args::yes()),
         Command::new("clear")
             .about("Deletes all data from all local databases")
@@ -195,6 +221,24 @@ pub async fn exec_add(mut config: Config, args: &ArgMatches) -> Result<(), anyho
     let nickname = args.get_one::<String>("name");
     let default = *args.get_one::<bool>("default").unwrap();
     let no_fingerprint = *args.get_one::<bool>("no-fingerprint").unwrap();
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+//    if no_fingerprint {
+//        if trust_server_cert_path.is_some() {
+//            eprintln!("WARNING: --cert ignored while using --no-fingerprint");
+//        }
+//        if client_cert_path.is_some() {
+//            eprintln!("WARNING:  ignored while using --no-fingerprint");
+//        }
+//    }
 
     let (host, protocol) = host_or_url_to_host_and_protocol(url);
     let protocol = protocol.ok_or_else(|| anyhow::anyhow!("Invalid url: {}", url))?;
@@ -204,14 +248,36 @@ pub async fn exec_add(mut config: Config, args: &ArgMatches) -> Result<(), anyho
     let fingerprint = if no_fingerprint {
         None
     } else {
-        let fingerprint = spacetime_server_fingerprint(url).await.with_context(|| {
+        let fingerprint = //map_request_error!(
+            spacetime_server_fingerprint(
+            &url.to_string(),
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ).await.with_context(|| {
             format!(
                 "Unable to retrieve fingerprint for server: {url}
 Is the server running?
 Add a server without retrieving its fingerprint with:
-\tspacetime server add --url {url} --no-fingerprint",
+\tspacetime server add --url {url} --no-fingerprint
+or provide a trusted --cert."
             )
-        })?;
+        })
+//        ,url.to_string(), client_cert_path, client_key_path)
+        ?;
+        //?;
+//        .map_err(|e| spacetimedb_lib::map_request_error(e, &url.to_string(), client_cert_path.as_deref(), client_key_path.as_deref()))?;
+//        .with_context(|e| {
+//            spacetimedb_lib::map_request_error(
+//                //anyhow::anyhow!("request failed"),
+//                e,
+//                &url.to_string(),
+//                client_cert_path.as_deref(),
+//                client_key_path.as_deref(),
+//            )
+//                .to_string()
+//        })?;
         println!("For server {}, got fingerprint:\n{}", url, fingerprint);
         Some(fingerprint)
     };
@@ -224,7 +290,6 @@ Add a server without retrieving its fingerprint with:
 
     println!("Host: {}", host);
     println!("Protocol: {}", protocol);
-
     config.save();
 
     Ok(())
@@ -240,25 +305,62 @@ pub async fn exec_remove(mut config: Config, args: &ArgMatches) -> Result<(), an
     Ok(())
 }
 
-async fn update_server_fingerprint(config: &mut Config, server: Option<&str>) -> Result<bool, anyhow::Error> {
-    let url = config.get_host_url(server)?;
-    let nick_or_host = config.server_nick_or_host(server)?;
-    let new_fing = spacetime_server_fingerprint(&url)
-        .await
-        .context("Error fetching server fingerprint")?;
-    if let Some(saved_fing) = config.server_fingerprint(server)? {
+async fn update_server_fingerprint(
+    config: &mut Config,
+    server: Option<&str>,
+    protocol: Option<&str>,
+    trust_server_cert_path: Option<&Path>,
+    client_cert_path: Option<&Path>,
+    client_key_path: Option<&Path>,
+    trust_system: bool,
+) -> Result<bool, anyhow::Error> {
+    let (host, proto, nick_or_host) = match server {
+        Some(s) => {
+            let (h, p) = host_or_url_to_host_and_protocol(s);
+            if p.is_none() && !s.contains(':') && !s.contains('/') {
+                // Nickname case: fetch URL from config
+                let url = config.get_host_url(Some(s))?;
+                let (h_url, p_url) = host_or_url_to_host_and_protocol(&url);
+                let p_url = p_url.ok_or_else(|| anyhow::anyhow!("Server {} has no protocol", s))?;
+                (h_url.to_string(), p_url.to_string(), s.to_string())
+            } else {
+                // Host or URL case
+                let p = p.or(protocol).ok_or_else(|| {
+                    anyhow::anyhow!("Protocol not specified and server {} is ambiguous", h)
+                })?;
+                (h.to_string(), p.to_string(), s.to_string())
+            }
+        }
+        None => {
+            let url = config.get_host_url(None)?;
+            let (h, p) = host_or_url_to_host_and_protocol(&url);
+            let p = p.ok_or_else(|| anyhow::anyhow!("Default server has no protocol"))?;
+            let nick = config.server_nick_or_host(None)?.to_string();
+            (h.to_string(), p.to_string(), nick)
+        }
+    };
+    let url = format!("{}://{}", proto, host);
+    let new_fing = //map_request_error!(
+        spacetime_server_fingerprint(
+            &url,
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ).await
+        .context("fetching server fingerprint")
+//        , url, client_cert_path, client_key_path)
+        ?;
+    if let Some(saved_fing) = config.server_fingerprint(Some(&host), Some(&proto))? {
         if saved_fing == new_fing {
             println!("Fingerprint is unchanged for server {}:\n{}", nick_or_host, saved_fing);
-
             Ok(false)
         } else {
             println!(
                 "Fingerprint has changed for server {}.\nWas:\n{}\nNew:\n{}",
                 nick_or_host, saved_fing, new_fing
             );
-
-            config.set_server_fingerprint(server, new_fing)?;
-
+            config.set_server_fingerprint(Some(&host), new_fing)?;
             Ok(true)
         }
     } else {
@@ -266,9 +368,7 @@ async fn update_server_fingerprint(config: &mut Config, server: Option<&str>) ->
             "No saved fingerprint for server {}. New fingerprint:\n{}",
             nick_or_host, new_fing
         );
-
-        config.set_server_fingerprint(server, new_fing)?;
-
+        config.set_server_fingerprint(Some(&host), new_fing)?;
         Ok(true)
     }
 }
@@ -276,8 +376,32 @@ async fn update_server_fingerprint(config: &mut Config, server: Option<&str>) ->
 pub async fn exec_fingerprint(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::Error> {
     let server = args.get_one::<String>("server").unwrap().as_str();
     let force = args.get_flag("force");
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
 
-    if update_server_fingerprint(&mut config, Some(server)).await? {
+    let url = config.get_host_url(Some(server))?;
+
+    let (host, protocol) = host_or_url_to_host_and_protocol(server);
+    println!("!!! {:#?}\n{:#?}\n{:#?}", host, server, url);
+    //if map_request_error!(
+    if update_server_fingerprint(
+        &mut config,
+        Some(host),
+        protocol,
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+    ).await? {
+        //.map_err(|e| spacetimedb_lib::map_request_error(e, &url, client_cert_path.as_deref(), client_key_path.as_deref()))? {
+     //   ,url, client_cert_path, client_key_path)? { 
         if !y_or_n(force, "Continue?")? {
             anyhow::bail!("Aborted");
         }
@@ -288,12 +412,39 @@ pub async fn exec_fingerprint(mut config: Config, args: &ArgMatches) -> Result<(
     Ok(())
 }
 
+
+
 pub async fn exec_ping(config: Config, args: &ArgMatches) -> Result<(), anyhow::Error> {
     let server = args.get_one::<String>("server").unwrap().as_str();
     let url = config.get_host_url(Some(server))?;
-
-    let builder = reqwest::Client::new().get(format!("{}/v1/ping", url).as_str());
-    let response = builder.send().await?;
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+//    use spacetimedb_lib;
+//    use spacetimedb_lib as u;
+//    let client = spacetimedb_lib::map_request_error2!(
+    let client = map_request_error!(
+        build_client(
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ).await//?;
+    //.map_err(|e| spacetimedb_lib::map_request_error(e, &url, client_cert_path.as_deref(), client_key_path.as_deref()))?;
+    //.map_request_error!(
+    ,url, client_cert_path, client_key_path)?;
+    //)?;
+    let builder = client.get(format!("{}/v1/ping", url).as_str());
+    let response = map_request_error!(builder.send().await
+        ,url, client_cert_path, client_key_path)?;
+//        .map_err(|e| spacetimedb_lib::map_request_error(e, &url, client_cert_path.as_deref(), client_key_path.as_deref()))?;
 
     match response.status() {
         reqwest::StatusCode::OK => {
@@ -342,6 +493,7 @@ pub async fn exec_edit(mut config: Config, args: &ArgMatches) -> Result<(), anyh
         println!("Changing host from {} to {}", old_host, new_host);
     }
     if let (Some(new_proto), Some(old_proto)) = (new_proto, old_proto) {
+        //FIXME: Changing protocol from https to https
         println!("Changing protocol from {} to {}", old_proto, new_proto);
     }
 
@@ -351,7 +503,26 @@ pub async fn exec_edit(mut config: Config, args: &ArgMatches) -> Result<(), anyh
         if no_fingerprint {
             config.delete_server_fingerprint(Some(&new_url))?;
         } else {
-            update_server_fingerprint(&mut config, Some(&new_url)).await?;
+            // TLS arguments
+            let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+            let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+            let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+            // for clients, default to true unless --no-trust-system-root-store
+            // because this is used to verify the received server cert which can be signed by public CA
+            // thus using system's trust/root store, by default, makes sense.
+            let trust_system = !args.get_flag("no-trust-system-root-store");
+            //map_request_error!(
+            update_server_fingerprint(
+                &mut config,
+                Some(&new_url),
+                new_proto,
+                trust_server_cert_path,
+                client_cert_path,
+                client_key_path,
+                trust_system,
+            ).await?;
+             //   ,new_url, client_cert_path, client_key_path)?;
         }
     }
 
diff --git a/crates/cli/src/subcommands/sql.rs b/crates/cli/src/subcommands/sql.rs
index 8e6cac174..8b40f3649 100644
--- a/crates/cli/src/subcommands/sql.rs
+++ b/crates/cli/src/subcommands/sql.rs
@@ -1,16 +1,18 @@
 use std::fmt;
 use std::fmt::Write;
 use std::time::{Duration, Instant};
+use std::path::Path;
 
 use crate::api::{from_json_seed, ClientApi, Connection, SqlStmtResult, StmtStats};
 use crate::common_args;
 use crate::config::Config;
-use crate::util::{database_identity, get_auth_header, ResponseExt, UNSTABLE_WARNING};
+use crate::util::{self, database_identity, get_auth_header, ResponseExt, UNSTABLE_WARNING, map_request_error};
 use anyhow::Context;
 use clap::{Arg, ArgAction, ArgMatches};
 use reqwest::RequestBuilder;
 use spacetimedb_lib::de::serde::SeedWrapper;
 use spacetimedb_lib::sats::{satn, ProductType, ProductValue, Typespace};
+use std::path::PathBuf;
 
 pub fn cli() -> clap::Command {
     clap::Command::new("sql")
@@ -37,20 +39,60 @@ pub fn cli() -> clap::Command {
         .arg(common_args::anonymous())
         .arg(common_args::server().help("The nickname, host name or URL of the server hosting the database"))
         .arg(common_args::yes())
+        //.arg(common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
 }
 
-pub(crate) async fn parse_req(mut config: Config, args: &ArgMatches) -> Result<Connection, anyhow::Error> {
+pub(crate) async fn parse_req(
+    mut config: Config,
+    args: &ArgMatches,
+    trust_server_cert_path: Option<&Path>,
+    client_cert_path: Option<&Path>,
+    client_key_path: Option<&Path>,
+    trust_system: bool,
+    ) -> Result<Connection, anyhow::Error> {
     let server = args.get_one::<String>("server").map(|s| s.as_ref());
     let force = args.get_flag("force");
     let database_name_or_identity = args.get_one::<String>("database").unwrap();
     let anon_identity = args.get_flag("anon_identity");
 
-    Ok(Connection {
-        host: config.get_host_url(server)?,
-        auth_header: get_auth_header(&mut config, anon_identity, server, !force).await?,
-        database_identity: database_identity(&config, database_name_or_identity, server).await?,
+    let host=config.get_host_url(server)?;
+    let client = map_request_error!(
+        util::build_client(
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ).await
+        , host, client_cert_path, client_key_path)?;
+    //    ?;
+
+//    let con=
+    Ok(
+    Connection {
+        host: host.clone(), 
+        auth_header: 
+            map_request_error!(
+                get_auth_header(&mut config, anon_identity, server, !force).await
+                , host, client_cert_path, client_key_path)
+                ?,
+        database_identity: 
+            map_request_error!(
+                database_identity(&config, database_name_or_identity, server, &client).await
+                , host, client_cert_path, client_key_path)
+                ?,
         database: database_name_or_identity.to_string(),
+        trust_server_cert_path: trust_server_cert_path.map(PathBuf::from),
+        client_cert_path: client_cert_path.map(PathBuf::from),
+        client_key_path: client_key_path.map(PathBuf::from),
+        trust_system,
     })
+//        )?
+//    Ok(con)
 }
 
 struct StmtResult {
@@ -171,15 +213,29 @@ fn stmt_result_to_table(stmt_result: &SqlStmtResult) -> anyhow::Result<(StmtStat
 
 pub async fn exec(config: Config, args: &ArgMatches) -> Result<(), anyhow::Error> {
     eprintln!("{}\n", UNSTABLE_WARNING);
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+    let con = parse_req(config, args,
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+    ).await?;
+
     let interactive = args.get_one::<bool>("interactive").unwrap_or(&false);
     if *interactive {
-        let con = parse_req(config, args).await?;
-
         crate::repl::exec(con).await?;
     } else {
         let query = args.get_one::<String>("query").unwrap();
 
-        let con = parse_req(config, args).await?;
         let api = ClientApi::new(con);
 
         run_sql(api.sql(), query, false).await?;
diff --git a/crates/cli/src/subcommands/subscribe.rs b/crates/cli/src/subcommands/subscribe.rs
index 6eb2039c7..6feba2844 100644
--- a/crates/cli/src/subcommands/subscribe.rs
+++ b/crates/cli/src/subcommands/subscribe.rs
@@ -19,6 +19,9 @@ use crate::common_args;
 use crate::sql::parse_req;
 use crate::util::UNSTABLE_WARNING;
 use crate::Config;
+use std::path::{Path, PathBuf};
+use spacetimedb_lib::MAX_CERT_BUNDLE_SIZE;
+use zeroize::Zeroize;
 
 pub fn cli() -> clap::Command {
     clap::Command::new("subscribe")
@@ -66,6 +69,12 @@ pub fn cli() -> clap::Command {
                 .action(ArgAction::SetTrue)
                 .help("Print the initial update for the queries."),
         )
+        //.arg(common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
         .arg(common_args::anonymous())
         .arg(common_args::yes())
         .arg(common_args::server().help("The nickname, host name or URL of the server hosting the database"))
@@ -132,7 +141,22 @@ pub async fn exec(config: Config, args: &ArgMatches) -> Result<(), anyhow::Error
     let timeout = args.get_one::<u32>("timeout").copied();
     let print_initial_update = args.get_flag("print_initial_update");
 
-    let conn = parse_req(config, args).await?;
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+    let conn = parse_req(config, args,
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+        ).await?;
     let api = ClientApi::new(conn);
     let module_def = api.module_def().await?;
 
@@ -158,7 +182,74 @@ pub async fn exec(config: Config, args: &ArgMatches) -> Result<(), anyhow::Error
     if let Some(auth_header) = api.con.auth_header.to_header() {
         req.headers_mut().insert(header::AUTHORIZATION, auth_header);
     }
-    let (mut ws, _) = tokio_tungstenite::connect_async(req).await?;
+
+    // Configure TLS with cert_path
+    let connector = if req.uri().scheme_str() != Some("wss") {
+        let b:bool=trust_server_cert_path.is_some() || client_cert_path.is_some() || client_key_path.is_some();
+        if b {
+            return Err(anyhow::anyhow!("Using cert(s)/key require using https:// scheme not http://"));
+        }
+        None
+    } else {
+        let mut builder = native_tls::TlsConnector::builder();
+        
+        // Validate trust store
+        if !trust_system && trust_server_cert_path.is_none() {
+            return Err(anyhow::anyhow!(
+                "--no-trust-system-root-store requires --trust-server-cert"
+            ));
+        }
+        if !trust_system {
+            builder.disable_built_in_roots(true);
+        }
+
+        if let Some(cert_path) = trust_server_cert_path {
+            let cert_data = spacetimedb_lib::read_file_limited(cert_path, MAX_CERT_BUNDLE_SIZE)
+                .await
+                .context(format!("Failed to read cert file: {}", cert_path.display()))?;
+            let certs = rustls_pemfile::certs(&mut std::io::Cursor::new(cert_data))
+                .collect::<Result<Vec<_>, _>>()
+                .context(format!("Failed to parse trust certificates: {}", cert_path.display()))?;
+            if certs.is_empty() {
+                return Err(anyhow::anyhow!(
+                    "No valid certificates in: {}",
+                    cert_path.display()
+                ));
+            }
+            for cert in certs {
+                //TODO: show me added certs like we do in other places!
+                let native_cert = native_tls::Certificate::from_der(&cert).context(format!(
+                    "Failed to convert cert to native-tls format from {}",
+                    cert_path.display()
+                ))?;
+                builder.add_root_certificate(native_cert);
+            }
+        }
+
+        // Configure mTLS
+        if let Some(cert_path) = client_cert_path {
+            let key_path = client_key_path.ok_or_else(|| {
+                anyhow::anyhow!("--client-key is required with --client-cert")
+            })?;
+            let cert_data = spacetimedb_lib::read_file_limited(cert_path, MAX_CERT_BUNDLE_SIZE)
+                .await
+                .context(format!("Failed to read client cert: {}", cert_path.display()))?;
+            let mut key_data = spacetimedb_lib::read_file_limited(key_path, MAX_CERT_BUNDLE_SIZE)
+                .await
+                .context(format!("Failed to read client key: {}", key_path.display()))?;
+            let identity = native_tls::Identity::from_pkcs8(&cert_data, &key_data).context(format!(
+                "Failed to parse client cert/key: {}",
+                cert_path.display()
+            ))?;
+            builder.identity(identity);
+            key_data.zeroize();
+        }
+
+        let tls_connector = builder.build().context("Failed to build TLS connector")?;
+        Some(tokio_tungstenite::Connector::NativeTls(tls_connector))
+    };
+
+    let (mut ws, _) = tokio_tungstenite::connect_async_tls_with_config(req, None, false, connector).await?;
 
     let task = async {
         subscribe(&mut ws, queries.cloned().map(Into::into).collect()).await?;
diff --git a/crates/cli/src/util.rs b/crates/cli/src/util.rs
index 20e0591ca..af22d9f63 100644
--- a/crates/cli/src/util.rs
+++ b/crates/cli/src/util.rs
@@ -9,6 +9,12 @@ use std::path::Path;
 
 use crate::config::Config;
 use crate::login::{spacetimedb_login_force, DEFAULT_AUTH_HOST};
+pub use spacetimedb_lib::load_root_cert;
+pub use spacetimedb_lib::{read_file_limited, TrustCertError, ClientCertError, ClientKeyError};
+pub use spacetimedb_lib::map_request_error;
+pub use spacetimedb_lib::MAX_CERT_BUNDLE_SIZE;
+pub use spacetimedb_lib::MAX_KEY_FILE_SIZE;
+use zeroize::Zeroize;
 
 pub const UNSTABLE_WARNING: &str = "WARNING: This command is UNSTABLE and subject to breaking changes.";
 
@@ -17,11 +23,12 @@ pub async fn database_identity(
     config: &Config,
     name_or_identity: &str,
     server: Option<&str>,
+    client: &reqwest::Client,
 ) -> Result<Identity, anyhow::Error> {
     if let Ok(identity) = Identity::from_hex(name_or_identity) {
         return Ok(identity);
     }
-    spacetime_dns(config, name_or_identity, server)
+    spacetime_dns(config, name_or_identity, server, client)
         .await?
         .with_context(|| format!("the dns resolution of `{name_or_identity}` failed."))
 }
@@ -106,13 +113,171 @@ impl ResponseExt for reqwest::Response {
     }
 }
 
+
+//pub async fn configure_tls(cert_path: Option<&Path>) -> anyhow::Result<reqwest::ClientBuilder> {
+//    let mut client_builder = reqwest::Client::builder();
+//    if let Some(cert) = load_root_cert(cert_path).await? {
+//        let path:String=cert_path.map_or("<unexpected empty path>".to_string(), |p| p.display().to_string());
+//        let reqwest_cert = reqwest::Certificate::from_der(&cert.to_der()
+//            .context(format!("Failed to convert certificate to DER for: {}", path))?)
+//            .context(format!("Invalid certificate: {}", path))?;
+//        client_builder = client_builder.add_root_certificate(reqwest_cert);
+//    }
+//    Ok(client_builder)
+//}
+pub async fn configure_tls(
+    trust_server_cert_path: Option<&Path>,
+    client_cert_path: Option<&Path>,
+    client_key_path: Option<&Path>,
+    trust_system: bool,
+//    no_trust_system: bool,
+) -> anyhow::Result<reqwest::ClientBuilder> {
+    let mut client_builder = reqwest::Client::builder().use_native_tls();
+
+    client_builder = if trust_system {
+        //TODO: find out if this method is taking /etc/ssl/ system trust store certs or what!
+        eprintln!("Trusting system/root cert store for verifying server's cert.");
+        client_builder.tls_built_in_root_certs(true)
+    } else {
+        eprintln!("Not trusting system/root cert store for verifying server's cert.");
+        client_builder.tls_built_in_root_certs(false)
+    };
+//    // Validate trust store options
+//    if no_trust_system && trust_cert_path.is_none() {
+//        //XXX: probably never hit due to clap enforcing this.
+//        return Err(anyhow!("--no-trust-system-root-store requires --trust-server-cert"));
+//    }
+
+    // Load trust certificates
+    if let Some(path) = trust_server_cert_path {
+        let cert_data = read_file_limited(path, MAX_CERT_BUNDLE_SIZE).await
+            .map_err(|e| anyhow::Error::new(TrustCertError::new(path, e)))?;
+        let certs = rustls_pemfile::certs(&mut std::io::Cursor::new(cert_data))
+            .collect::<Result<Vec<_>, _>>()
+            .context(format!("parse trust certificate(s) from file: {}", display_path(path)))
+            .map_err(|e| anyhow::Error::new(TrustCertError::new(path, e)))?;
+        if certs.is_empty() {
+            return Err(anyhow::anyhow!("No valid trust certificate(s) in file: {}", display_path(path)));
+        }
+        use x509_parser::prelude::FromDer;
+        use sha2::Digest;
+        for cert in certs {
+//            // Parse and log cert details
+//            if let Ok((_, parsed)) = x509_parser::prelude::X509Certificate::from_der(cert.as_ref()) {
+//                let subject = parsed.subject().to_string();
+//                let issuer = parsed.issuer().to_string();
+//                let not_after = parsed.validity().not_after.to_string();
+//                let serial = parsed.serial.to_string();
+//                let fingerprint = format!("{:x}", sha2::Sha256::digest(cert.as_ref()));
+//                log::info!(
+//                    "Client root cert: subject={}, issuer={}, serial={}, expires={}, fingerprint={}",
+//                    subject, issuer, serial, not_after, fingerprint
+//                );
+//            } else {
+//                log::warn!("Failed to parse client root cert from file: '{}'",path.display());
+//            }
+            // Parse and log cert details
+            let (_, parsed) = x509_parser::prelude::X509Certificate::from_der(cert.as_ref())
+                .context(format!("parse a trust cert from file: {}", display_path(path)))?;
+            let subject = parsed.subject().to_string();
+            let issuer = parsed.issuer().to_string();
+            let not_after = parsed.validity().not_after.to_string();
+            let serial = parsed.serial.to_string();
+            let fingerprint = format!("{:x}", sha2::Sha256::digest(cert.as_ref()));
+            //log::info!(
+            eprintln!(
+                "Adding trusted root cert(for server verification): subject={}, issuer={}, serial={}, expires={}, fingerprint={}",
+                subject, issuer, serial, not_after, fingerprint
+            );
+            let reqwest_cert = 
+                reqwest::Certificate::from_der(&cert)
+                //anyhow::anyhow!("foo")
+                .context(format!("convert trusted cert to reqwest format from file: {}", display_path(path)))
+                .map_err(|e| anyhow::Error::new(TrustCertError::new(path, e)))?;
+            client_builder = client_builder.add_root_certificate(reqwest_cert);
+        }
+    }
+
+    // Configure client authentication aka mTLS
+    if let Some(cert_path) = client_cert_path {
+        let key_path = client_key_path.context("clap ensures if --client-cert was used --client-key was too with a path, so reaching this is impossible?!")?;
+        let cert_data = read_file_limited(cert_path, MAX_CERT_BUNDLE_SIZE).await
+            .map_err(|e| anyhow::Error::new(ClientCertError::new(cert_path,e)))
+            ?;
+        let mut key_data = read_file_limited(key_path, MAX_KEY_FILE_SIZE).await
+            .map_err(|e| anyhow::Error::new(ClientKeyError::new(key_path,e)))
+            ?;
+        //let identity = reqwest::Identity::from_pkcs8_pem(&[&cert_data[..], &key_data[..]].concat())
+        let identity = reqwest::Identity::from_pkcs8_pem(&cert_data, &key_data)
+            .context(format!("parse client cert: {}, key: {}", display_path(cert_path), display_path(key_path)))?;
+        client_builder = client_builder.identity(identity);
+        key_data.zeroize();
+    }
+
+    Ok(client_builder)
+}
+
+pub const UNSPECIFIED_PATH:&str="<unspecified path, ie. None>";
+
+// Function to convert Option<&Path> to a displayable &str
+pub fn display_opt_path(path: Option<&Path>) -> &str {
+    // Match on the Option to handle Some and None cases
+    match path {
+        Some(p) => p.to_str().unwrap_or(UNSPECIFIED_PATH), // Convert Path to &str, fallback if invalid
+        None => UNSPECIFIED_PATH, // Return default for None
+    }
+}
+pub fn display_path(path: &Path) -> &str {
+    path.to_str().unwrap_or(UNSPECIFIED_PATH) // Convert Path to &str, fallback if invalid
+}
+
+
+pub fn build_client_with_context(
+    builder: reqwest::ClientBuilder,
+    trust_server_cert_path: Option<&Path>,
+    client_cert_path: Option<&Path>,
+    client_key_path: Option<&Path>,
+    trust_system: bool,
+    ) -> anyhow::Result<reqwest::Client> {
+    builder
+        .build()
+        .context(
+            format!("Failed to build client with trusted (server)cert(s) {}, with client cert(s): {}, with client private key: {}, while {} the system/root cert store for verifying the server's cert.",
+            display_opt_path(trust_server_cert_path),
+            display_opt_path(client_cert_path),
+            display_opt_path(client_key_path),
+            if trust_system { "trusting" } else { "NOT trusting" },
+            )
+        )
+}
+
+pub async fn build_client(
+    trust_server_cert_path: Option<&Path>,
+    client_cert_path: Option<&Path>,
+    client_key_path: Option<&Path>,
+    trust_system: bool,
+    ) -> anyhow::Result<reqwest::Client> {
+    let builder = configure_tls(
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+        ).await.context("build client")?;
+    build_client_with_context(builder,
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+    )
+}
+
 /// Converts a name to a database identity.
 pub async fn spacetime_dns(
     config: &Config,
     domain: &str,
     server: Option<&str>,
+    client: &reqwest::Client,
 ) -> Result<Option<Identity>, anyhow::Error> {
-    let client = reqwest::Client::new();
     let url = format!("{}/v1/database/{}/identity", config.get_host_url(server)?, domain);
     let Some(res) = client.get(url).send().await?.found() else {
         return Ok(None);
@@ -123,9 +288,47 @@ pub async fn spacetime_dns(
         .context("identity endpoint did not return an identity")
 }
 
-pub async fn spacetime_server_fingerprint(url: &str) -> anyhow::Result<String> {
-    let builder = reqwest::Client::new().get(format!("{}/v1/identity/public-key", url).as_str());
-    let res = builder.send().await?.error_for_status()?;
+pub async fn spacetime_server_fingerprint(
+    url: &String,
+    trust_server_cert_path: Option<&Path>,
+    client_cert_path: Option<&Path>,
+    client_key_path: Option<&Path>,
+    trust_system: bool,
+    ) -> anyhow::Result<String> {
+    if let Some(_path) = trust_server_cert_path {
+        if !url.starts_with("https") {
+            eprintln!("WARNING: Non-https url '{url}' but --cert was specified.");
+        }
+    }
+
+//    //doneTODO: collapse these 2 into build_client from above.
+//    let builder = configure_tls(
+//        trust_server_cert_path,
+//        client_cert_path,
+//        client_key_path,
+//        trust_system,
+//        ).await.context("attempt server fingerprint")?;
+//    let client = builder.build().map_err(|e| anyhow::anyhow!("Failed to build client: {}", e))?;
+
+    let client = map_request_error!(
+        build_client(
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ).await.context("attempt server fingerprint")
+        , url, client_cert_path, client_key_path)
+        ?;
+
+
+    // A request 'builder' it seems:
+    let builder = client.get(format!("{}/v1/identity/public-key", url).as_str());
+    let res = map_request_error!(
+        builder.send().await
+        //?
+        , url, client_cert_path, client_key_path)?
+        .error_for_status()
+        ?;
     let fingerprint = res.text().await?;
     Ok(fingerprint)
 }
@@ -314,9 +517,21 @@ pub async fn get_login_token_or_log_in(
 
     if full_login {
         let host = Url::parse(DEFAULT_AUTH_HOST)?;
-        spacetimedb_login_force(config, &host, false).await
+        spacetimedb_login_force(config, &host, false,
+            /*TODO*/
+            None,
+            None,
+            None,
+            false,
+            ).await
     } else {
         let host = Url::parse(&config.get_host_url(target_server)?)?;
-        spacetimedb_login_force(config, &host, true).await
+        spacetimedb_login_force(config, &host, true,
+            /*TODO*/
+            None,
+            None,
+            None,
+            false,
+            ).await
     }
 }
diff --git a/crates/lib/Cargo.toml b/crates/lib/Cargo.toml
index 1057d8fb8..411a4b126 100644
--- a/crates/lib/Cargo.toml
+++ b/crates/lib/Cargo.toml
@@ -43,9 +43,25 @@ thiserror.workspace = true
 blake3.workspace = true
 enum-map = { workspace = true, optional = true }
 
+#XXX: can't bring openssl or mio into this lib due to "publish" failing to compile them in wasm!
+#eg. hyper,reqwest,native-tls,tokio all bring either of them.
+[target.'cfg(not(target_arch = "wasm32"))'.dependencies]
+#tokio = { version= "1.44", default-features = false, features = ["rt", "sync", "time"] }
+tokio.workspace = true #this "full" tokio causes 'mio' to fail to wasm compile see: https://github.com/tokio-rs/mio/pull/1856
+#native-tls = "0.2"
+native-tls.workspace=true
+hyper.workspace=true
+openssl.workspace=true
+clap.workspace = true
+reqwest.workspace=true
+#This pki-types crate is actually an indirect(aka transitive) dep of reqwest above, but we want a feature enabled, so:
+rustls-pki-types.workspace=true #needed here, to enable its 'trace_drop_and_zeroize' feature
+#rustls-pki-types = { version = "1.11", features = ["trace_drop_and_zeroize"] }
+
 # For the 'proptest' feature.
 proptest = { workspace = true, optional = true }
 proptest-derive = { workspace = true, optional = true }
+zeroize.workspace=true
 
 [dev-dependencies]
 spacetimedb-sats = { path = "../sats", features = ["test"] }
@@ -57,3 +73,34 @@ ron.workspace = true
 # Also as dev-dependencies for use in _this_ crate's tests.
 proptest.workspace = true
 proptest-derive.workspace = true
+tempfile.workspace=true
+
+##no effect if here:
+#[patch.crates-io]
+##A version that has zeroize, because 1.12.0 or so, isn't yet released.
+##Patched to have zeroize() method but doesn't zeroize on drop(this isn't enough for our uses!):
+##rustls-pki-types = { git = "https://github.com/rustls/pki-types.git", rev = "b59e08d49911b10c423d25bd9040cfbe5a6042ff" }
+#
+##Patched to zeroize on drop(good for us):
+#rustls-pki-types = { path = "/home/user/SOURCE/github/modified_forks/pki-types" }
+##^ it's indirectly used though.
+#
+## a rustls that uses same pki-types patch.crates-io section from above and also enables pki-types' feature trace_drop_and_zeroize
+##rustls = { path = "/home/user/SOURCE/github/rustls/rustls" }
+##so rustls's Cargo.toml is modded to look like this:
+### pki-types = { package = "rustls-pki-types", version = "1.11", features = ["alloc","trace_drop_and_zeroize"] }
+###...
+### ppatch.crates-io]
+### rustls-pki-types = { path = "/home/user/SOURCE/github/modified_forks/pki-types" } #patched with ./zeroize_on_drop.patch
+##XXX: this ^ (rustls hack) isn't needed if using the above inclusion of rustls-pki-types as dep here and .workspace=true in any Cargo.toml that has deps that use it.
+#
+##patched to not obscure connection errors behind ChannelClosed:
+#hyper-util = { path ="/home/user/SOURCE/my/channelclosed.reqwest/hyper-util" }
+#
+##The current branch(TLS+mTLS) which added these changes to spacetimedb is also available as patch in: https://github.com/dare3path/spacetimedb-tls-patch
+#
+
+##no effect, if here or in root dir aka workspace Cargo.toml
+#[patch.crates-io]
+#rustls-pki-types = { path = "/home/user/SOURCE/github/modified_forks/pki-types" }
+#hyper-util = { path ="/home/user/SOURCE/my/channelclosed.reqwest/hyper-util" }
diff --git a/crates/lib/src/lib.rs b/crates/lib/src/lib.rs
index d25e317ea..d255ca205 100644
--- a/crates/lib/src/lib.rs
+++ b/crates/lib/src/lib.rs
@@ -6,6 +6,25 @@ use spacetimedb_sats::{impl_serialize, WithTypespace};
 use std::any::TypeId;
 use std::collections::{btree_map, BTreeMap};
 
+pub const TRACE_DROP_AND_ZEROIZE: bool = false;//TODO: make this depend on ring||pki-types' trace_drop_and_zeroize feature
+
+macro_rules! non_wasm {
+    ($($item:item)*) => {
+        $(
+            #[cfg(not(target_arch = "wasm32"))]
+            $item
+        )*
+    };
+}
+
+//XXX: we avoid anything 'mio' or 'openssl' which will fail to compile in wasm32; this this lib is
+//used on both wasm32 during 'spacetime publish' compilation and non-wasm32 ie. x86_64
+//#[cfg(not(target_arch = "wasm32"))]
+non_wasm! {
+use tokio::io::AsyncReadExt;
+use zeroize::Zeroize; // adds .zeroize to Vec<u8> amongst others.
+}
+
 pub mod connection_id;
 pub mod db;
 mod direct_index_key;
@@ -386,3 +405,923 @@ pub fn resolved_type_via_v9<T: SpacetimeType>() -> AlgebraicType {
         .resolve_refs()
         .expect("recursive types not supported")
 }
+
+non_wasm! {
+    /// one ore more concatenated certificated (ie. public) ie. a .crt file bundle
+    pub const MAX_CERT_BUNDLE_SIZE:usize=1_048_576;//1MiB
+    /// size of a private key file (contains 1 private key) ie. a .key file
+    pub const MAX_KEY_FILE_SIZE:usize=64*1024;//64KiB
+    pub async fn load_root_cert(cert_path: Option<&std::path::Path>) -> anyhow::Result<Option<native_tls::Certificate>> {
+        if let Some(path) = cert_path {
+            // Read file using read_file_limited
+            let cert_data = read_file_limited(path, MAX_CERT_BUNDLE_SIZE)
+                .await
+                .context(format!("Failed to read certificate file: {}", path.display()))?;
+
+            // Convert Vec<u8> to String for PEM parsing
+            let cert_pem = String::from_utf8(cert_data)
+                .context(format!("Certificate file is not valid UTF-8: {}", path.display()))?;
+
+            // Parse PEM
+            let cert = native_tls::Certificate::from_pem(cert_pem.as_bytes())
+                .context(format!("Failed to parse PEM certificate: {}", path.display()))?;
+
+            eprintln!("Added trusted certificate from {} for a new TLS connection.", path.display());
+            Ok(Some(cert))
+        } else {
+            eprintln!("No trusted certificate specified via --cert for this new connection, thus if you used local CA or self-signed server certificate, you may get an error like '(unable to get local issuer certificate)' next.");
+            Ok(None)
+        }
+    }
+
+    //for cli clients:
+    pub fn trust_server_cert() -> clap::Arg {
+        //TODO: rename this to trust_ca_cert() it's less confusing
+        clap::Arg::new("trust-server-cert")
+            .long("trust-server-cert")
+            .alias("trust-server-certs")
+            .alias("trust-server-cert-bundle")
+            .alias("cert")
+            .alias("certs")
+            .alias("cert-bundle")
+            .alias("root-cert")
+            .alias("root-certs")
+            .alias("root-cert-bundle")
+            .alias("trust-ca-cert")
+            .alias("trust-ca-certs")
+            .alias("trust-ca-cert-bundle")
+            .alias("ca-certs")
+            .alias("ca-cert")
+            .alias("ca-cert-bundle")
+            .value_name("FILE")
+            .action(clap::ArgAction::Set)
+            .value_parser(clap::value_parser!(std::path::PathBuf))
+            .required(false)
+            //        .requires("ssl")
+            //.help("Path to PEM file containing certificates to trust for the server (e.g., CA or self-signed)")
+            .help("Path to the server’s self-signed certificate or CA certificate (PEM format, can be a bundle ie. appended PEM certs) to trust during this command (ie. as if it were part of your system's cert trust/root store)")
+    }
+
+    //for the cli clients:
+    pub fn client_cert() -> clap::Arg {
+        clap::Arg::new("client-cert")
+            .long("client-cert")
+            .value_name("FILE")
+            .action(clap::ArgAction::Set)
+            .value_parser(clap::value_parser!(std::path::PathBuf))
+            .required(false)
+            .requires("client-key")
+            .help("Path to the client’s certificate (PEM format) for authentication, this will be presented to the server that we(the client) are trying to connect to.")
+    }
+
+    //for the cli clients:
+    pub fn client_key() -> clap::Arg {
+        clap::Arg::new("client-key")
+            .long("client-key")
+            .value_name("FILE")
+            .action(clap::ArgAction::Set)
+            .value_parser(clap::value_parser!(std::path::PathBuf))
+            .required(false)
+            .requires("client-cert")
+            .help("Path to the client’s private key (PEM format) for authentication, this will be used our(client) outgoing connection to the server.")
+    }
+
+    //for cli clients, this is the default(to trust):
+    pub fn trust_system_root_store() -> clap::Arg {
+        clap::Arg::new("trust-system-root-store")
+            .long("trust-system-root-store")
+            //        .alias("trust-root-store")
+            .action(clap::ArgAction::SetTrue)
+            .conflicts_with("no-trust-system-root-store")
+            //        .requires("ssl")
+            .help("Use system root certificates (default)")
+    }
+
+    //for cli clients, setting this means only the --trust-server-certs arg is used to verify the
+    //target server's cert):
+    pub fn no_trust_system_root_store() -> clap::Arg {
+        clap::Arg::new("no-trust-system-root-store")
+            .long("no-trust-system-root-store")
+            .alias("empty-trust-store")
+            //        .alias("no-trust-root-store")
+            .action(clap::ArgAction::SetTrue)
+            .conflicts_with("trust-system-root-store")
+            .requires("trust-server-cert")
+            .help("Use empty trust store (requires --trust-server-cert else there'd be 0 certs to verify trust)")
+    }
+
+    //for the standalone server:
+    pub fn client_trust_cert() -> clap::Arg {
+        clap::Arg::new("client-trust-cert")
+            .long("client-trust-cert")
+            .alias("client-cert")
+            .alias("client-certs")
+            .alias("client-ca-cert")
+            .alias("client-CA-cert")
+            .alias("client-root-cert")
+            .alias("client-trust-certs")
+            .alias("client-ca-certs")
+            .alias("client-CA-certs")
+            .alias("client-root-certs")
+            .alias("client-cert-bundle")
+            .alias("client-trust-cert-bundle")
+            .alias("client-ca-cert-bundle")
+            .alias("client-CA-cert-bundle")
+            .alias("client-root-cert-bundle")
+            .value_name("FILE")
+            .action(clap::ArgAction::Set)
+            .value_parser(clap::value_parser!(std::path::PathBuf))
+            .requires("ssl")
+            .required(false)
+            .help("Path to PEM file containing certificate(s) to trust for client authentication (e.g., CA or self-signed)")
+    }
+
+    //for the standalone server:
+    pub fn client_trust_system_root_store() -> clap::Arg {
+        clap::Arg::new("client-trust-system-root-store")
+            .long("client-trust-system-root-store")
+            .action(clap::ArgAction::SetTrue)
+            .conflicts_with("client-no-trust-system-root-store")
+            .requires("ssl")
+            .help("Use system root certificates for client authentication (unusual)")
+    }
+
+    //for the standalone server:
+    pub fn client_no_trust_system_root_store() -> clap::Arg {
+        clap::Arg::new("client-no-trust-system-root-store")
+            .long("client-no-trust-system-root-store")
+            .alias("client-empty-trust-store")
+            .action(clap::ArgAction::SetTrue)
+            .conflicts_with("client-trust-system-root-store")
+            .requires("client-trust-cert")
+            .requires("ssl")
+            .help("Use empty trust store for client authentication (default), requires --client-trust-cert to validate client certs somehow.")
+    }
+
+    //This ensures data is zeroized on error paths (when ZeroizingVec is dropped) but allows returning the Vec on success without zeroizing.
+    struct ZeroizingVec(Vec<u8>);
+
+    impl ZeroizingVec {
+        fn new(capacity: usize) -> Self {
+            ZeroizingVec(Vec::with_capacity(capacity))
+        }
+
+        fn as_mut_vec(&mut self) -> &mut Vec<u8> {
+            &mut self.0
+        }
+
+        fn into_inner(mut self) -> Vec<u8> {
+            //std::mem::take<T>(dest: &mut T) -> T replaces the value at dest with a “default” value (for Vec<u8>, an empty Vec with zero capacity) and returns the original value.
+            std::mem::take(&mut self.0)
+            // Drop runs automatically, zeroizing the now-empty(and unallocated on heap) self.0 vec
+        }
+    }
+
+    impl zeroize::ZeroizeOnDrop for ZeroizingVec {} // Marker
+    impl Drop for ZeroizingVec {
+        fn drop(&mut self) {
+            //#[cfg(trace_drop_and_zeroize)] // set by ../build.rs if ring or pki-types have it set.
+            if TRACE_DROP_AND_ZEROIZE {
+                if self.0.len() > 0 {
+                    eprintln!("!!! Dropping ZeroizingVec after zeroize-ing it.");
+                } else {
+                    eprintln!("!!! Dropping ZeroizingVec (empty)");
+                }
+            }
+            self.0.zeroize();
+        }
+    }
+
+    const MAX_BUF_SIZE:usize=64 * 1024; // 64KiB
+    // Helper to zeroize a fixed-size buffer on drop
+    struct ZeroizingBuffer([u8; MAX_BUF_SIZE]); // 64 KiB, matching Tokio's default chunk size
+
+    impl ZeroizingBuffer {
+        fn new() -> Self {
+            ZeroizingBuffer([0u8; MAX_BUF_SIZE])
+        }
+
+        fn as_mut_slice(&mut self) -> &mut [u8] {
+            &mut self.0
+        }
+    }
+
+    impl zeroize::ZeroizeOnDrop for ZeroizingBuffer {} // Marker
+    impl Drop for ZeroizingBuffer {
+        fn drop(&mut self) {
+            //#[cfg(feature = "trace_drop_and_zeroize")] // set by ../build.rs if ring or pki-types have it set.
+            //#[cfg(trace_drop_and_zeroize)] // set by ../build.rs if ring or pki-types have it set.
+            //XXX: can't really detect if ring(not in lib's Cargo.toml dep) or pki-types(it's in Cargo.toml) has trace_drop_and_zeroize feature since it's indirectly pulled by my_fork (unless I used my_fork=[] in pki-types or ring) but maybe it works via cargo metadata in build.rs, didn't try it. However, decided to use this const and toggle it by editing this source, if needed, ever.
+            if TRACE_DROP_AND_ZEROIZE {
+                if self.0.len() > 0 {
+                    eprintln!("!!! Dropping ZeroizingBuffer after zeroize-ing it.");
+                } else {
+                    eprintln!("!!! Dropping ZeroizingBuffer (empty)");
+                }
+            }
+            self.0.zeroize();
+        }
+    }
+
+    fn smallest_non_zero(a: usize, b: usize) -> usize {
+        assert!(a != 0 || b != 0, "both args were 0");
+        if a == 0 {
+            b
+        } else if b == 0 {
+            a
+        } else {
+            a.min(b)
+        }
+    }
+
+    /// Asynchronously reads a file with a maximum size limit specified by max_size.
+    /// If max_size is 0, no limit is applied (up to usize::MAX).
+    /// Files up to and including max_size bytes are allowed; larger files will fail.
+    /// Uses a temporary buffer to read chunks, allowing detection of extra data without over-allocating data.
+    /// The internal buffer (which is temporary) is zeroized(on Drop) on error or success to prevent sensitive data lingering in memory.
+    /// The returned data isn't zeroized, it's left for the caller to zeroize!
+    pub async fn read_file_limited(path: &Path, max_size: usize) -> anyhow::Result<Vec<u8>> {
+        let max_size = if max_size == 0 { usize::MAX } else { max_size };
+        debug_assert!(max_size > 0);
+
+        let mut file: tokio::fs::File = tokio::fs::OpenOptions::new()
+            .read(true)
+            .write(false)
+            .open(path)
+            .await
+            .context(format!("Failed to open file: {}", path.display()))?;
+
+        // This to avoid the reading/mem alloc-ing for normal eg. non-/dev/zero files:
+        let metadata = file
+            .metadata()
+            .await
+            .context(format!("Failed to read metadata for {}", path.display()))?;
+
+        let f_len: usize = metadata
+            .len()
+            .try_into()
+            .context(format!(
+                    "File size for {} exceeds usize::MAX ({}) or is invalid",
+                    path.display(),
+                    usize::MAX
+            ))?;
+
+        if f_len > max_size {
+            return Err(anyhow::anyhow!(
+                    "File {} is {} bytes, which exceeds expected-maximum size of {} bytes",
+                    path.display(),
+                    f_len,
+                    max_size
+            ));
+        }
+
+        // blocks like /dev/zero are 0 bytes file len, thus then pick max_size instead.
+        let max_read_len: usize = smallest_non_zero(f_len, max_size);
+        // These are assert!, not debug_assert!, so they always execute, even in release builds, regardless of debug-assertions.
+        assert!(max_read_len > 0, "max_read_len must be positive");
+
+        let mut data = ZeroizingVec::new(max_read_len);
+        let mut buffer = ZeroizingBuffer::new();
+        let buf_slice:&mut [u8] = buffer.as_mut_slice();
+        let buf_slice_len:usize=buf_slice.len();
+        let mut total_read: usize = 0;
+
+        // Read chunks into buffer, copy to data up to max_read_len
+        while total_read < max_read_len {
+            let to_read = (max_read_len - total_read).min(buf_slice_len);
+            let n = file
+                .read(&mut buf_slice[..to_read])
+                .await
+                .context(format!("Failed to read file: {}", path.display()))?;
+            if n == 0 {
+                debug_assert!(to_read > 0, "to_read must be positive for n == 0 to indicate EOF");
+                break; // EOF
+            }
+            data.as_mut_vec().extend_from_slice(&buf_slice[..n]);
+            total_read += n;
+        }
+
+        // Check for extra data by attempting to read one more byte into the buffer
+        if total_read == max_read_len {
+            let n = file
+                .read(&mut buf_slice[..1])
+                .await
+                .context(format!("Failed to check for extra data: {}", path.display()))?;
+            if n > 0 && max_read_len == max_size {
+                return Err(anyhow::anyhow!(
+                        "File {} has more data after reading {} bytes, exceeding maximum size of {} bytes",
+                        path.display(),
+                        max_read_len,
+                        max_size
+                ));
+            }
+        }
+
+        // Buffer is zeroized automatically on drop (success or error)
+        // but 'data' isn't, well the Vec<u8> we return is caller's problem to zeroize now.
+        Ok(data.into_inner())
+    }
+
+    #[macro_export]
+    macro_rules! set_string {
+        ($s:expr, $new:expr) => {
+            $s.replace_range(.., $new);
+        };
+    }
+
+    pub fn set_string(s: &mut String, new: &str) {
+        s.replace_range(.., new);
+    }
+
+    #[macro_export]
+    macro_rules! new_string {
+        ($binding:ident, $initial:literal, $capacity:expr) => {
+            let mut $binding: String = {
+                const LOCAL: &str = $initial; // Explicit &str
+                let capacity: usize = const {
+                    // Compile-time check
+                    const INIT_LEN: usize = $initial.len();
+                    if $capacity >= INIT_LEN { $capacity } else { INIT_LEN }
+                };
+                let mut s: String = String::with_capacity(capacity);
+                s.push_str(LOCAL);
+                //FIXME Move: Returns a String (24 bytes: ptr, len, capacity), moved to $binding.
+                //--release: LLVM inlines the block, constructing s directly in $binding’s stack slot (zero cost). The move is eliminated—s is built in-place.
+                s
+            };
+        };
+        ($binding:ident, $initial:expr, $capacity:expr) => {
+            let mut $binding: String = {
+                let local: &str = $initial; // Explicit &str
+                let capacity: usize = {
+                    // Runtime check
+                    let init_len = local.len();
+                    if $capacity >= init_len { $capacity } else { init_len }
+                };
+                let mut s: String = String::with_capacity(capacity);
+                s.push_str(local);
+                //FIXME Move: Returns a String (24 bytes: ptr, len, capacity), moved to $binding.
+                //--release: LLVM inlines the block, constructing s directly in $binding’s stack slot (zero cost). The move is eliminated—s is built in-place.
+                s
+            };
+        };
+    }
+
+    use std::path::Path;
+    use std::error::Error;
+
+    #[derive(Debug)]
+    pub struct ClientCertError {
+        path: String,
+        source: anyhow::Error,
+    }
+
+    impl ClientCertError {
+        pub fn new(path: &Path, source: anyhow::Error) -> Self {
+            Self {
+                path: path.display().to_string(),
+                source,
+            }
+        }
+    }
+
+    impl std::fmt::Display for ClientCertError {
+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+            write!(f, "Something failed with client certificate {}", self.path) //: {}", self.path, self.source)
+        }
+    }
+
+    impl Error for ClientCertError {
+        fn source(&self) -> Option<&(dyn Error + 'static)> {
+            Some(&*self.source)
+        }
+    }
+
+    #[derive(Debug)]
+    pub struct ClientKeyError {
+        path: String,
+        source: anyhow::Error,
+    }
+
+    impl ClientKeyError {
+        pub fn new(path: &Path, source: anyhow::Error) -> Self {
+            Self {
+                path: path.display().to_string(),
+                source,
+            }
+        }
+    }
+
+    impl std::fmt::Display for ClientKeyError {
+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+            write!(f, "Something failed with client private key {}", self.path) //: {}", self.path, self.source)
+        }
+    }
+
+    impl Error for ClientKeyError {
+        fn source(&self) -> Option<&(dyn Error + 'static)> {
+            Some(&*self.source)
+        }
+    }
+
+    #[derive(Debug)]
+    pub struct TrustCertError {
+        path: String,
+        source: anyhow::Error,
+    }
+
+    impl TrustCertError {
+        pub fn new(path: &Path, source: anyhow::Error) -> Self {
+            Self {
+                path: path.display().to_string(),
+                source,
+            }
+        }
+    }
+
+    impl std::fmt::Display for TrustCertError {
+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+            write!(f, "Something failed with trust certificate {}", self.path) //: {}", self.path, self.source)
+        }
+    }
+
+    impl Error for TrustCertError {
+        fn source(&self) -> Option<&(dyn Error + 'static)> {
+            Some(&*self.source)
+        }
+    }
+
+    /*doneFIXME: find out why I got the following error only once.
+      ok it's this https://github.com/seanmonstar/reqwest/issues/1808 and possibly https://github.com/hyperium/hyper/issues/2136  but basically it's because client doesn't expect server to reply because client didn't request(HTTP1) anything first in order to expect a reply, so if both  reply and close  are happening on server then some race happens where mostly closed connection is handled first, even tho the reply itself is already gotten.
+     * https://github.com/seanmonstar/reqwest/issues/2649
+     * https://github.com/hyperium/hyper-util/pull/184
+     *
+     $ spacetime server ping slocal --cert ../my/spacetimedb-cert-gen/ca.crt
+     WARNING: This command is UNSTABLE and subject to breaking changes.
+
+     Adding trusted root cert(for server verification): subject=CN=MyLocalCA, issuer=CN=MyLocalCA, serial=359627719638463223090969970838819027680303337392, expires=Mar 24 13:24:50 2035 +00:00, fingerprint=25bb314ec76db8ab97f225011ec24dd0bca8aff470cb21c812600a8f4ed0cca7
+     Error: Failed sending request to https://127.0.0.1:3000: Failed to construct or send the HTTP request, source: Some(
+     hyper_util::client::legacy::Error(
+     Canceled,
+     hyper::Error(
+     Canceled,
+     hyper::Error(
+     Io,
+     Custom {
+     kind: Other,
+     error: Error {
+     code: ErrorCode(
+     1,
+     ),
+     cause: Some(
+     Ssl(
+     ErrorStack(
+     [
+     Error {
+     code: 167773276,
+     library: "SSL routines",
+     function: "ssl3_read_bytes",
+     reason: "tlsv13 alert certificate required",
+     file: "ssl/record/rec_layer_s3.c",
+     line: 908,
+     data: "SSL alert number 116",
+     },
+     ],
+     ),
+     ),
+     ),
+     },
+     },
+     ),
+     ),
+     ),
+     )
+
+
+     XXX: and why I get instead this:
+
+     $ spacetime server ping slocal --cert ../my/spacetimedb-cert-gen/ca.crt
+     WARNING: This command is UNSTABLE and subject to breaking changes.
+
+     Adding trusted root cert(for server verification): subject=CN=MyLocalCA, issuer=CN=MyLocalCA, serial=359627719638463223090969970838819027680303337392, expires=Mar 24 13:24:50 2035 +00:00, fingerprint=25bb314ec76db8ab97f225011ec24dd0bca8aff470cb21c812600a8f4ed0cca7
+     Error: Failed sending request to https://127.0.0.1:3000: Server closed the connection because you did NOT provide the args --client-cert and --client-key for mutual TLS (mTLS), source: Some(
+     hyper_util::client::legacy::Error(
+     SendRequest,
+     hyper::Error(
+     ChannelClosed,
+     ),
+     ),
+     )
+    */
+    pub fn map_request_error<E: Into<anyhow::Error>>(
+        e: E,
+        url: &String,
+        client_cert_path: Option<&Path>,
+        client_key_path: Option<&Path>,
+    ) -> anyhow::Error {
+        let e = e.into();
+        //let mut last_message:String = "Unknown error occurred".to_string();
+        new_string!(last_message, "An error occurred that wasn't mapped into something better by map_request_error.", 512);
+        //    fn example<E: std::fmt::Display>(e: &E) -> String {
+        //        format!("err: {}, Error type: {}", e, std::any::type_name::<E>())
+        //    }
+        //    set_string!(last_message, &format!("{}", example(&e)));
+        let mut max_specificity = 0; // 0: Unknown, 1: reqwest, 2: ChannelClosed, 3: tlsv13 alert, 4: file
+
+        /*Normally Similar: For most types, &e and e.as_ref() are equivalent, as AsRef often just returns a reference to the type. For example, for String, e.as_ref() returns &String, same as &e.
+          Your Case: For anyhow::Error, e.as_ref() is special:
+
+          &e gives &anyhow::Error, a reference to the struct.
+          e.as_ref() calls anyhow::Error’s AsRef implementation, returning &dyn std::error::Error + Send + Sync + 'static. This dynamic trait object satisfies the bounds needed for downcast_ref and source, avoiding E0277.
+          */
+        // Summary: e.as_ref() in map_request_error converts e: anyhow::Error to &dyn std::error::Error, enabling safe chain traversal.
+        // Traverse the error chain using e.as_ref()
+        let mut current: Option<&dyn std::error::Error> = Some(e.as_ref());
+        while let Some(err) = current {
+            // Check hyper::Error
+            if let Some(hyper_err) = err.downcast_ref::<hyper::Error>() {
+                if hyper_err.is_closed() {
+                    let msg = (
+                        if client_cert_path.is_none() || client_key_path.is_none() {
+                            "Server closed the connection likely because you did NOT provide the args --client-cert and --client-key for mutual TLS (mTLS) and server requires it, also you need the hyper-util patch which affects hyper/reqwest and makes them not hide connection errors behind ChannelClosed from here: https://github.com/hyperium/hyper-util/pull/184 which means that's why you're seeing this generic error."
+                        } else {
+                            "Connection channel closed unexpectedly (server may be down or misconfigured), you should have this PR https://github.com/hyperium/hyper-util/pull/184 applied to avoid hiding the real reason behind ChannelClosed error(s)."
+                        },
+                        2,
+                    );
+                    if msg.1 > max_specificity {
+                        //last_message = msg.0.to_string();
+                        //last_message. = msg.0.to_string();
+                        set_string!(last_message, msg.0);
+                        max_specificity = msg.1;
+                    }
+                }
+                if let Some(io_err) = hyper_err.source() {
+                    if let Some(ssl_err) = io_err.downcast_ref::<std::io::Error>() {
+                        if let Some(openssl_err) = ssl_err.get_ref() {
+                            if let Some(ssl_error) = openssl_err.downcast_ref::<openssl::ssl::Error>() {
+                                // BEGIN: Refactored OpenSSL error stack iteration to check multiple reasons
+                                if let Some(stack) = ssl_error.ssl_error() {
+                                    for e in stack.errors() {
+                                        if e.reason() == Some("tlsv13 alert certificate required") {
+                                            let msg = (
+                                                if client_cert_path.is_none() || client_key_path.is_none() {
+                                                    "You didn't pass the required client certificate(yours) for mTLS, use --client-cert and --client-key 🔒"
+                                                } else {
+                                                    "TLS handshake failed: server requires a valid client certificate(yours) for mTLS 🔒"
+                                                },
+                                                3,
+                                            );
+                                            if msg.1 > max_specificity {
+                                                set_string!(last_message, msg.0);
+                                                max_specificity = msg.1;
+                                            }
+                                        }
+                                        if e.reason() == Some("tlsv1 alert unknown ca") {
+                                            assert!(client_cert_path.is_some() && client_key_path.is_some(),"dev error, this should be unreachable: TLS handshake failed: server requires a client certificate for mTLS, but none was provided. Use --client-cert and --client-key with valid files.");
+                                            let msg = (
+                                                    "TLS handshake failed: the server does not trust the CA that signed your client certificate. Ensure the server is configured with the correct CA certificate via --client-trust-cert (the CA that signed your client1.crt, e.g., ca4clients.crt)."
+                                                ,
+                                                3,
+                                            );
+                                            if msg.1 > max_specificity {
+                                                set_string!(last_message, msg.0);
+                                                max_specificity = msg.1;
+                                            }
+                                        }//if
+                                    }//for
+                                }//if
+                            }//if
+                        }//if
+                    }//if
+                }//if
+            }//if
+            // Check reqwest::Error
+            else if let Some(reqwest_err) = err.downcast_ref::<reqwest::Error>() {
+                let msg = if reqwest_err.is_connect() {
+                    Some(("Failed to connect to the server (connection refused or network unreachable)", 1))
+                } else if reqwest_err.is_timeout() {
+                    Some(("Request timed out while trying to reach the server", 1))
+                } else if reqwest_err.is_request() {
+                    Some(("Failed to construct or send the HTTP request", 1))
+                } else if reqwest_err.is_body() {
+                    Some(("Error in the request body", 1))
+                } else if reqwest_err.is_decode() {
+                    Some(("Failed to decode the response", 1))
+                } else {
+                    None
+                };
+                if let Some((msg, spec)) = msg {
+                    if spec > max_specificity {
+                        //last_message = msg;
+                        set_string!(last_message, msg);
+                        max_specificity = spec;
+                    }
+                }
+            }
+            // Check custom file errors
+            else if let Some(trust_err) = err.downcast_ref::<TrustCertError>() {
+                let msg = (format!("problem with trust certificate file {}", trust_err.path), 4);
+                if msg.1 > max_specificity {
+                    set_string!(last_message, &msg.0);
+                    max_specificity = msg.1;
+                }
+            }
+            else if let Some(cert_err) = err.downcast_ref::<ClientCertError>() {
+                let msg = (format!("problem with client certificate file {}", cert_err.path), 4);
+                if msg.1 > max_specificity {
+                    set_string!(last_message, &msg.0);
+                    max_specificity = msg.1;
+                }
+            }
+            else if let Some(key_err) = err.downcast_ref::<ClientKeyError>() {
+                let msg = (format!("problem with client private key file {}", key_err.path), 4);
+                if msg.1 > max_specificity {
+                    set_string!(last_message, &msg.0);
+                    max_specificity = msg.1;
+                }
+            }
+
+            current = err.source();
+        }
+        //TODO: see if specificity is needed, and likely get rid of it
+
+        let source_str = match e.source() {
+            Some(err) => format!("{:#?}", err),
+            None => "<no error cause/source>".to_string(),
+        };
+        let message=format!(
+            "(as follows on next lines)\n------- map_request_error ------\nFailed sending request to {}\nerr   : {}\nsource: {}\n----- end -----",
+            url,
+            last_message,
+            source_str,
+        );
+        // Chain the original error with the new message
+        e.context(message)
+    }
+
+    #[macro_export]
+    macro_rules! map_request_error {
+        ($result:expr, $url:expr, $client_cert_path:expr, $client_key_path:expr) => {
+            //using self:: here requires only an use spacetimedb_lib::map_request_error; at call site.
+            //and note how macro and fn name are same.
+            $result.map_err(|e| self::map_request_error(e,
+                    &$url,
+                    $client_cert_path.as_deref(),
+                    $client_key_path.as_deref()
+            ))
+        };
+    }
+
+
+    #[cfg(test)]
+    mod tests {
+        use super::{read_file_limited, MAX_BUF_SIZE};
+        use anyhow::Context;
+        use std::path::Path;
+        use tempfile::NamedTempFile;
+        use tokio::fs::File;
+        use tokio::io::AsyncWriteExt;
+
+        const TEST_MAX_SIZE: usize = 1_048_576; // 1 MiB
+
+        // Tests for MAX_BUF_SIZE multiples (1x, 2x, 3x) with -1, 0, +1 bytes
+        #[tokio::test]
+        async fn test_1x_buf_size_minus_1() {
+            let size = MAX_BUF_SIZE - 1; // 65,535
+            let temp_file = create_test_file(size).await.expect("Failed to create test file");
+            let result = read_file_limited(temp_file.path(), TEST_MAX_SIZE).await;
+            assert!(result.is_ok(), "Expected success for {} bytes, got {:?}", size, result);
+            let data = result.unwrap();
+            assert_eq!(data.len(), size, "Expected {} bytes, got {}", size, data.len());
+        }
+
+        #[tokio::test]
+        async fn test_1x_buf_size() {
+            let size = MAX_BUF_SIZE; // 65,536
+            let temp_file = create_test_file(size).await.expect("Failed to create test file");
+            let result = read_file_limited(temp_file.path(), TEST_MAX_SIZE).await;
+            assert!(result.is_ok(), "Expected success for {} bytes, got {:?}", size, result);
+            let data = result.unwrap();
+            assert_eq!(data.len(), size, "Expected {} bytes, got {}", size, data.len());
+        }
+
+        #[tokio::test]
+        async fn test_1x_buf_size_plus_1() {
+            let size = MAX_BUF_SIZE + 1; // 65,537
+            let temp_file = create_test_file(size).await.expect("Failed to create test file");
+            let result = read_file_limited(temp_file.path(), TEST_MAX_SIZE).await;
+            assert!(result.is_ok(), "Expected success for {} bytes, got {:?}", size, result);
+            let data = result.unwrap();
+            assert_eq!(data.len(), size, "Expected {} bytes, got {}", size, data.len());
+        }
+
+        #[tokio::test]
+        async fn test_2x_buf_size_minus_1() {
+            let size = 2 * MAX_BUF_SIZE - 1; // 131,071
+            let temp_file = create_test_file(size).await.expect("Failed to create test file");
+            let result = read_file_limited(temp_file.path(), TEST_MAX_SIZE).await;
+            assert!(result.is_ok(), "Expected success for {} bytes, got {:?}", size, result);
+            let data = result.unwrap();
+            assert_eq!(data.len(), size, "Expected {} bytes, got {}", size, data.len());
+        }
+
+        #[tokio::test]
+        async fn test_2x_buf_size() {
+            let size = 2 * MAX_BUF_SIZE; // 131,072
+            let temp_file = create_test_file(size).await.expect("Failed to create test file");
+            let result = read_file_limited(temp_file.path(), TEST_MAX_SIZE).await;
+            assert!(result.is_ok(), "Expected success for {} bytes, got {:?}", size, result);
+            let data = result.unwrap();
+            assert_eq!(data.len(), size, "Expected {} bytes, got {}", size, data.len());
+        }
+
+        #[tokio::test]
+        async fn test_2x_buf_size_plus_1() {
+            let size = 2 * MAX_BUF_SIZE + 1; // 131,073
+            let temp_file = create_test_file(size).await.expect("Failed to create test file");
+            let result = read_file_limited(temp_file.path(), TEST_MAX_SIZE).await;
+            assert!(result.is_ok(), "Expected success for {} bytes, got {:?}", size, result);
+            let data = result.unwrap();
+            assert_eq!(data.len(), size, "Expected {} bytes, got {}", size, data.len());
+        }
+
+        #[tokio::test]
+        async fn test_3x_buf_size_minus_1() {
+            let size = 3 * MAX_BUF_SIZE - 1; // 196,607
+            let temp_file = create_test_file(size).await.expect("Failed to create test file");
+            let result = read_file_limited(temp_file.path(), TEST_MAX_SIZE).await;
+            assert!(result.is_ok(), "Expected success for {} bytes, got {:?}", size, result);
+            let data = result.unwrap();
+            assert_eq!(data.len(), size, "Expected {} bytes, got {}", size, data.len());
+        }
+
+        #[tokio::test]
+        async fn test_3x_buf_size() {
+            let size = 3 * MAX_BUF_SIZE; // 196,608
+            let temp_file = create_test_file(size).await.expect("Failed to create test file");
+            let result = read_file_limited(temp_file.path(), TEST_MAX_SIZE).await;
+            assert!(result.is_ok(), "Expected success for {} bytes, got {:?}", size, result);
+            let data = result.unwrap();
+            assert_eq!(data.len(), size, "Expected {} bytes, got {}", size, data.len());
+        }
+
+        #[tokio::test]
+        async fn test_3x_buf_size_plus_1() {
+            let size = 3 * MAX_BUF_SIZE + 1; // 196,609
+            let temp_file = create_test_file(size).await.expect("Failed to create test file");
+            let result = read_file_limited(temp_file.path(), TEST_MAX_SIZE).await;
+            assert!(result.is_ok(), "Expected success for {} bytes, got {:?}", size, result);
+            let data = result.unwrap();
+            assert_eq!(data.len(), size, "Expected {} bytes, got {}", size, data.len());
+        }
+
+        // Helper to create a file with a specific size
+        async fn create_test_file(size: usize) -> anyhow::Result<NamedTempFile> {
+            let temp_file = NamedTempFile::new().context("Failed to create temp file")?;
+            let mut file = File::create(temp_file.path()).await.context("Failed to open temp file")?;
+            let data = vec![0u8; size];
+            file.write_all(&data).await.context("Failed to write to temp file")?;
+            file.flush().await.context("Failed to flush temp file")?;
+            Ok(temp_file)
+        }
+
+        #[tokio::test]
+        async fn test_max_allowed_size() {
+            // Test a file of 1,048,575 bytes (TEST_MAX_SIZE - 1, should succeed)
+            let temp_file = create_test_file(TEST_MAX_SIZE - 1)
+                .await
+                .expect("Failed to create test file");
+            let result = read_file_limited(temp_file.path(), TEST_MAX_SIZE).await;
+            assert!(result.is_ok(), "Expected success for {} bytes, got {:?}", TEST_MAX_SIZE - 1, result);
+            let data = result.unwrap();
+            assert_eq!(data.len(), TEST_MAX_SIZE - 1, "Expected {} bytes, got {}", TEST_MAX_SIZE - 1, data.len());
+        }
+
+        #[tokio::test]
+        async fn test_exactly_max_size() {
+            // Test a file of 1,048,576 bytes (TEST_MAX_SIZE, should succeed)
+            let temp_file = create_test_file(TEST_MAX_SIZE)
+                .await
+                .expect("Failed to create test file");
+            let result = read_file_limited(temp_file.path(), TEST_MAX_SIZE).await;
+            assert!(result.is_ok(), "Expected success for {} bytes, got {:?}", TEST_MAX_SIZE, result);
+            let data = result.unwrap();
+            assert_eq!(data.len(), TEST_MAX_SIZE, "Expected {} bytes, got {}", TEST_MAX_SIZE, data.len());
+        }
+
+#[tokio::test]
+        async fn test_dev_zero() {
+            // Test /dev/zero (special file, should fail due to extra data)
+            let path = Path::new("/dev/zero");
+            if path.exists() {
+                let result = read_file_limited(path, TEST_MAX_SIZE).await;
+                assert!(result.is_err(), "Expected failure for /dev/zero, got {:?}", result);
+                let err = result.unwrap_err().to_string();
+                assert!(
+                    err.contains("has more data"),
+                    "Expected extra data error, got {}",
+                    err
+                );
+            } else {
+                eprintln!("Skipping /dev/zero test: file does not exist");
+            }
+        }
+
+        #[tokio::test]
+        async fn test_empty_file() {
+            // Test an empty file (0 bytes, should succeed)
+            let temp_file = NamedTempFile::new().expect("Failed to create temp file");
+            let result = read_file_limited(temp_file.path(), TEST_MAX_SIZE).await;
+            assert!(result.is_ok(), "Expected success for empty file, got {:?}", result);
+            let data = result.unwrap();
+            assert_eq!(data.len(), 0, "Expected 0 bytes, got {}", data.len());
+        }
+
+        #[tokio::test]
+        async fn test_small_file() {
+            // Test a small file (2 KiB, should succeed)
+            let size = 2 * 1024; // 2 KiB
+            let temp_file = create_test_file(size).await.expect("Failed to create test file");
+            let result = read_file_limited(temp_file.path(), TEST_MAX_SIZE).await;
+            assert!(result.is_ok(), "Expected success for {} bytes, got {:?}", size, result);
+            let data = result.unwrap();
+            assert_eq!(data.len(), size, "Expected {} bytes, got {}", size, data.len());
+        }
+
+        #[tokio::test]
+        async fn test_content_verification() {
+            // Test files of various sizes, verifying content matches expected pattern
+            let sizes = [
+                0,                 // Empty file
+                1,                 // Single byte
+                1024,              // 1 KiB
+                MAX_BUF_SIZE - 1,  // 65,535 (1x MAX_BUF_SIZE - 1)
+                MAX_BUF_SIZE,      // 65,536 (1x MAX_BUF_SIZE)
+                MAX_BUF_SIZE + 1,  // 65,537 (1x MAX_BUF_SIZE + 1)
+                2 * MAX_BUF_SIZE - 1, // 131,071 (2x MAX_BUF_SIZE - 1)
+                2 * MAX_BUF_SIZE,     // 131,072 (2x MAX_BUF_SIZE)
+                2 * MAX_BUF_SIZE + 1, // 131,073 (2x MAX_BUF_SIZE + 1)
+                3 * MAX_BUF_SIZE - 1, // 196,607 (3x MAX_BUF_SIZE - 1)
+                3 * MAX_BUF_SIZE,     // 196,608 (3x MAX_BUF_SIZE)
+                3 * MAX_BUF_SIZE + 1, // 196,609 (3x MAX_BUF_SIZE + 1)
+            ];
+
+            for &size in sizes.iter() {
+                // Create file with deterministic content
+                let temp_file = NamedTempFile::new().expect("Failed to create temp file");
+                //{
+                    let mut file = File::create(temp_file.path())
+                    .await
+                    .expect("Failed to open temp file");
+                    let mut data: Vec<u8> = Vec::with_capacity(size);
+                    for i in 0..size {
+                        data.push((i % 256) as u8); // Repeating pattern [0, 1, 2, ..., 255, 0, ...]
+                    }
+                    file.write_all(&data)
+                        .await
+                        .expect("Failed to write to temp file");
+                    //file.flush().await.expect("Failed to flush temp file");
+                drop(file); // Explicitly close the file
+                //}//drop 'file' which should close it.
+
+                // Read file and verify content
+                let result = read_file_limited(temp_file.path(), TEST_MAX_SIZE).await;
+                assert!(
+                    result.is_ok(),
+                    "Expected success for {} bytes, got {:?}",
+                    size,
+                    result
+                );
+                let read_data = result.unwrap();
+                assert_eq!(
+                    read_data.len(),
+                    size,
+                    "Expected {} bytes, got {} bytes",
+                    size,
+                    read_data.len()
+                );
+                for (i, &byte) in read_data.iter().enumerate() {
+                    assert_eq!(
+                        byte,
+                        (i % 256) as u8,
+                        "Content mismatch at index {} for size {}",
+                        i,
+                        size
+                    );
+                }
+            }
+        }
+
+        use zeroize::ZeroizeOnDrop;
+        use super::{ZeroizingVec, ZeroizingBuffer};
+
+        #[test]
+        fn test_has_zeroize_on_drop() {
+            const fn assert_zeroize_on_drop<T: ZeroizeOnDrop>() {}
+            assert_zeroize_on_drop::<ZeroizingVec>();
+            assert_zeroize_on_drop::<ZeroizingBuffer>();
+        }
+    }//mod tests
+
+} // end of non_wasm! macro call
diff --git a/crates/sdk/Cargo.toml b/crates/sdk/Cargo.toml
index 9daa2a983..25c2ff47a 100644
--- a/crates/sdk/Cargo.toml
+++ b/crates/sdk/Cargo.toml
@@ -29,6 +29,18 @@ prometheus.workspace = true
 rand.workspace = true
 tokio.workspace = true
 tokio-tungstenite.workspace = true
+#rustls = "0.23"
+rustls.workspace = true
+#rustls-pemfile = "2.2.0"
+#native-tls = "0.2"  # Explicitly add for Connector::NativeTls
+native-tls.workspace = true
+#anyhow="1.0"
+anyhow.workspace=true
+clap.workspace=true
+rustls-pemfile.workspace = true
+#This pki-types crate is actually a dep of pemfile above, but we want a feature enabled, so:
+rustls-pki-types.workspace=true #needed here, to enable its 'trace_drop_and_zeroize' feature
+zeroize.workspace=true
 
 [dev-dependencies]
 # for quickstart-chat and cursive-chat examples
@@ -39,3 +51,9 @@ futures-channel.workspace = true
 
 # for tests
 spacetimedb-testing = { path = "../testing" }
+
+##no effect, if here or in root dir aka workspace Cargo.toml
+#[patch.crates-io]
+#rustls-pki-types = { path = "/home/user/SOURCE/github/modified_forks/pki-types" }
+#hyper-util = { path ="/home/user/SOURCE/my/channelclosed.reqwest/hyper-util" }
+
diff --git a/crates/sdk/examples/quickstart-chat/main.rs b/crates/sdk/examples/quickstart-chat/main.rs
index e04ff9cb3..041ae1650 100644
--- a/crates/sdk/examples/quickstart-chat/main.rs
+++ b/crates/sdk/examples/quickstart-chat/main.rs
@@ -5,11 +5,86 @@ use module_bindings::*;
 
 use spacetimedb_sdk::{credentials, DbContext, Error, Event, Identity, Status, Table, TableWithPrimaryKey};
 
+use clap::{Arg, Command};
+use std::path::PathBuf;
+
+
 // ## Define the main function
 
 fn main() {
+     // Parse command-line arguments with clap
+    let matches = Command::new("quickstart-chat")
+        .arg(
+            Arg::new("trust-server-cert")
+                .long("trust-server-cert")
+                .alias("cert")
+                .value_name("FILE")
+                .value_parser(clap::value_parser!(PathBuf))
+                .help("Path to PEM file containing certificates to trust for the server"),
+        )
+        .arg(
+            Arg::new("client-cert")
+                .long("client-cert")
+                .value_name("FILE")
+                .value_parser(clap::value_parser!(PathBuf))
+                .help("Path to the client’s certificate (PEM) for mTLS"),
+        )
+        .arg(
+            Arg::new("client-key")
+                .long("client-key")
+                .value_name("FILE")
+                .value_parser(clap::value_parser!(PathBuf))
+                .requires("client-cert")
+                .help("Path to the client’s private key (PEM) for mTLS"),
+        )
+        .arg(
+            Arg::new("trust-system-certs")
+                .long("trust-system-certs")
+                .action(clap::ArgAction::SetTrue)
+                .conflicts_with("no-trust-system-certs")
+                .help("Use system root certificates (default)"),
+        )
+        .arg(
+            Arg::new("no-trust-system-certs")
+                .long("no-trust-system-certs")
+                .alias("empty-trust-store")
+                .action(clap::ArgAction::SetTrue)
+                .conflicts_with("trust-system-certs")
+                .help("Use empty trust store (requires --trust-server-cert)"),
+        )
+        .get_matches();
+    //FIXME: check args./aliases
+
+    //FIXME: see if this 'if' makes sense:
+    // Validate no-trust-system-certs
+    if matches.get_flag("no-trust-system-certs") && !matches.contains_id("trust-server-cert") {
+        eprintln!("--no-trust-system-certs requires --trust-server-cert");
+        std::process::exit(1);
+    }
+
+//    // ### Parse command-line arguments for --cert into a PathBuf
+//    let args: Vec<String> = std::env::args().collect();
+//    let cert_path: Option<PathBuf> = args.iter()
+//        .position(|arg| arg == "--cert")
+//        .map(|i| args.get(i + 1).expect("Missing certificate path after --cert"))
+//        .map(|s| PathBuf::from(s));
+//    // Connect to the database with optional cert
+//    let ctx = connect_to_db(cert_path);
+
+    // Extract arguments
+    let trust_server_cert = matches.get_one::<PathBuf>("trust-server-cert").cloned();
+    let client_cert = matches.get_one::<PathBuf>("client-cert").cloned();
+    let client_key = matches.get_one::<PathBuf>("client-key").cloned();
+    let trust_system_certs = if matches.get_flag("no-trust-system-certs") {
+        Some(false)
+    } else if matches.get_flag("trust-system-certs") {
+        Some(true)
+    } else {
+        None // None here but deeper this means 'true', in db_connection.rs
+    };
+
     // Connect to the database
-    let ctx = connect_to_db();
+    let ctx = connect_to_db(trust_server_cert, client_cert, client_key, trust_system_certs);
 
     // Register callbacks to run in response to database events.
     register_callbacks(&ctx);
@@ -22,18 +97,36 @@ fn main() {
 
     // Handle CLI input
     user_input_loop(&ctx);
+    //gracefully exit, if Ctrl+D was pressed (Ctrl+Z on Windows)
+    let _=ctx.disconnect();
+    const TIMEOUT:u64=3;
+    let duration = std::time::Duration::from_secs(TIMEOUT);
+    std::thread::sleep(duration);
+    //not reached:
+    println!("Failed to disconnect from the database! Waited {} seconds.", TIMEOUT);
 }
 
 // ## Connect to the database
 
-/// The URI of the SpacetimeDB instance hosting our chat module.
-const HOST: &str = "http://localhost:3000";
+/// The host and port, without scheme, of the SpacetimeDB instance hosting our chat module.
+const HOST_PORT: &str = "localhost:3000";
 
 /// The module name we chose when we published our module.
 const DB_NAME: &str = "quickstart-chat";
 
 /// Load credentials from a file and connect to the database.
-fn connect_to_db() -> DbConnection {
+fn connect_to_db(
+    cert_path: Option<PathBuf>,
+    client_cert: Option<PathBuf>,
+    client_key: Option<PathBuf>,
+    trust_system_certs: Option<impl Into<bool>>
+    ) -> DbConnection {
+    // ### Construct URI with scheme based on cert presence
+    let expects_https=cert_path.is_some() || client_cert.is_some() || client_key.is_some();
+    let scheme = if expects_https { "https" } else { "http" };
+    let uri = format!("{}://{}", scheme, HOST_PORT);
+
+//    let mut builder=
     DbConnection::builder()
         // Register our `on_connect` callback, which will save our auth token.
         .on_connect(on_connected)
@@ -48,7 +141,23 @@ fn connect_to_db() -> DbConnection {
         // Set the database name we chose when we called `spacetime publish`.
         .with_module_name(DB_NAME)
         // Set the URI of the SpacetimeDB host that's running our database.
-        .with_uri(HOST)
+        .with_uri(&uri)
+//;    // ### Add trusted cert if provided
+//    if let Some(cert_path) = cert_path {
+//    //XXX: we don't wanna do this(that's why it's accepting Option instead):
+//        builder = builder.with_trusted_cert(cert_path);
+//    }
+//     // Finalize configuration and connect!
+//     builder.build()
+//         .expect("Failed to connect")
+        // ### Add trusted cert if provided
+        .with_trusted_cert(cert_path)
+        // Add client identity (TLS)
+        .with_client_cert(client_cert)
+        .with_client_key(client_key)
+        // Configure trust store
+        .with_trust_system_certs(trust_system_certs)
+
         // Finalize configuration and connect!
         .build()
         .expect("Failed to connect")
diff --git a/crates/sdk/src/db_connection.rs b/crates/sdk/src/db_connection.rs
index e1e4133e3..b3c955a8e 100644
--- a/crates/sdk/src/db_connection.rs
+++ b/crates/sdk/src/db_connection.rs
@@ -44,6 +44,7 @@ use tokio::{
     runtime::{self, Runtime},
     sync::Mutex as TokioMutex,
 };
+use std::path::PathBuf;
 
 pub(crate) type SharedCell<T> = Arc<StdMutex<T>>;
 
@@ -748,6 +749,11 @@ pub struct DbConnectionBuilder<M: SpacetimeModule> {
     on_disconnect: Option<OnDisconnectCallback<M>>,
 
     params: WsParams,
+
+    trusted_cert: Option<std::path::PathBuf>,
+    client_cert: Option<std::path::PathBuf>,
+    client_key: Option<std::path::PathBuf>,
+    trust_system_certs: Option<bool>,
 }
 
 /// This process's global connection ID, which will be attacked to all connections it makes.
@@ -794,6 +800,10 @@ impl<M: SpacetimeModule> DbConnectionBuilder<M> {
             on_connect_error: None,
             on_disconnect: None,
             params: <_>::default(),
+            trusted_cert: None,
+            client_cert: None,
+            client_key: None,
+            trust_system_certs: None,
         }
     }
 
@@ -841,6 +851,11 @@ but you must call one of them, or else the connection will never progress.
                 self.token.as_deref(),
                 get_connection_id(),
                 self.params,
+                self.trusted_cert.as_ref(),
+                self.client_cert.as_ref(),
+                self.client_key.as_ref(),
+                //XXX: trust system/root store by default, for clients when verifying server certs!
+                self.trust_system_certs.unwrap_or(true),
             ))
         })
         .map_err(|source| crate::Error::FailedToConnect {
@@ -892,6 +907,34 @@ but you must call one of them, or else the connection will never progress.
         self
     }
 
+    pub fn with_trusted_cert(mut self, cert: Option<impl Into<std::path::PathBuf>>) -> Self {
+        self.trusted_cert = cert.map(|c| c.into());
+        self
+    }
+
+    pub fn with_client_cert(mut self, cert: Option<impl Into<PathBuf>>) -> Self {
+        self.client_cert = cert.map(|c| c.into());
+        self
+    }
+
+    pub fn with_client_key(mut self, key: Option<impl Into<PathBuf>>) -> Self {
+        self.client_key = key.map(|c| c.into());
+        self
+    }
+
+//    pub fn with_trust_system_certs(mut self, trust: bool) -> Self {
+//        self.trust_system_certs = trust;
+//        self
+//    }
+//    pub fn with_trust_system_certs(mut self, trust: Option<impl Into<Option<bool>>>) -> Self {
+//        self.trust_system_certs = trust.map(|t| t.into()).unwrap_or(None);
+//        self
+//    }
+    pub fn with_trust_system_certs(mut self, trust: Option<impl Into<bool>>) -> Self {
+        self.trust_system_certs = trust.map(|t| t.into());
+        self
+    }
+
     /// Set the name or identity of the remote module.
     pub fn with_module_name(mut self, name_or_identity: impl Into<String>) -> Self {
         self.module_name = Some(name_or_identity.into());
diff --git a/crates/sdk/src/websocket.rs b/crates/sdk/src/websocket.rs
index 436520d50..4f022726d 100644
--- a/crates/sdk/src/websocket.rs
+++ b/crates/sdk/src/websocket.rs
@@ -21,13 +21,14 @@ use tokio::task::JoinHandle;
 use tokio::time::Instant;
 use tokio::{net::TcpStream, runtime};
 use tokio_tungstenite::{
-    connect_async_with_config,
     tungstenite::client::IntoClientRequest,
     tungstenite::protocol::{Message as WebSocketMessage, WebSocketConfig},
-    MaybeTlsStream, WebSocketStream,
+    MaybeTlsStream,
+    WebSocketStream,
 };
 
 use crate::metrics::CLIENT_METRICS;
+use zeroize::Zeroize;
 
 #[derive(Error, Debug, Clone)]
 pub enum UriError {
@@ -90,6 +91,18 @@ pub(crate) struct WsConnection {
     sock: WebSocketStream<MaybeTlsStream<TcpStream>>,
 }
 
+impl From<anyhow::Error> for WsError {
+    fn from(err: anyhow::Error) -> Self {
+        WsError::Tungstenite {
+            uri: Uri::default(), // Fallback; context provides real URI
+            source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                std::io::ErrorKind::Other,
+                err.to_string(),
+            ))),
+        }
+    }
+}
+
 fn parse_scheme(scheme: Option<Scheme>) -> Result<Scheme, UriError> {
     Ok(match scheme {
         Some(s) => match s.as_str() {
@@ -207,19 +220,160 @@ impl WsConnection {
         token: Option<&str>,
         connection_id: ConnectionId,
         params: WsParams,
+        trusted_cert: Option<&std::path::PathBuf>,
+        client_cert: Option<&std::path::PathBuf>,
+        client_key: Option<&std::path::PathBuf>,
+        trust_system_certs: bool,
     ) -> Result<Self, WsError> {
         let req = make_request(host, db_name, token, connection_id, params)?;
 
         // Grab the URI for error-reporting.
         let uri = req.uri().clone();
 
-        let (sock, _): (WebSocketStream<MaybeTlsStream<TcpStream>>, _) = connect_async_with_config(
+        let host = uri.clone(); //shadow, and it's thus wss:// not https://
+        use std::sync::Arc;
+        use tokio::net::TcpStream;
+        use tokio_tungstenite::{client_async_tls_with_config, Connector, MaybeTlsStream, WebSocketStream};
+
+        let host_str = host.host().ok_or(WsError::UriError(UriError::InvalidUri {
+            source: Arc::new("No host in URI".parse::<Uri>().unwrap_err().into()),
+        }))?;
+        let port = host.port_u16().ok_or(WsError::UriError(UriError::InvalidUri {
+            source: Arc::new("No port specified in URI".parse::<Uri>().unwrap_err().into()),
+        }))?;
+        if port == 0 { // || port > 65535 { //it's u16
+            return Err(WsError::UriError(UriError::InvalidUri {
+                source: Arc::new(format!("Invalid port: {}", port).parse::<Uri>().unwrap_err().into()),
+            }));
+        }
+
+        let tcp_stream = TcpStream::connect((host_str, port))
+            .await
+            .map_err(|source| WsError::Tungstenite {
+                uri: uri.clone(),
+                source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(source)),
+            })?;
+
+        let connector = if host.scheme_str() == Some("wss") {
+            //FIXME: --cert implies wss, or do we want to allow --cert even for ws instead of error-ing!
+            let mut builder = native_tls::TlsConnector::builder();
+
+            // Validate trust store
+            if !trust_system_certs && trusted_cert.is_none() {
+                return Err(WsError::Tungstenite {
+                    uri: uri.clone(),
+                    source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                                std::io::ErrorKind::Other,
+                                "--no-trust-system-root-store requires --trust-server-cert",
+                    ))),
+                });
+            }
+            if !trust_system_certs {
+                eprintln!("Not trusting system/root cert store.");
+                builder.disable_built_in_roots(true);
+            }
+
+            if let Some(cert_path) = trusted_cert {
+                // This is the server's self-signed cert or local CA's cert that signed the server's cert.
+                let cert_data = spacetimedb_lib::read_file_limited(cert_path, spacetimedb_lib::MAX_CERT_BUNDLE_SIZE)
+                    .await?;
+                //FIXME: fix this and 2 more below.
+//                    .map_err(|e| WsError::Tungstenite {
+//                        uri: uri.clone(),
+//                        source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(e)),
+//                    })?;
+                let certs = rustls_pemfile::certs(&mut std::io::Cursor::new(cert_data))
+                    .collect::<Result<Vec<_>, _>>()
+                    .map_err(|e| WsError::Tungstenite {
+                        uri: uri.clone(),
+                        source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                                    std::io::ErrorKind::Other,
+                                    format!("Failed to parse trust certificates: {}", e),
+                        ))),
+                    })?;
+                if certs.is_empty() {
+                    return Err(WsError::Tungstenite {
+                        uri: uri.clone(),
+                        source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                                    std::io::ErrorKind::Other,
+                                    format!("No valid certificates in {}", cert_path.display()),
+                        ))),
+                    });
+                }//if
+                for cert in certs {
+                    builder
+                        .add_root_certificate(native_tls::Certificate::from_der(&cert).map_err(|e| WsError::Tungstenite {
+                            uri: uri.clone(),
+                            source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                                        std::io::ErrorKind::Other,
+                                        e,
+                            ))),
+                        })?);
+                }//for
+            }//if
+
+            // Configure mTLS
+            if let Some(cert_path) = client_cert {
+                let key_path = client_key.ok_or_else(|| WsError::Tungstenite {
+                    uri: uri.clone(),
+                    source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                                std::io::ErrorKind::Other,
+                                "--client-key is required with --client-cert",
+                    ))),
+                })?;
+                let cert_data = spacetimedb_lib::read_file_limited(cert_path, spacetimedb_lib::MAX_CERT_BUNDLE_SIZE)
+                    .await?;
+//                    .map_err(|e| WsError::Tungstenite {
+//                        uri: uri.clone(),
+//                        source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(e)),
+//                    })?;
+                let mut key_data = spacetimedb_lib::read_file_limited(key_path, spacetimedb_lib::MAX_KEY_FILE_SIZE)
+                    .await?;
+//                    .map_err(|e| WsError::Tungstenite {
+//                        uri: uri.clone(),
+//                        source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(e)),
+//                    })?;
+                //use anyhow::Context;
+                let identity = native_tls::Identity::from_pkcs8(&cert_data, &key_data)
+//                    .context("Failed to parse client cert/key")?;
+//                    //XXX: that shows: error: "Failed to parse client cert/key" only!
+                    .map_err(|e| WsError::Tungstenite {
+                    uri: uri.clone(),
+                    //this shows: error: "Failed to parse client cert/key: expected PKCS#8 PEM"
+                    source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                                std::io::ErrorKind::Other,
+                                // {:#?} here would show only "NotPkcs8"
+                                // {} here shows "expected PKCS#8 PEM"
+                                format!("Failed to parse client cert/key: {}", e),
+                    //TODO: make better error msgs like these in other places that use .context()
+                    ))),
+                })?;
+                builder.identity(identity);
+                key_data.zeroize();
+            } //if
+
+            let tls_connector = builder.build().map_err(|e| WsError::Tungstenite {
+                uri: uri.clone(),
+                source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                    std::io::ErrorKind::Other,
+                    e,
+                ))),
+            })?;
+            Some(Connector::NativeTls(tls_connector))
+        } else {
+            //This is probably just ws:// ie. from http:// aka plaintext non-TLS
+            //eprintln!("!!! Unexpected non-wss:// scheme, is: {}", uri);
+            None
+        };
+
+        let (sock, _): (WebSocketStream<MaybeTlsStream<TcpStream>>, _) = client_async_tls_with_config(
             req,
+            tcp_stream,
             // TODO(kim): In order to be able to replicate module WASM blobs,
             // `cloud-next` cannot have message / frame size limits. That's
             // obviously a bad default for all other clients, though.
             Some(WebSocketConfig::default().max_frame_size(None).max_message_size(None)),
-            false,
+            connector
         )
         .await
         .map_err(|source| WsError::Tungstenite {
@@ -231,7 +385,7 @@ impl WsConnection {
             connection_id,
             sock,
         })
-    }
+    } //connect(
 
     pub(crate) fn parse_response(bytes: &[u8]) -> Result<ServerMessage<BsatnFormat>, WsError> {
         let (compression, bytes) = bytes.split_first().ok_or(WsError::EmptyMessage)?;
diff --git a/crates/standalone/Cargo.toml b/crates/standalone/Cargo.toml
index a1583855c..642041ac3 100644
--- a/crates/standalone/Cargo.toml
+++ b/crates/standalone/Cargo.toml
@@ -30,6 +30,25 @@ spacetimedb-table.workspace = true
 anyhow.workspace = true
 async-trait.workspace = true
 axum.workspace = true
+
+# Add this for TLS support
+#axum-server = { version = "0.7.2", features = ["tls-rustls"] }
+axum-server.workspace=true
+#rustls-platform-verifier.workspace=true
+rustls-native-certs.workspace=true
+x509-parser.workspace=true
+sha2.workspace=true
+zeroize.workspace=true
+
+#ring = "0.17"  # explicitly add this for the CryptoProvider, even tho it's included transitively.
+ring.workspace=true
+#rustls= { version="0.23", default-features = true, features=[ "ring" ] }
+rustls.workspace=true
+#rustls-pemfile = "2.2"
+rustls-pemfile.workspace=true
+#This pki-types crate is actually a dep of pemfile above, but we want a feature enabled, so:
+rustls-pki-types.workspace=true #needed here, to enable its 'trace_drop_and_zeroize' feature
+
 clap = { workspace = true, features = ["derive", "string"] }
 dirs.workspace = true
 futures.workspace = true
diff --git a/crates/standalone/src/subcommands/start.rs b/crates/standalone/src/subcommands/start.rs
index e7c2bb69c..71e448ba7 100644
--- a/crates/standalone/src/subcommands/start.rs
+++ b/crates/standalone/src/subcommands/start.rs
@@ -1,4 +1,9 @@
+use zeroize::Zeroize;
 use std::sync::Arc;
+use std::path::Path;
+use std::path::PathBuf;
+use rustls::pki_types::{CertificateDer, PrivateKeyDer};
+use rustls::pki_types::PrivatePkcs8KeyDer;
 
 use crate::StandaloneEnv;
 use anyhow::Context;
@@ -13,7 +18,10 @@ use spacetimedb_client_api::routes::database::DatabaseRoutes;
 use spacetimedb_client_api::routes::router;
 use spacetimedb_paths::cli::{PrivKeyPath, PubKeyPath};
 use spacetimedb_paths::server::ServerDataDir;
-use tokio::net::TcpListener;
+
+pub use spacetimedb_lib::read_file_limited;
+pub use spacetimedb_lib::MAX_CERT_BUNDLE_SIZE;
+pub use spacetimedb_lib::MAX_KEY_FILE_SIZE;
 
 pub fn cli() -> clap::Command {
     clap::Command::new("start")
@@ -72,9 +80,170 @@ pub fn cli() -> clap::Command {
                 "The maximum size of the page pool in bytes. Should be a multiple of 64KiB. The default is 8GiB.",
             ),
         )
+        .arg(spacetimedb_lib::client_trust_cert())
+        .arg(spacetimedb_lib::client_trust_system_root_store())
+        .arg(spacetimedb_lib::client_no_trust_system_root_store())
+        .arg(
+            Arg::new("ssl")
+            .long("ssl")
+            .alias("tls")
+            .alias("https")
+            .alias("secure")
+            .action(clap::ArgAction::SetTrue)
+            .help("enables the standalone server to listen in SSL mode, ie. use https instead of http to connect to it. Aliases --tls, --ssl, --secure, or --https. While in this mode, plaintext connections aren't supported, only SSL/TLS.")
+        )
+        .arg(
+//            spacetimedb_lib::cert()
+            clap::Arg::new("server-cert")
+            .long("server-cert")
+            .alias("cert")
+            .alias("server-public-cert")
+            .value_name("FILE")
+            .action(clap::ArgAction::Set)
+            .value_parser(clap::value_parser!(std::path::PathBuf))
+            .required(false)
+            .requires("ssl")
+            .help("--cert server.crt: The server sends this to clients during the TLS handshake. ie. server's certificate(in PEM format), which if it's self-signed then this is the file that you must pass to clients via --cert when talking to the server from a client(or the cli), or if signed by a local CA then pass that CA's cert to your clients instead, in order to can trust this server from a client connection. Otherwise, you don't have to pass anything to clients if this cert was signed by a public CA like Let's Encrypt.")
+        )
+        .arg(
+            Arg::new("server-key")
+            .long("server-key")
+            .alias("server-private-key")
+            .alias("private-key")
+            .alias("key")
+            .requires("ssl")
+            .requires("server-cert")
+            .value_name("FILE")
+            .action(clap::ArgAction::Set)
+            .value_parser(clap::value_parser!(PathBuf))
+            .help("--key server.key: The server's private key used to decrypt and sign responses. Used for SSL/TLS connections ie. https"))
     // .after_help("Run `spacetime help start` for more detailed information.")
 }
 
+
+/// Loads certificates from a PEM file.
+async fn load_certs(file_path: &Path, expected_num: Option<usize>) -> anyhow::Result<Vec<CertificateDer<'static>>> {
+    let data = read_file_limited(file_path, MAX_CERT_BUNDLE_SIZE).await?;
+    let certs: Vec<CertificateDer<'static>> = rustls_pemfile::certs(&mut std::io::Cursor::new(data))
+        .collect::<Result<Vec<_>, _>>()
+        .map_err(|e| anyhow::anyhow!("Failed to parse certificates from {}: {:?}", file_path.display(), e))?;
+    if certs.len() < 1 {
+        //Err(anyhow::anyhow!("No certificate(s) found in file {}", file_path.display()))
+        eprintln!("WARNING: No certificate(s) found in file {}", file_path.display())
+    }
+//    } else {
+//        Ok(certs)
+//    }
+    if let Some(expected_num)=expected_num {
+        let len=certs.len();
+        if len == expected_num {
+            return Ok(certs);
+        } else {
+            return Err(anyhow::anyhow!("{} certificate(s) found in file {}, but expected {} cert(s) exactly!", len, file_path.display(), expected_num));
+        }
+    } else {
+        return Ok(certs);
+    }
+//    match certs.len() {
+//        0 => Err(anyhow::anyhow!("No certificate(s) found in file {}, expected {} cert(s)", file_path.display(), expected_num)),
+//        expected_num => Ok(certs),
+//        _ => Err(anyhow::anyhow!("Multiple certificates found in file {}; only {} certificate(s) is expected.", file_path.display(), expected_num)),
+//    }
+}
+
+#[allow(dead_code)] // because it's for compile-time check only.
+const fn assert_zeroize<T: zeroize::Zeroize + zeroize::ZeroizeOnDrop>() {}
+const _: () = {
+    assert_zeroize::<PrivatePkcs8KeyDer<'static>>();
+    assert_zeroize::<PrivateKeyDer<'static>>();
+    assert_zeroize::<ring::signature::RsaKeyPair>();
+    assert_zeroize::<ring::signature::EcdsaKeyPair>();
+    assert_zeroize::<ring::signature::Ed25519KeyPair>();
+};
+
+/// Loads a private key from a PEM file.
+async fn load_private_key(file_path: &Path) -> anyhow::Result<PrivateKeyDer<'static>> {
+
+    let mut data = read_file_limited(file_path, MAX_KEY_FILE_SIZE).await?;
+    let result = {
+        let mut cursor = std::io::Cursor::new(&data); // Borrow data
+        assert_zeroize::<PrivatePkcs8KeyDer<'static>>(); // Fails if Zeroize not implemented
+        let mut keys: Vec<PrivatePkcs8KeyDer<'static>> = rustls_pemfile::pkcs8_private_keys(
+            &mut cursor)
+            .collect::<Result<Vec<_>, _>>()
+            .map_err(|e| anyhow::anyhow!("Failed to parse private keys from {}: {:?}", file_path.display(), e))?;
+        match keys.len() {
+            0 => Err(anyhow::anyhow!("No private key found in file {}", file_path.display())),
+            //1 => Ok(PrivateKeyDer::Pkcs8(keys.into_iter().next().unwrap())),
+            1 => Ok(PrivateKeyDer::Pkcs8(keys.pop().unwrap())),
+            _ => Err(anyhow::anyhow!("Multiple private keys found in file {}; only one private key is expected.", file_path.display())),
+        }
+    };
+    data.zeroize();
+    result
+}
+
+/// Creates a custom CryptoProvider with specific cipher suites.
+fn custom_crypto_provider() -> rustls::crypto::CryptoProvider {
+    use rustls::crypto::ring::default_provider;
+    use rustls::crypto::ring::cipher_suite;
+    use rustls::crypto::ring::kx_group;
+
+    let cipher_suites = vec![
+        // TLS 1.3
+        // test with: $ openssl s_client -connect 127.0.0.1:3000 -tls1_3
+        cipher_suite::TLS13_AES_256_GCM_SHA384,
+        cipher_suite::TLS13_AES_128_GCM_SHA256,
+        cipher_suite::TLS13_CHACHA20_POLY1305_SHA256,
+        // TLS 1.2
+        // these are ignored if builder_with_protocol_versions() below doesn't contain TLS 1.2
+        // test with: $ openssl s_client -connect 127.0.0.1:3000 -tls1_2
+        cipher_suite::TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+        cipher_suite::TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+        cipher_suite::TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+        cipher_suite::TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+        cipher_suite::TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+        cipher_suite::TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
+    ];
+
+    // (KX) groups used in TLS handshakes to negotiate the shared secret between client and server.
+    let kx_groups = vec![
+        kx_group::X25519,
+        /*
+           X25519:
+
+           An elliptic curve Diffie-Hellman (ECDH) key exchange algorithm based on Curve25519.
+           Known for high security, speed, and resistance to side-channel attacks.
+           Commonly used in modern TLS (1.2 and 1.3) due to its efficiency and forward secrecy.
+           Preferred by many clients (e.g., browsers) for TLS 1.3 handshakes.
+           */
+        kx_group::SECP256R1,
+        /*
+           SECP256R1 (aka NIST P-256):
+
+           An elliptic curve standardized by NIST, using a 256-bit prime field.
+           Widely supported across TLS 1.2 and 1.3, especially in enterprise environments.
+           Slightly less performant than X25519 but trusted due to long-standing use.
+           Common in certificates signed by older CAs or legacy systems.
+           */
+        kx_group::SECP384R1,
+        /*
+           SECP384R1 (aka NIST P-384):
+
+           Another NIST elliptic curve, using a 384-bit prime field for higher security.
+           Offers stronger cryptographic strength than SECP256R1, at the cost of slower performance.
+           Used in TLS 1.2 and 1.3 when higher assurance is needed (e.g., government systems).
+           Less common than X25519 or SECP256R1 due to computational overhead.
+           */
+    ];
+
+    rustls::crypto::CryptoProvider {
+        cipher_suites,
+        kx_groups,
+        ..default_provider()
+    }
+}
+
 pub async fn exec(args: &ArgMatches) -> anyhow::Result<()> {
     let listen_addr = args.get_one::<String>("listen_addr").unwrap();
     let cert_dir = args.get_one::<spacetimedb_paths::cli::ConfigDir>("jwt_key_dir");
@@ -104,7 +273,7 @@ pub async fn exec(args: &ArgMatches) -> anyhow::Result<()> {
         page_pool_max_size,
     };
 
-    banner();
+    //banner();
     let exe_name = std::env::current_exe()?;
     let exe_name = exe_name.file_name().unwrap().to_str().unwrap();
     println!("{} version: {}", exe_name, env!("CARGO_PKG_VERSION"));
@@ -158,55 +327,166 @@ pub async fn exec(args: &ArgMatches) -> anyhow::Result<()> {
     let extra = axum::Router::new().nest("/health", spacetimedb_client_api::routes::health::router());
     let service = router(&ctx, db_routes, extra).with_state(ctx);
 
-    let tcp = TcpListener::bind(listen_addr).await?;
-    socket2::SockRef::from(&tcp).set_nodelay(true)?;
-    log::debug!("Starting SpacetimeDB listening on {}", tcp.local_addr().unwrap());
-    axum::serve(tcp, service).await?;
+    use std::net::SocketAddr;
+    let addr: SocketAddr = listen_addr.parse()?;
+
+    if args.get_flag("ssl") {
+        // Install custom CryptoProvider at the start
+        rustls::crypto::CryptoProvider::install_default(custom_crypto_provider())
+            .map_err(|e| anyhow::anyhow!("Failed to install custom CryptoProvider: {:?}", e))?;
+
+        let cert_path: &Path = args.get_one::<PathBuf>("server-cert").context("Missing --cert for SSL")?.as_path();
+        let key_path: &Path = args.get_one::<PathBuf>("server-key").context("Missing --key for SSL")?.as_path();
+
+        // Load certificate and private key with file size limit
+        let cert_chain = load_certs(cert_path,Some(1)).await?;
+        let private_key = load_private_key(key_path).await?;
+        //scopeguard::defer! { private_key.zeroize(); }//can't it's moving it
+        {
+            let mut _cloned_pk=private_key.clone_key();
+        }
+//        scopeguard::defer! {
+//            eprintln!("!!! in defer!");
+//            cloned_pk.zeroize();
+//            eprintln!("!!! at end of defer!");
+//        }//can't it's moving it
+//        struct LoggedKey(PrivateKeyDer<'static>);
+//        impl Drop for LoggedKey {
+//            fn drop(&mut self) {
+//                eprintln!("Dropping PrivateKeyDer");
+//                self.0.zeroize(); // Explicitly zero for clarity
+//            }
+//        }
+//        {
+//            let _foo=LoggedKey(private_key.clone_key());
+//        } // well yeah the wrapper gets dropped, obviously.
+
+        // XXX: No revocation status is checked, so a valid-but-revoked cert would pass. (because
+        // code doesn't use .with_crls() )
+
+        // Initialize root store
+        let mut roots = rustls::RootCertStore::empty();
+
+        // Handle system root certificates
+        let trust_system = args.get_flag("client-trust-system-root-store");
+
+        use x509_parser::prelude::FromDer;
+        use sha2::{Digest, Sha256};
+        //use openssl::sha::{Sha256, Digest};
+
+        if trust_system {
+            eprintln!("Was asked to trust the system root store for verifying client certs.");
+            //unusual to trust system store with mTLS
+            //load system trust store certs
+            let cr:rustls_native_certs::CertificateResult = rustls_native_certs::load_native_certs();
+            if cr.errors.len() > 0 {
+                return Err(anyhow::anyhow!("Failed to load system certs: {:#?}", cr.errors));
+            }
+            let system_store = cr.expect("impossible now: failed to load system certs.");
+            for cert in system_store {
+                // Parse and log cert details
+                if let Ok((_, parsed)) = x509_parser::prelude::X509Certificate::from_der(cert.as_ref()) {
+                    let subject = parsed.subject().to_string();
+                    let issuer = parsed.issuer().to_string();
+                    let not_after = parsed.validity().not_after.to_string();
+                    let serial = parsed.serial.to_string();
+                    let fingerprint = format!("{:x}", Sha256::digest(cert.as_ref()));
+                    log::info!(
+                        "System cert: subject={}, issuer={}, serial={}, expires={}, fingerprint={}",
+                        subject, issuer, serial, not_after, fingerprint
+                    );
+                } else {
+                    log::warn!("Failed to parse system cert");
+                }
+
+                roots.add(cert)?;
+            }
+        } else {
+            eprintln!("Was asked to not trust the system root store for verifying client certs.");
+        }
+
+        // Load custom client trust certificates
+        if let Some(client_trust_path) = args.get_one::<PathBuf>("client-trust-cert") {
+            let client_certs = load_certs(client_trust_path, None).await?;
+            for cert in client_certs {
+                // Parse and log cert details
+                if let Ok((_, parsed)) = x509_parser::prelude::X509Certificate::from_der(cert.as_ref()) {
+                    let subject = parsed.subject().to_string();
+                    let issuer = parsed.issuer().to_string();
+                    let not_after = parsed.validity().not_after.to_string();
+                    let serial = parsed.serial.to_string();
+                    let fingerprint = format!("{:x}", Sha256::digest(cert.as_ref()));
+                    log::info!(
+                        "Custom cert: subject={}, issuer={}, serial={}, expires={}, fingerprint={}",
+                        subject, issuer, serial, not_after, fingerprint
+                    );
+                } else {
+                    log::warn!("Failed to parse custom cert from file {}", client_trust_path.display());
+                }
+                roots.add(cert)?;
+            }
+        }
+
+        // Configure client authentication (mTLS)
+        // FIXME: check if this 'danger' thing is as good as using
+        // crate::ConfigBuilder::with_client_auth_cert and .with_no_client_auth
+        let client_auth: Arc<dyn rustls::server::danger::ClientCertVerifier> = if args.get_one::<PathBuf>("client-trust-cert").is_some() {
+            eprintln!("Using mTLS");
+            // these roots here may just be the cert we specified without system root store's certs
+            rustls::server::WebPkiClientVerifier::builder(roots.into()) //Arc::new(roots))
+                .build()
+                .map_err(|e| anyhow::anyhow!("Failed to build client verifier: {}", e))?
+        } else {
+            eprintln!("Not using mTLS.");
+            rustls::server::WebPkiClientVerifier::no_client_auth()
+        };
+
+        // Create ServerConfig with secure settings
+        /*  zeroize: in rustls:
+            PR #1492 adds zeroization for session secrets and TLS keys, improving security for non-key material.
+            Private keys are still passed to ring, which doesn’t zeroize, so the risk remains for your use case.
+           ring:
+            No zeroization for RsaKeyPair, EcdsaKeyPair, pkcs8::Document, or Seed
+            Relies on the global allocator, which doesn’t guarantee memory zeroing.
+            Patching ring to add Zeroize is necessary for private key sanitization.
+        */
+        let config=
+            rustls::ServerConfig::builder_with_protocol_versions(&[
+                &rustls::version::TLS13,
+//                &rustls::version::TLS12,
+            ])
+//            rustls::ServerConfig::builder() // using this instead, wouldn't restrict proto versions.
+            .with_client_cert_verifier(client_auth)
+            //.with_no_client_auth() ^
+            .with_single_cert(cert_chain, private_key)
+            .map_err(|e| anyhow::anyhow!("Failed to set certificates from files pub:'{}', priv:'{}', err: {}", cert_path.display(), key_path.display(), e))?;
+
+        // Use axum_server with custom config
+        // zeroize: Safe, as it only holds an Arc<rustls::ServerConfig> and delegates to rustls for key handling.
+        let tls_config = axum_server::tls_rustls::RustlsConfig::from_config(Arc::new(config));
+
+        log::info!(
+            "Starting SpacetimeDB with TLSv1.3(only) on {}.",
+            addr,
+        );
+//        axum_server::bind_rustls(addr, tls_config)
+//            .serve(service.into_make_service())
+//            .await?;
+        // Run server in a task
+        let server = tokio::spawn(axum_server::bind_rustls(addr, tls_config).serve(service.into_make_service()));
+        // Wait for Ctrl+C
+        tokio::signal::ctrl_c().await?;
+        server.abort(); // Stop the server
+        //sanitize_private_key(&mut private_key); // Sanitize the key
+        //private_key.zeroize();//not needed(&can't do due to moved, above!) because rustls-pki-types crate implements (on drop) zeroize::Zeroize
+        eprintln!("\n!!! server's done.");
+    } else {
+        log::debug!("Starting SpacetimeDB without any ssl (so it's plaintext) listening on {}", addr);
+        axum_server::bind(addr)
+            .serve(service.into_make_service())
+            .await?;
+    }
+
     Ok(())
 }
 
-fn banner() {
-    println!(
-        r#"
-┌───────────────────────────────────────────────────────────────────────────────────────────────────────┐
-│                                                                                                       │
-│                                                                                                       │
-│                                                                              ⢀⠔⠁                      │
-│                                                                            ⣠⡞⠁                        │
-│                                              ⣀⣀⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣀⣀⣀⣀⣀⣀⣀⣤⣤⡴⠒    ⢀⣠⡾⠋                          │
-│                                         ⢀⣤⣶⣾88888888888888888888⠿⠋    ⢀⣴8⡟⠁                           │
-│                                      ⢀⣤⣾88888⡿⠿⠛⠛⠛⠛⠛⠛⠛⠛⠻⠿88888⠟⠁    ⣠⣾88⡟                             │
-│                                    ⢀⣴88888⠟⠋⠁ ⣀⣤⠤⠶⠶⠶⠶⠶⠤⣤⣀ ⠉⠉⠉    ⢀⣴⣾888⡟                              │
-│                                   ⣠88888⠋  ⣠⠶⠋⠉         ⠉⠙⠶⣄   ⢀⣴888888⠃                              │
-│                                  ⣰8888⡟⠁ ⣰⠟⠁               ⠈⠻⣆ ⠈⢿888888                               │
-│                                 ⢠8888⡟  ⡼⠁                   ⠈⢧ ⠈⢿8888⡿                               │
-│                                 ⣼8888⠁ ⢸⠇                     ⠸⡇ ⠘8888⣷                               │
-│                                 88888  8                       8  88888                               │
-│                                 ⢿8888⡄ ⢸⡆                     ⢰⡇ ⢀8888⡟                               │
-│                                 ⣾8888⣷⡀ ⢳⡀                   ⢀⡞  ⣼8888⠃                               │
-│                                 888888⣷⡀ ⠹⣦⡀               ⢀⣴⠏ ⢀⣼8888⠏                                │
-│                                ⢠888888⠟⠁   ⠙⠶⣄⣀         ⣀⣠⠶⠋  ⣠88888⠋                                 │
-│                                ⣼888⡿⠟⠁    ⣀⣀⣀ ⠉⠛⠒⠶⠶⠶⠶⠶⠒⠛⠉ ⢀⣠⣴88888⠟⠁                                  │
-│                               ⣼88⡿⠋    ⢀⣴88888⣶⣦⣤⣤⣤⣤⣤⣤⣤⣤⣶⣾88888⡿⠛⠁                                    │
-│                             ⢀⣼8⠟⠁    ⣠⣶88888888888888888888⡿⠿⠛⠁                                       │
-│                            ⣠⡾⠋⠁    ⠤⠞⠛⠛⠉⠉⠉⠉⠉⠉⠉⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠉⠉                                            │
-│                          ⢀⡼⠋                                                                          │
-│                        ⢀⠔⠁                                                                            │
-│                                                                                                       │
-│                                                                                                       │
-│  .d8888b.                                     888    d8b                        8888888b.  888888b.   │
-│ d88P  Y88b                                    888    Y8P                        888  "Y88b 888  "88b  │
-│ Y88b.                                         888                               888    888 888  .88P  │
-│  "Y888b.   88888b.   8888b.   .d8888b .d88b.  888888 888 88888b.d88b.   .d88b.  888    888 8888888K.  │
-│     "Y88b. 888 "88b     "88b d88P"   d8P  Y8b 888    888 888 "888 "88b d8P  Y8b 888    888 888  "Y88b │
-│       "888 888  888 .d888888 888     88888888 888    888 888  888  888 88888888 888    888 888    888 │
-│ Y88b  d88P 888 d88P 888  888 Y88b.   Y8b.     Y88b.  888 888  888  888 Y8b.     888  .d88P 888   d88P │
-│  "Y8888P"  88888P"  "Y888888  "Y8888P "Y8888   "Y888 888 888  888  888  "Y8888  8888888P"  8888888P"  │
-│            888                                                                                        │
-│            888                                                                                        │
-│            888                                                                                        │
-│                                  "Multiplayer at the speed of light"                                  │
-└───────────────────────────────────────────────────────────────────────────────────────────────────────┘
-    "#
-    )
-}
diff --git a/crates/update/Cargo.toml b/crates/update/Cargo.toml
index a698251f3..3022b509f 100644
--- a/crates/update/Cargo.toml
+++ b/crates/update/Cargo.toml
@@ -29,7 +29,7 @@ tar.workspace = true
 tempfile.workspace = true
 tokio.workspace = true
 toml.workspace = true
-tracing = { workspace = true, features = ["release_max_level_off"] }
+tracing = { workspace = true } #, features = ["release_max_level_off"] }
 zip = "2.3"
 
 [target.'cfg(windows)'.dependencies]
diff --git a/go_build_and_install b/go_build_and_install
new file mode 100755
index 000000000..e44acf1e6
--- /dev/null
+++ b/go_build_and_install
@@ -0,0 +1,64 @@
+#!/usr/bin/bash
+
+#info: https://github.com/clockworklabs/SpacetimeDB?tab=readme-ov-file#installing-from-source
+#typeish="release"
+if ! cargo fetch --offline; then
+  echo "!!! using internet"
+  set -e
+  cargo fetch
+  echo "!!!! re-run this to not use internet."
+  exit 0
+fi
+typeish="debug"
+if test "$typeish" == "release"; then
+  echo "building in release mode"
+  set -e
+  #time cargo build --locked --release -p spacetimedb-standalone -p spacetimedb-update -p spacetimedb-cli
+  #debug
+  time cargo build --locked --release -p spacetimedb-standalone -p spacetimedb-update -p spacetimedb-cli
+  #time cargo build --release -p spacetimedb-standalone -p spacetimedb-update -p spacetimedb-cli
+  set +e
+  outdir="./target/release/"
+else
+  echo "building with debug/dev profile"
+  set -e
+  #time cargo build -p spacetimedb-standalone
+  #time cargo build --locked -p spacetimedb-standalone
+  #time cargo build -p spacetimedb-cli
+  #time cargo build --locked -p spacetimedb-cli
+  time cargo build --locked -p spacetimedb-standalone -p spacetimedb-update -p spacetimedb-cli
+  #time cargo build -p spacetimedb-standalone -p spacetimedb-update -p spacetimedb-cli ; echo "$(tput setab 1)undo me in $0$(tput sgr0)"
+  set +e
+  outdir="./target/debug/"
+fi
+# Create directories
+mkdir -p ~/.local/bin
+export STDB_VERSION="$(${outdir}/spacetimedb-cli --version | sed -n 's/.*spacetimedb tool version \([0-9.]*\);.*/\1/p')"
+mkdir -p ~/.local/share/spacetime/bin/$STDB_VERSION
+
+on_err() {
+  echo "$(tput setaf 1)Failed$(tput sgr0)"
+}
+trap on_err ERR
+set -e
+# Install the update binary
+cp ${outdir}/spacetimedb-cli ~/.local/share/spacetime/bin/$STDB_VERSION
+cp ${outdir}/spacetimedb-standalone ~/.local/share/spacetime/bin/$STDB_VERSION
+cp ${outdir}/spacetimedb-update ~/.local/bin/spacetime
+
+spacetime version list
+spacetime version use "$STDB_VERSION"
+#spacetime version
+ls -la ~/.local/share/spacetime/bin/current
+set +e
+
+# Check if $HOME/.local/bin is in the PATH
+if [[ ":$PATH:" != *":$HOME/.local/bin:"* ]]; then
+    echo "$HOME/.local/bin is not in your PATH."
+    echo "You can add it by running:"
+    #echo "export PATH=\"\$HOME/.local/bin:\$PATH\""
+    #echo 'export PATH="$HOME/.local/bin:$PATH"'
+    echo 'export PATH="$PATH:$HOME/.local/bin"'
+fi
+
+echo "$(tput setaf 2)all done$(tput sgr0)"
diff --git a/start b/start
new file mode 100755
index 000000000..9d7b3b911
--- /dev/null
+++ b/start
@@ -0,0 +1,18 @@
+#!/usr/bin/bash
+
+#XXX: use(with this) the example client/server scripts from: https://github.com/dare3path/quickstart-chat
+echo "This starts the standalone spacetimedb server, using the 'spacetimedb' executable that's been installed (not the one build inside the repo)"
+export RUST_LOG="spacetimedb=debug,spacetimedb_client_api=debug,spacetimedb_lib=debug,spacetimedb_standalone=debug,spacetimedb_commitlog=info,spacetimedb_durability=info,axum::rejection=debug"
+export RUST_BACKTRACE=1
+#time spacetime start --ssl --cert cert.pem --key key.pem
+#time spacetime start --edition standalone --listen-addr 127.1.2.3:6543 --ssl --cert ../spacetimedb-cert-gen/server.crt --key ../spacetimedb-cert-gen/server.key
+
+#mTLS:
+time spacetime start --edition standalone --listen-addr 127.1.2.3:6543 --ssl --cert ../spacetimedb-cert-gen/server.crt --key ../spacetimedb-cert-gen/server.key --client-CA-cert ../spacetimedb-cert-gen/ca4clients.crt --client-no-trust-system-root-store
+#listens as HTTP, not HTTPS:
+#time spacetime start --edition standalone --listen-addr 127.1.2.3:6543
+
+#old:
+#time spacetime start --edition standalone --listen-addr 127.0.0.1:3001 #this is HTTP
+#time spacetime start --edition standalone --listen-addr 127.0.0.1:3001  --ssl --cert ../spacetimedb-cert-gen/server.crt --key ../spacetimedb-cert-gen/server.key #this is HTTPS
+
