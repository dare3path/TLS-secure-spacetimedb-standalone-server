apply this on top of ./spacetimedb-tls.patch

adds mutual TLS (mTLS) support
which means, clients can provide a cert to identify themselves, if server used --client-cert arg
to pass the cert file/chain that server will use to check client-provided certs for authentication.

Note that: $ spacetime start --help
has a similar feature for identities (ie. after you're already talking to the server, the spacetimedb one,
as opposed to the TLS "handshaking" part of it which is prior and this patch addresses)

      --jwt-pub-key-path <jwt_pub_key_path>    The path to the public jwt key for verifying identities
      --jwt-priv-key-path <jwt_priv_key_path>  The path to the private jwt key for issuing identities

so if that jwt isn't enough for you, then you want this mTLS patch, perhaps in addition to it.

TODO: error handling is incomplete, eg. ping and fingerprint have it

diff --git a/Cargo.lock b/Cargo.lock
index 7e74cb9a..96b54567 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -212,6 +212,45 @@ version = "0.7.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50"
 
+[[package]]
+name = "asn1-rs"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "56624a96882bb8c26d61312ae18cb45868e5a9992ea73c58e45c3101e56a1e60"
+dependencies = [
+ "asn1-rs-derive",
+ "asn1-rs-impl",
+ "displaydoc",
+ "nom",
+ "num-traits",
+ "rusticata-macros",
+ "thiserror 2.0.11",
+ "time",
+]
+
+[[package]]
+name = "asn1-rs-derive"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3109e49b1e4909e9db6515a30c633684d68cdeaa252f215214cb4fa1a5bfee2c"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.87",
+ "synstructure 0.13.1",
+]
+
+[[package]]
+name = "asn1-rs-impl"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7b18050c2cd6fe86c3a76584ef5e0baf286d038cda203eb6223df2cc413565f7"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.87",
+]
+
 [[package]]
 name = "async-stream"
 version = "0.3.6"
@@ -334,7 +373,7 @@ dependencies = [
  "http 1.1.0",
  "http-body 1.0.1",
  "http-body-util",
- "hyper 1.5.0",
+ "hyper 1.6.0",
  "hyper-util",
  "itoa",
  "matchit",
@@ -410,7 +449,7 @@ dependencies = [
  "fs-err 3.1.0",
  "http 1.1.0",
  "http-body 1.0.1",
- "hyper 1.5.0",
+ "hyper 1.6.0",
  "hyper-util",
  "pin-project-lite",
  "rustls",
@@ -1501,6 +1540,20 @@ version = "0.1.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "da692b8d1080ea3045efaab14434d40468c3d8657e42abddfffca87b428f4c1b"
 
+[[package]]
+name = "der-parser"
+version = "10.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "07da5016415d5a3c4dd39b11ed26f915f52fc4e0dc197d87908bc916e51bc1a6"
+dependencies = [
+ "asn1-rs",
+ "displaydoc",
+ "nom",
+ "num-bigint",
+ "num-traits",
+ "rusticata-macros",
+]
+
 [[package]]
 name = "deranged"
 version = "0.3.11"
@@ -2455,9 +2508,9 @@ dependencies = [
 
 [[package]]
 name = "hyper"
-version = "1.5.0"
+version = "1.6.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbbff0a806a4728c99295b254c8838933b5b082d75e3cb70c8dab21fdfbcfa9a"
+checksum = "cc2b571658e38e0c01b1fdca3bbbe93c00d3d71693ff2770043f8c29bc7d6f80"
 dependencies = [
  "bytes",
  "futures-channel",
@@ -2482,7 +2535,7 @@ checksum = "08afdbb5c31130e3034af566421053ab03787c640246a446327f550d11bcb333"
 dependencies = [
  "futures-util",
  "http 1.1.0",
- "hyper 1.5.0",
+ "hyper 1.6.0",
  "hyper-util",
  "rustls",
  "rustls-pki-types",
@@ -2512,7 +2565,7 @@ checksum = "70206fc6890eaca9fde8a0bf71caa2ddfc9fe045ac9e5c70df101a7dbde866e0"
 dependencies = [
  "bytes",
  "http-body-util",
- "hyper 1.5.0",
+ "hyper 1.6.0",
  "hyper-util",
  "native-tls",
  "tokio",
@@ -2522,16 +2575,15 @@ dependencies = [
 
 [[package]]
 name = "hyper-util"
-version = "0.1.10"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "df2dcfbe0677734ab2f3ffa7fa7bfd4706bfdc1ef393f2ee30184aed67e631b4"
+version = "0.1.12"
 dependencies = [
  "bytes",
  "futures-channel",
  "futures-util",
  "http 1.1.0",
  "http-body 1.0.1",
- "hyper 1.5.0",
+ "hyper 1.6.0",
+ "libc",
  "pin-project-lite",
  "socket2",
  "tokio",
@@ -3040,9 +3092,9 @@ checksum = "884e2677b40cc8c339eaefcb701c32ef1fd2493d71118dc0ca4b6a736c93bd67"
 
 [[package]]
 name = "libc"
-version = "0.2.162"
+version = "0.2.172"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "18d287de67fe55fd7e1581fe933d965a5a9477b38e949cfa9f8574ef01506398"
+checksum = "d750af042f7ef4f724306de029d18836c26c1765a54a6a3f094cbd23a7267ffa"
 
 [[package]]
 name = "libloading"
@@ -3329,7 +3381,7 @@ dependencies = [
  "openssl-probe",
  "openssl-sys",
  "schannel",
- "security-framework",
+ "security-framework 2.11.1",
  "security-framework-sys",
  "tempfile",
 ]
@@ -3547,6 +3599,15 @@ dependencies = [
  "memchr",
 ]
 
+[[package]]
+name = "oid-registry"
+version = "0.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "12f40cff3dde1b6087cc5d5f5d4d65712f34016a03ed60e9c08dcc392736b5b7"
+dependencies = [
+ "asn1-rs",
+]
+
 [[package]]
 name = "once_cell"
 version = "1.20.2"
@@ -4510,7 +4571,7 @@ dependencies = [
  "http 1.1.0",
  "http-body 1.0.1",
  "http-body-util",
- "hyper 1.5.0",
+ "hyper 1.6.0",
  "hyper-rustls",
  "hyper-tls 0.6.0",
  "hyper-util",
@@ -4663,6 +4724,15 @@ dependencies = [
  "semver",
 ]
 
+[[package]]
+name = "rusticata-macros"
+version = "4.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "faf0c4a6ece9950b9abdb62b1cfcf2a68b3b67a10ba445b3bb85be2a293d0632"
+dependencies = [
+ "nom",
+]
+
 [[package]]
 name = "rustix"
 version = "0.38.40"
@@ -4678,9 +4748,9 @@ dependencies = [
 
 [[package]]
 name = "rustls"
-version = "0.23.16"
+version = "0.23.26"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "eee87ff5d9b36712a58574e12e9f0ea80f915a5b0ac518d322b24a465617925e"
+checksum = "df51b5869f3a441595eac5e8ff14d486ff285f7b8c0df8770e49c3b56351f0f0"
 dependencies = [
  "aws-lc-rs",
  "log",
@@ -4692,6 +4762,18 @@ dependencies = [
  "zeroize",
 ]
 
+[[package]]
+name = "rustls-native-certs"
+version = "0.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7fcff2dd52b58a8d98a70243663a0d234c4e2b79235637849d15913394a247d3"
+dependencies = [
+ "openssl-probe",
+ "rustls-pki-types",
+ "schannel",
+ "security-framework 3.2.0",
+]
+
 [[package]]
 name = "rustls-pemfile"
 version = "1.0.4"
@@ -4712,15 +4794,15 @@ dependencies = [
 
 [[package]]
 name = "rustls-pki-types"
-version = "1.10.0"
+version = "1.11.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "16f1201b3c9a7ee8039bcadc17b7e605e2945b27eee7631788c1bd2b0643674b"
+checksum = "917ce264624a4b4db1c364dcc35bfca9ded014d0a958cd47ad3e960e988ea51c"
 
 [[package]]
 name = "rustls-webpki"
-version = "0.102.8"
+version = "0.103.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "64ca1bc8749bd4cf37b5ce386cc146580777b4e8572c7b97baf22c83f444bee9"
+checksum = "fef8b8769aaccf73098557a87cd1816b4f9c7c16811c9c77142aa695c16f2c03"
 dependencies = [
  "aws-lc-rs",
  "ring",
@@ -4850,11 +4932,24 @@ dependencies = [
  "security-framework-sys",
 ]
 
+[[package]]
+name = "security-framework"
+version = "3.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "271720403f46ca04f7ba6f55d438f8bd878d6b8ca0a1046e8228c4145bcbb316"
+dependencies = [
+ "bitflags 2.6.0",
+ "core-foundation 0.10.0",
+ "core-foundation-sys",
+ "libc",
+ "security-framework-sys",
+]
+
 [[package]]
 name = "security-framework-sys"
-version = "2.12.1"
+version = "2.14.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fa39c7303dc58b5543c94d22c1766b0d31f2ee58306363ea622b10bbc075eaa2"
+checksum = "49db231d56a190491cb4aeda9527f1ad45345af50b0851622a7adb8c03b01c32"
 dependencies = [
  "core-foundation-sys",
  "libc",
@@ -5170,9 +5265,9 @@ dependencies = [
 
 [[package]]
 name = "socket2"
-version = "0.5.7"
+version = "0.5.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ce305eb0b4296696835b71df73eb912e0f1ffd2556a501fcede6e0c50349191c"
+checksum = "4f5fd57c80058a56cf5c777ab8a126398ece8e442983605d280a44ce79d0edef"
 dependencies = [
  "libc",
  "windows-sys 0.52.0",
@@ -5310,10 +5405,12 @@ dependencies = [
  "percent-encoding",
  "regex",
  "reqwest 0.12.9",
+ "rustls-pemfile 2.2.0",
  "rustyline",
  "serde",
  "serde_json",
  "serde_with",
+ "sha2",
  "slab",
  "spacetimedb-auth",
  "spacetimedb-client-api-messages",
@@ -5343,6 +5440,7 @@ dependencies = [
  "wasmtime",
  "webbrowser",
  "windows-sys 0.59.0",
+ "x509-parser",
 ]
 
 [[package]]
@@ -5361,7 +5459,7 @@ dependencies = [
  "futures",
  "headers",
  "http 1.1.0",
- "hyper 1.5.0",
+ "hyper 1.6.0",
  "hyper-util",
  "itoa",
  "jemalloc_pprof",
@@ -5481,7 +5579,7 @@ dependencies = [
  "hashbrown 0.15.1",
  "hex",
  "hostname",
- "hyper 1.5.0",
+ "hyper 1.6.0",
  "imara-diff",
  "indexmap 2.6.0",
  "itertools 0.12.1",
@@ -5678,11 +5776,14 @@ dependencies = [
  "enum-as-inner",
  "enum-map",
  "hex",
+ "hyper 1.6.0",
  "insta",
  "itertools 0.12.1",
  "native-tls",
+ "openssl",
  "proptest",
  "proptest-derive",
+ "reqwest 0.12.9",
  "ron",
  "serde",
  "serde_json",
@@ -5834,6 +5935,7 @@ dependencies = [
  "base64 0.21.7",
  "brotli",
  "bytes",
+ "clap 4.5.20",
  "cursive",
  "futures",
  "futures-channel",
@@ -5916,9 +6018,11 @@ dependencies = [
  "prometheus",
  "ring",
  "rustls",
+ "rustls-native-certs",
  "rustls-pemfile 2.2.0",
  "scopeguard",
  "serde_json",
+ "sha2",
  "sled",
  "socket2",
  "spacetimedb-client-api",
@@ -5934,6 +6038,7 @@ dependencies = [
  "toml 0.8.19",
  "tower-http",
  "tracing",
+ "x509-parser",
 ]
 
 [[package]]
@@ -8057,6 +8162,23 @@ dependencies = [
  "tap",
 ]
 
+[[package]]
+name = "x509-parser"
+version = "0.17.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4569f339c0c402346d4a75a9e39cf8dad310e287eef1ff56d4c68e5067f53460"
+dependencies = [
+ "asn1-rs",
+ "data-encoding",
+ "der-parser",
+ "lazy_static",
+ "nom",
+ "oid-registry",
+ "rusticata-macros",
+ "thiserror 2.0.11",
+ "time",
+]
+
 [[package]]
 name = "xattr"
 version = "1.3.1"
diff --git a/Cargo.toml b/Cargo.toml
index acd852f6..e9001a66 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -66,7 +66,8 @@ lto = "thin"
 
 [profile.dev]
 opt-level = 0
-debug = true
+debug = 1
+#debug = true #FIXME: put this back
 debug-assertions = true
 overflow-checks = true
 lto = false
@@ -129,7 +130,12 @@ arrayvec = "0.7.2"
 async-stream = "0.3.6"
 async-trait = "0.1.68"
 axum = { version = "0.7", features = ["tracing"] }
+axum-server = { version = "0.7.2", features = ["tls-rustls"] }
 axum-extra = { version = "0.9", features = ["typed-header"] }
+#rustls-platform-verifier = "0.5"
+x509-parser = "0.17"
+sha2="0.10.8"
+rustls-native-certs = "0.8"
 backtrace = "0.3.66"
 base64 = "0.21.2"
 bigdecimal = "0.4.7"
@@ -178,8 +184,8 @@ home = "0.5"
 hostname = "^0.3"
 http = "1.0"
 humantime = "2.1.0"
-hyper = "1.0"
-hyper-util = { version = "0.1", features = ["tokio"] }
+hyper = "1.6"
+hyper-util = { version = "0.1.12", features = ["tokio"] }
 imara-diff = "0.1.3"
 indexmap = "2.0.0"
 indicatif = "0.17"
@@ -214,7 +220,12 @@ rand = "0.9"
 rayon = "1.8"
 rayon-core = "1.11.0"
 regex = "1"
-reqwest = { version = "0.12", features = ["stream", "json"] }
+reqwest = { version = "0.12", features = ["stream", "json", "native-tls"] }
+rustls-pemfile = "2.2"
+#rustls = "0.23"
+rustls= { version="0.23", default-features = true, features=[ "ring" ] }
+native-tls = "0.2"  # Explicitly add for Connector::NativeTls
+ring = "0.17"  # explicitly add this for the CryptoProvider, even tho it's included transitively.
 ron = "0.8"
 rusqlite = { version = "0.29.0", features = ["bundled", "column_decltype"] }
 rust_decimal = { version = "1.29.1", features = ["db-tokio-postgres"] }
@@ -317,3 +328,8 @@ features = [
   "ondemand",
 ]
 
+
+[patch.crates-io]
+#hyper = { path = "/home/user/SOURCE/my/channelclosed.reqwest/hyper" }
+hyper-util = { path = "/home/user/SOURCE/my/channelclosed.reqwest/hyper-util" }
+
diff --git a/crates/cli/Cargo.toml b/crates/cli/Cargo.toml
index eca986ec..fe693b51 100644
--- a/crates/cli/Cargo.toml
+++ b/crates/cli/Cargo.toml
@@ -74,7 +74,12 @@ wasmbin.workspace = true
 wasmtime.workspace = true
 webbrowser.workspace = true
 clap-markdown.workspace = true
-native-tls = "0.2"
+#native-tls = "0.2"
+native-tls.workspace=true
+rustls-pemfile.workspace=true
+x509-parser.workspace=true
+sha2.workspace=true
+#hyper.workspace=true
 
 [target.'cfg(not(target_env = "msvc"))'.dependencies]
 tikv-jemallocator = { workspace = true }
diff --git a/crates/cli/src/api.rs b/crates/cli/src/api.rs
index 544a80b6..e8c039e8 100644
--- a/crates/cli/src/api.rs
+++ b/crates/cli/src/api.rs
@@ -20,7 +20,11 @@ pub struct Connection {
     pub(crate) database_identity: Identity,
     pub(crate) database: String,
     pub(crate) auth_header: AuthHeader,
-    pub(crate) cert_path: Option<PathBuf>, // FIXME: bad idea to put it here? else pass it as arg?
+    // FIXME: bad idea to put these next ones here? else pass'em as arg?
+    pub(crate) trust_server_cert_path: Option<PathBuf>,
+    pub(crate) client_cert_path: Option<PathBuf>,
+    pub(crate) client_key_path: Option<PathBuf>,
+    pub(crate) trust_system: bool,
 }
 
 impl Connection {
@@ -37,10 +41,19 @@ impl Connection {
 }
 
 pub fn build_client(con: &Connection) -> Client {
+    let trust_server_cert_path=con.trust_server_cert_path.as_deref();
+    let client_cert_path=con.client_cert_path.as_deref();
+    let client_key_path=con.client_key_path.as_deref();
+    let trust_system=con.trust_system;
     //XXX: alternatively make this async and then make new() async, and ensure callers do .await on it
     let mut builder = tokio::task::block_in_place(|| {
         tokio::runtime::Handle::current()
-            .block_on(util::configure_tls(con.cert_path.as_deref()))
+            .block_on(util::configure_tls(
+                    trust_server_cert_path,
+                    client_cert_path,
+                    client_key_path,
+                    trust_system
+                    ))
     })
     .unwrap();
     builder = builder.user_agent(APP_USER_AGENT);
@@ -51,7 +64,12 @@ pub fn build_client(con: &Connection) -> Client {
         builder = builder.default_headers(headers);
     }
 
-    util::build_client_with_context(builder, con.cert_path.as_deref()).unwrap()
+    util::build_client_with_context(builder,
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+    ).unwrap()
 }
 
 pub struct ClientApi {
diff --git a/crates/cli/src/common_args.rs b/crates/cli/src/common_args.rs
index 578d9363..4ff8d27d 100644
--- a/crates/cli/src/common_args.rs
+++ b/crates/cli/src/common_args.rs
@@ -1,6 +1,6 @@
 use clap::Arg;
 use clap::ArgAction::SetTrue;
-pub use spacetimedb_lib::cert;
+pub use spacetimedb_lib::{no_trust_system_root_store, trust_system_root_store, trust_server_cert, client_key, client_cert};
 
 pub fn server() -> Arg {
     Arg::new("server")
diff --git a/crates/cli/src/subcommands/call.rs b/crates/cli/src/subcommands/call.rs
index a8375f9e..a142056e 100644
--- a/crates/cli/src/subcommands/call.rs
+++ b/crates/cli/src/subcommands/call.rs
@@ -11,6 +11,7 @@ use spacetimedb_lib::sats::{self, AlgebraicType, Typespace};
 use spacetimedb_lib::{Identity, ProductTypeElement};
 use spacetimedb_schema::def::{ModuleDef, ReducerDef};
 use std::fmt::Write;
+use std::path::{Path, PathBuf};
 
 use super::sql::parse_req;
 
@@ -30,7 +31,14 @@ pub fn cli() -> clap::Command {
                 .required(true)
                 .help("The name of the reducer to call"),
         )
-        .arg(common_args::cert())
+        //.arg(common_args::cert())
+
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
+
         .arg(Arg::new("arguments").help("arguments formatted as JSON").num_args(1..))
         .arg(common_args::server().help("The nickname, host name or URL of the server hosting the database"))
         .arg(common_args::anonymous())
@@ -43,8 +51,22 @@ pub async fn exec(config: Config, args: &ArgMatches) -> Result<(), Error> {
     let reducer_name = args.get_one::<String>("reducer_name").unwrap();
     let arguments = args.get_many::<String>("arguments");
 
-    let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
-    let conn = parse_req(config, args, cert_path).await?;
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+    let conn = parse_req(config, args,
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+    ).await?;
     let api = ClientApi::new(conn);
 
     let database_identity = api.con.database_identity;
diff --git a/crates/cli/src/subcommands/delete.rs b/crates/cli/src/subcommands/delete.rs
index 7391bd14..d993d4a8 100644
--- a/crates/cli/src/subcommands/delete.rs
+++ b/crates/cli/src/subcommands/delete.rs
@@ -2,6 +2,7 @@ use crate::common_args;
 use crate::config::Config;
 use crate::util::{add_auth_header_opt, database_identity, get_auth_header, build_client};
 use clap::{Arg, ArgMatches};
+use std::path::{Path, PathBuf};
 
 pub fn cli() -> clap::Command {
     clap::Command::new("delete")
@@ -13,7 +14,12 @@ pub fn cli() -> clap::Command {
         )
         .arg(common_args::server().help("The nickname, host name or URL of the server hosting the database"))
         .arg(common_args::yes())
-        .arg(common_args::cert())
+
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
         .after_help("Run `spacetime help delete` for more detailed information.\n")
 }
 
@@ -24,9 +30,22 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     let database = args.get_one::<String>("database").unwrap();
     let force = args.get_flag("force");
 
-    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
-
-    let client = build_client(cert).await?;
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+    let client = build_client(
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+        ).await?;
     let identity = database_identity(&config, database, server, &client).await?;
 
     let builder = client.delete(format!("{}/v1/database/{}", config.get_host_url(server)?, identity));
diff --git a/crates/cli/src/subcommands/describe.rs b/crates/cli/src/subcommands/describe.rs
index fea482d0..2fbcf5ac 100644
--- a/crates/cli/src/subcommands/describe.rs
+++ b/crates/cli/src/subcommands/describe.rs
@@ -6,6 +6,7 @@ use crate::util::UNSTABLE_WARNING;
 use anyhow::Context;
 use clap::{Arg, ArgAction, ArgMatches};
 use spacetimedb_lib::sats;
+use std::path::{Path, PathBuf};
 
 pub fn cli() -> clap::Command {
     clap::Command::new("describe")
@@ -40,7 +41,12 @@ pub fn cli() -> clap::Command {
                      give human-readable output.",
                 ),
         )
-        .arg(common_args::cert())
+        //.arg(common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
         .arg(common_args::anonymous())
         .arg(common_args::server().help("The nickname, host name or URL of the server hosting the database"))
         .arg(common_args::yes())
@@ -60,9 +66,23 @@ pub async fn exec(config: Config, args: &ArgMatches) -> Result<(), anyhow::Error
     let entity_type = args.get_one::<EntityType>("entity_type");
     let entity = entity_type.zip(entity_name);
     let json = args.get_flag("json");
-    let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
 
-    let conn = parse_req(config, args, cert_path).await?;
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+
+    let conn = parse_req(config, args,
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+        ).await?;
     let api = ClientApi::new(conn);
 
     let module_def = api.module_def().await?;
diff --git a/crates/cli/src/subcommands/dns.rs b/crates/cli/src/subcommands/dns.rs
index b75d0d6d..b62c6a7b 100644
--- a/crates/cli/src/subcommands/dns.rs
+++ b/crates/cli/src/subcommands/dns.rs
@@ -1,8 +1,9 @@
 use crate::common_args;
 use crate::config::Config;
-use crate::util::{add_auth_header_opt, decode_identity, get_auth_header, get_login_token_or_log_in, ResponseExt};
+use crate::util::{add_auth_header_opt, decode_identity, get_auth_header, get_login_token_or_log_in, ResponseExt, build_client};
 use clap::ArgMatches;
 use clap::{Arg, Command};
+use std::path::{Path, PathBuf};
 
 use spacetimedb_client_api_messages::name::{DomainName, InsertDomainResult};
 
@@ -20,7 +21,12 @@ pub fn cli() -> Command {
                 .required(true)
                 .help("The database identity to rename"),
         )
-        .arg(common_args::cert())
+        //.arg(common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
         .arg(common_args::server().help("The nickname, host name or URL of the server on which to set the name"))
         .arg(common_args::yes())
         .after_help("Run `spacetime rename --help` for more detailed information.\n")
@@ -34,11 +40,24 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     let token = get_login_token_or_log_in(&mut config, server, !force).await?;
     let identity = decode_identity(&token)?;
     let auth_header = get_auth_header(&mut config, false, server, !force).await?;
-    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
 
     let domain: DomainName = domain.parse()?;
 
-    let client = crate::util::build_client(cert).await?;
+    let client = build_client(
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+    ).await?;
     let builder = client
         .post(format!(
             "{}/v1/database/{database_identity}/names",
diff --git a/crates/cli/src/subcommands/energy.rs b/crates/cli/src/subcommands/energy.rs
index a01b03b8..6d07019d 100644
--- a/crates/cli/src/subcommands/energy.rs
+++ b/crates/cli/src/subcommands/energy.rs
@@ -3,7 +3,8 @@ use crate::common_args;
 use clap::ArgMatches;
 
 use crate::config::Config;
-use crate::util::{self, get_login_token_or_log_in, UNSTABLE_WARNING};
+use crate::util::{self, get_login_token_or_log_in, UNSTABLE_WARNING, build_client};
+use std::path::{Path, PathBuf};
 
 pub fn cli() -> clap::Command {
     clap::Command::new("energy")
@@ -30,7 +31,12 @@ fn get_energy_subcommands() -> Vec<clap::Command> {
             common_args::server()
                 .help("The nickname, host name or URL of the server from which to request balance information"),
         )
-        .arg(common_args::cert())
+        //.arg(common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
         .arg(common_args::yes())]
 }
 
@@ -59,8 +65,22 @@ async fn exec_status(mut config: Config, args: &ArgMatches) -> Result<(), anyhow
         let token = get_login_token_or_log_in(&mut config, server, !force).await?;
         util::decode_identity(&token)?
     };
-    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
-    let client = crate::util::build_client(cert).await?;
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+    let client = build_client(
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+    ).await?;
 
     let status = client
         .get(format!("{}/v1/energy/{}", config.get_host_url(server)?, identity))
diff --git a/crates/cli/src/subcommands/list.rs b/crates/cli/src/subcommands/list.rs
index d048b782..3b8ca2d9 100644
--- a/crates/cli/src/subcommands/list.rs
+++ b/crates/cli/src/subcommands/list.rs
@@ -12,6 +12,7 @@ use tabled::{
     settings::{object::Columns, Alignment, Modify, Style},
     Table, Tabled,
 };
+use std::path::{Path, PathBuf};
 
 pub fn cli() -> Command {
     Command::new("list")
@@ -19,7 +20,12 @@ pub fn cli() -> Command {
             "Lists the databases attached to an identity. {}",
             UNSTABLE_WARNING
         ))
-        .arg(common_args::cert())
+        //.arg(common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
         .arg(common_args::server().help("The nickname, host name or URL of the server from which to list databases"))
         .arg(common_args::yes())
 }
@@ -43,8 +49,22 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     let token = get_login_token_or_log_in(&mut config, server, !force).await?;
     let identity = util::decode_identity(&token)?;
 
-    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
-    let client = util::build_client(cert).await?;
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+    let client = util::build_client(
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+        ).await?;
     let res = client
         .get(format!(
             "{}/v1/identity/{}/databases",
diff --git a/crates/cli/src/subcommands/login.rs b/crates/cli/src/subcommands/login.rs
index d009d122..c65169e1 100644
--- a/crates/cli/src/subcommands/login.rs
+++ b/crates/cli/src/subcommands/login.rs
@@ -4,6 +4,8 @@ use clap::{Arg, ArgAction, ArgGroup, ArgMatches, Command};
 use reqwest::Url;
 use serde::Deserialize;
 use webbrowser;
+use crate::common_args;
+use std::path::{Path, PathBuf};
 
 pub const DEFAULT_AUTH_HOST: &str = "https://spacetimedb.com";
 
@@ -31,7 +33,12 @@ pub fn cli() -> Command {
                 .group("login-method")
                 .help("Bypass the login flow and use a login token directly"),
         )
-        .arg(crate::common_args::cert())
+        //.arg(crate::common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
         .about("Manage your login to the SpacetimeDB CLI")
 }
 
@@ -73,12 +80,31 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
         return Ok(());
     }
 
-    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
     if let Some(server) = server_issued_login {
         let host = Url::parse(&config.get_host_url(Some(server))?)?;
-        spacetimedb_token_cached(&mut config, &host, true, cert).await?;
+        spacetimedb_token_cached(&mut config, &host, true,
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ).await?;
     } else {
-        spacetimedb_token_cached(&mut config, &host, false, cert).await?;
+        spacetimedb_token_cached(&mut config, &host, false,
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ).await?;
     }
 
     Ok(())
@@ -111,7 +137,12 @@ async fn exec_show(config: Config, args: &ArgMatches) -> Result<(), anyhow::Erro
     Ok(())
 }
 
-async fn spacetimedb_token_cached(config: &mut Config, host: &Url, direct_login: bool, cert: Option<&std::path::Path>) -> anyhow::Result<String> {
+async fn spacetimedb_token_cached(config: &mut Config, host: &Url, direct_login: bool,
+    trust_server_cert_path: Option<&Path>,
+    client_cert_path: Option<&Path>,
+    client_key_path: Option<&Path>,
+    trust_system: bool,
+    ) -> anyhow::Result<String> {
     // Currently, this token does not expire. However, it will at some point in the future. When that happens,
     // this code will need to happen before any request to a spacetimedb server, rather than at the end of the login flow here.
     if let Some(token) = config.spacetimedb_token() {
@@ -119,14 +150,29 @@ async fn spacetimedb_token_cached(config: &mut Config, host: &Url, direct_login:
         println!("If you want to log out, use spacetime logout.");
         Ok(token.clone())
     } else {
-        spacetimedb_login_force(config, host, direct_login, cert).await
+        spacetimedb_login_force(config, host, direct_login,
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ).await
     }
 }
 
-pub async fn spacetimedb_login_force(config: &mut Config, host: &Url, direct_login: bool, cert: Option<&std::path::Path>) -> anyhow::Result<String> {
+pub async fn spacetimedb_login_force(config: &mut Config, host: &Url, direct_login: bool,
+    trust_server_cert_path: Option<&Path>,
+    client_cert_path: Option<&Path>,
+    client_key_path: Option<&Path>,
+    trust_system: bool,
+) -> anyhow::Result<String> {
     let token = if direct_login {
         println!("We will log in directly to your target server.");
-        let token = spacetimedb_direct_login(host, cert).await?;
+        let token = spacetimedb_direct_login(host,
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ).await?;
         println!("We have logged in directly to your target server.");
         println!("WARNING: This login will NOT work for any other servers.");
         token
@@ -286,8 +332,18 @@ struct LocalLoginResponse {
     pub token: String,
 }
 
-async fn spacetimedb_direct_login(host: &Url, cert: Option<&std::path::Path>) -> Result<String, anyhow::Error> {
-    let client = build_client(cert.as_deref()).await?;
+async fn spacetimedb_direct_login(host: &Url,
+    trust_server_cert_path: Option<&Path>,
+    client_cert_path: Option<&Path>,
+    client_key_path: Option<&Path>,
+    trust_system: bool,
+) -> Result<String, anyhow::Error> {
+    let client = build_client(
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+    ).await?;
 
     let response: LocalLoginResponse = client
         .post(host.join("/v1/identity")?)
diff --git a/crates/cli/src/subcommands/logs.rs b/crates/cli/src/subcommands/logs.rs
index 4f6cb8a6..d6ffe1e2 100644
--- a/crates/cli/src/subcommands/logs.rs
+++ b/crates/cli/src/subcommands/logs.rs
@@ -9,6 +9,7 @@ use futures::{AsyncBufReadExt, TryStreamExt};
 use is_terminal::IsTerminal;
 use termcolor::{Color, ColorSpec, WriteColor};
 use tokio::io::AsyncWriteExt;
+use std::path::{Path, PathBuf};
 
 pub fn cli() -> clap::Command {
     clap::Command::new("logs")
@@ -48,7 +49,12 @@ pub fn cli() -> clap::Command {
                 .help("Output format for the logs")
         )
         .arg(common_args::yes())
-        .arg(common_args::cert())
+        //.arg(common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
         .after_help("Run `spacetime help logs` for more detailed information.\n")
 }
 
@@ -121,9 +127,22 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
 
     let auth_header = get_auth_header(&mut config, false, server, !force).await?;
 
-    let cert: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
-
-    let client = build_client(cert).await?;
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+    let client = build_client(
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+    ).await?;
     let database_identity = database_identity(&config, database, server, &client).await?;
 
     if follow && num_lines.is_none() {
diff --git a/crates/cli/src/subcommands/publish.rs b/crates/cli/src/subcommands/publish.rs
index 7c6283ef..79a9e515 100644
--- a/crates/cli/src/subcommands/publish.rs
+++ b/crates/cli/src/subcommands/publish.rs
@@ -5,7 +5,7 @@ use reqwest::{StatusCode, Url};
 use spacetimedb_client_api_messages::name::PublishOp;
 use spacetimedb_client_api_messages::name::{is_identity, parse_database_name, PublishResult};
 use std::fs;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 use crate::config::Config;
 use crate::util::{add_auth_header_opt, get_auth_header, ResponseExt};
@@ -63,7 +63,12 @@ i.e. only lowercase ASCII letters and numbers, separated by dashes."),
         .arg(common_args::server()
                 .help("The nickname, domain name or URL of the server to host the database."),
         )
-        .arg(common_args::cert())
+//        .arg(common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
         .arg(
             common_args::yes()
         )
@@ -80,7 +85,16 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     let wasm_file = args.get_one::<PathBuf>("wasm_file");
     let database_host = config.get_host_url(server)?;
     let build_options = args.get_one::<String>("build_options").unwrap();
-    let cert_path: Option<&std::path::Path> = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
 
 
     // If the user didn't specify an identity and we didn't specify an anonymous identity, then
@@ -89,7 +103,12 @@ pub async fn exec(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::E
     //  easily create a new identity with an email
     let auth_header = get_auth_header(&mut config, anon_identity, server, !force).await?;
 
-    let client = build_client(cert_path).await?;
+    let client = build_client(
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+    ).await?;
 
     // If a domain or identity was provided, we should locally make sure it looks correct and
     let mut builder = if let Some(name_or_identity) = name_or_identity {
diff --git a/crates/cli/src/subcommands/server.rs b/crates/cli/src/subcommands/server.rs
index d9d81045..add81e86 100644
--- a/crates/cli/src/subcommands/server.rs
+++ b/crates/cli/src/subcommands/server.rs
@@ -10,7 +10,7 @@ use tabled::{
     settings::{object::Columns, Alignment, Modify, Style},
     Table, Tabled,
 };
-use std::path::Path;
+use std::path::{Path, PathBuf};
 
 pub fn cli() -> Command {
     Command::new("server")
@@ -55,8 +55,12 @@ fn get_subcommands() -> Vec<Command> {
                     .long("no-fingerprint")
                     .action(ArgAction::SetTrue),
             )
-            .arg(common_args::cert()),
-        Command::new("remove")
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
+        ,Command::new("remove")
             .about("Remove a saved server configuration")
             .arg(
                 Arg::new("server")
@@ -71,7 +75,11 @@ fn get_subcommands() -> Vec<Command> {
                     .required(true)
                     .help("The nickname, host name or URL of the server"),
             )
-            .arg(common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
             .arg(common_args::yes()),
         Command::new("ping")
             .about("Checks to see if a SpacetimeDB host is online")
@@ -80,8 +88,12 @@ fn get_subcommands() -> Vec<Command> {
                     .required(true)
                     .help("The nickname, host name or URL of the server to ping"),
             )
-            .arg(common_args::cert()),
-        Command::new("edit")
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
+        ,Command::new("edit")
             .about("Update a saved server's nickname, host name or protocol")
             .arg(
                 Arg::new("server")
@@ -104,7 +116,11 @@ fn get_subcommands() -> Vec<Command> {
                     .long("no-fingerprint")
                     .action(ArgAction::SetTrue),
             )
-            .arg(common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
             .arg(common_args::yes()),
         Command::new("clear")
             .about("Deletes all data from all local databases")
@@ -200,11 +216,24 @@ pub async fn exec_add(mut config: Config, args: &ArgMatches) -> Result<(), anyho
     let nickname = args.get_one::<String>("name");
     let default = *args.get_one::<bool>("default").unwrap();
     let no_fingerprint = *args.get_one::<bool>("no-fingerprint").unwrap();
-    let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
-
-    if no_fingerprint && cert_path.is_some() {
-        eprintln!("WARNING: --cert ignored while using --no-fingerprint");
-    }
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+//    if no_fingerprint {
+//        if trust_server_cert_path.is_some() {
+//            eprintln!("WARNING: --cert ignored while using --no-fingerprint");
+//        }
+//        if client_cert_path.is_some() {
+//            eprintln!("WARNING:  ignored while using --no-fingerprint");
+//        }
+//    }
 
     let (host, protocol) = host_or_url_to_host_and_protocol(url);
     let protocol = protocol.ok_or_else(|| anyhow::anyhow!("Invalid url: {}", url))?;
@@ -214,7 +243,13 @@ pub async fn exec_add(mut config: Config, args: &ArgMatches) -> Result<(), anyho
     let fingerprint = if no_fingerprint {
         None
     } else {
-        let fingerprint = spacetime_server_fingerprint(url, cert_path).await.with_context(|| {
+        let fingerprint = spacetime_server_fingerprint(
+            url,
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            trust_system,
+        ).await.with_context(|| {
             format!(
                 "Unable to retrieve fingerprint for server: {url}
 Is the server running?
@@ -253,8 +288,11 @@ pub async fn exec_remove(mut config: Config, args: &ArgMatches) -> Result<(), an
 async fn update_server_fingerprint(
     config: &mut Config,
     server: Option<&str>,
-    cert_path: Option<&Path>,
     protocol: Option<&str>,
+    trust_server_cert_path: Option<&Path>,
+    client_cert_path: Option<&Path>,
+    client_key_path: Option<&Path>,
+    trust_system: bool,
 ) -> Result<bool, anyhow::Error> {
     let (host, proto, nick_or_host) = match server {
         Some(s) => {
@@ -282,8 +320,13 @@ async fn update_server_fingerprint(
         }
     };
     let url = format!("{}://{}", proto, host);
-    let new_fing = spacetime_server_fingerprint(&url, cert_path)
-        .await
+    let new_fing = spacetime_server_fingerprint(
+        &url,
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+    ).await
         .context("Error fetching server fingerprint")?;
     if let Some(saved_fing) = config.server_fingerprint(Some(&host), Some(&proto))? {
         if saved_fing == new_fing {
@@ -310,10 +353,29 @@ async fn update_server_fingerprint(
 pub async fn exec_fingerprint(mut config: Config, args: &ArgMatches) -> Result<(), anyhow::Error> {
     let server = args.get_one::<String>("server").unwrap().as_str();
     let force = args.get_flag("force");
-    let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+    let url = config.get_host_url(Some(server))?;
 
     let (host, protocol) = host_or_url_to_host_and_protocol(server);
-    if update_server_fingerprint(&mut config, Some(host), cert_path, protocol).await? {
+    println!("!!! {:#?}\n{:#?}\n{:#?}", host, server, url);
+    if update_server_fingerprint(
+        &mut config,
+        Some(host),
+        protocol,
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+    ).await.map_err(|e| spacetimedb_lib::map_request_error(e, &url, client_cert_path.as_deref(), client_key_path.as_deref()))? {
         if !y_or_n(force, "Continue?")? {
             anyhow::bail!("Aborted");
         }
@@ -327,11 +389,120 @@ pub async fn exec_fingerprint(mut config: Config, args: &ArgMatches) -> Result<(
 pub async fn exec_ping(config: Config, args: &ArgMatches) -> Result<(), anyhow::Error> {
     let server = args.get_one::<String>("server").unwrap().as_str();
     let url = config.get_host_url(Some(server))?;
-    let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
-
-    let client = build_client(cert_path).await?;
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+    let client = build_client(
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+    ).await?;
     let builder = client.get(format!("{}/v1/ping", url).as_str());
-    let response = builder.send().await?;
+    let response = builder.send().await.map_err(|e| spacetimedb_lib::map_request_error(e, &url, client_cert_path.as_deref(), client_key_path.as_deref()))?;
+//        {
+//        use std::error::Error;//help: items from traits can only be used if the trait is in scope
+//        /*doneFIXME: find out why I got this only once: it's this https://github.com/seanmonstar/reqwest/issues/1808 and possibly https://github.com/hyperium/hyper/issues/2136  but basically it's because client doesn't expect server to reply because client didn't request(HTTP1) anything first in order to expect a reply, so if both  reply and close  are happening on server then some race happens where mostly closed connection is handled first, even tho the reply itself is already gotten.
+//         * https://github.com/seanmonstar/reqwest/issues/2649
+//         * https://github.com/hyperium/hyper-util/pull/184
+//         *
+//$ spacetime server ping slocal --cert ../my/spacetimedb-cert-gen/ca.crt
+//WARNING: This command is UNSTABLE and subject to breaking changes.
+//
+//Adding trusted root cert(for server verification): subject=CN=MyLocalCA, issuer=CN=MyLocalCA, serial=359627719638463223090969970838819027680303337392, expires=Mar 24 13:24:50 2035 +00:00, fingerprint=25bb314ec76db8ab97f225011ec24dd0bca8aff470cb21c812600a8f4ed0cca7
+//Error: Failed sending request to https://127.0.0.1:3000: Failed to construct or send the HTTP request, source: Some(
+//    hyper_util::client::legacy::Error(
+//        Canceled,
+//        hyper::Error(
+//            Canceled,
+//            hyper::Error(
+//                Io,
+//                Custom {
+//                    kind: Other,
+//                    error: Error {
+//                        code: ErrorCode(
+//                            1,
+//                        ),
+//                        cause: Some(
+//                            Ssl(
+//                                ErrorStack(
+//                                    [
+//                                        Error {
+//                                            code: 167773276,
+//                                            library: "SSL routines",
+//                                            function: "ssl3_read_bytes",
+//                                            reason: "tlsv13 alert certificate required",
+//                                            file: "ssl/record/rec_layer_s3.c",
+//                                            line: 908,
+//                                            data: "SSL alert number 116",
+//                                        },
+//                                    ],
+//                                ),
+//                            ),
+//                        ),
+//                    },
+//                },
+//            ),
+//        ),
+//    ),
+//)
+//
+//
+//XXX: and why I get instead this:
+//
+//$ spacetime server ping slocal --cert ../my/spacetimedb-cert-gen/ca.crt
+//WARNING: This command is UNSTABLE and subject to breaking changes.
+//
+//Adding trusted root cert(for server verification): subject=CN=MyLocalCA, issuer=CN=MyLocalCA, serial=359627719638463223090969970838819027680303337392, expires=Mar 24 13:24:50 2035 +00:00, fingerprint=25bb314ec76db8ab97f225011ec24dd0bca8aff470cb21c812600a8f4ed0cca7
+//Error: Failed sending request to https://127.0.0.1:3000: Server closed the connection because you did NOT provide the args --client-cert and --client-key for mutual TLS (mTLS), source: Some(
+//    hyper_util::client::legacy::Error(
+//        SendRequest,
+//        hyper::Error(
+//            ChannelClosed,
+//        ),
+//    ),
+//)
+//
+//        */
+//        let error_details = 'error_details: {
+//            let mut source = e.source();
+//            while let Some(err) = source {
+//                if let Some(hyper_err) = err.downcast_ref::<hyper::Error>() {
+//                    if hyper_err.is_closed() {
+//                        break 'error_details if client_cert_path.is_none() && client_key_path.is_none() {
+//                            "Server closed the connection likely because you did NOT provide the args --client-cert and --client-key for mutual TLS (mTLS) and server requires it, also you need the hyper-util patch which affects hyper/reqwest and makes them not hide connection errors behind ChannelClosed from here: https://github.com/hyperium/hyper-util/pull/184"
+//                        } else {
+//                            "Connection channel closed unexpectedly (server may be down or misconfigured), you should have this PR https://github.com/hyperium/hyper-util/pull/184 applied to avoid hiding the real reason behind ChannelClosed error(s)."
+//                        };
+//                    }
+//                }
+//                source = err.source();
+//            }
+//            if e.is_connect() {
+//                "Failed to connect to the server (connection refused or network unreachable)"
+//            } else if e.is_timeout() {
+//                "Request timed out while trying to reach the server"
+//            } else if e.is_request() {
+//                "Failed to construct or send the HTTP request"
+//            } else if e.is_body() {
+//                "Error in the request body"
+//            } else if e.is_decode() {
+//                "Failed to decode the response"
+//            } else if let Some(source) = e.source() {
+//                &format!("Unexpected error: {}", source)
+//            } else {
+//                "Unknown error occurred while sending request"
+//            }
+//        };
+//        anyhow::anyhow!("Failed sending request to {}, err: {}, source: {:#?}", url, error_details, e.source())
+//    })?;
 
     match response.status() {
         reqwest::StatusCode::OK => {
@@ -390,8 +561,24 @@ pub async fn exec_edit(mut config: Config, args: &ArgMatches) -> Result<(), anyh
         if no_fingerprint {
             config.delete_server_fingerprint(Some(&new_url))?;
         } else {
-            let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
-            update_server_fingerprint(&mut config, Some(&new_url), cert_path, new_proto).await?;
+            // TLS arguments
+            let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+            let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+            let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+            // for clients, default to true unless --no-trust-system-root-store
+            // because this is used to verify the received server cert which can be signed by public CA
+            // thus using system's trust/root store, by default, makes sense.
+            let trust_system = !args.get_flag("no-trust-system-root-store");
+            update_server_fingerprint(
+                &mut config,
+                Some(&new_url),
+                new_proto,
+                trust_server_cert_path,
+                client_cert_path,
+                client_key_path,
+                trust_system,
+            ).await?;
         }
     }
 
diff --git a/crates/cli/src/subcommands/sql.rs b/crates/cli/src/subcommands/sql.rs
index f0fe745d..28e4a4a9 100644
--- a/crates/cli/src/subcommands/sql.rs
+++ b/crates/cli/src/subcommands/sql.rs
@@ -6,7 +6,7 @@ use std::path::Path;
 use crate::api::{from_json_seed, ClientApi, Connection, SqlStmtResult, StmtStats};
 use crate::common_args;
 use crate::config::Config;
-use crate::util::{database_identity, get_auth_header, ResponseExt, UNSTABLE_WARNING, build_client};
+use crate::util::{self, database_identity, get_auth_header, ResponseExt, UNSTABLE_WARNING};
 use anyhow::Context;
 use clap::{Arg, ArgAction, ArgMatches};
 use reqwest::RequestBuilder;
@@ -39,23 +39,43 @@ pub fn cli() -> clap::Command {
         .arg(common_args::anonymous())
         .arg(common_args::server().help("The nickname, host name or URL of the server hosting the database"))
         .arg(common_args::yes())
-        .arg(common_args::cert())
+        //.arg(common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
 }
 
-pub(crate) async fn parse_req(mut config: Config, args: &ArgMatches, cert_path: Option<&Path>) -> Result<Connection, anyhow::Error> {
+pub(crate) async fn parse_req(
+    mut config: Config,
+    args: &ArgMatches,
+    trust_server_cert_path: Option<&Path>,
+    client_cert_path: Option<&Path>,
+    client_key_path: Option<&Path>,
+    trust_system: bool,
+    ) -> Result<Connection, anyhow::Error> {
     let server = args.get_one::<String>("server").map(|s| s.as_ref());
     let force = args.get_flag("force");
     let database_name_or_identity = args.get_one::<String>("database").unwrap();
     let anon_identity = args.get_flag("anon_identity");
 
-    let client = build_client(cert_path).await?;
+    let client = util::build_client(
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+    ).await?;
 
     Ok(Connection {
         host: config.get_host_url(server)?,
         auth_header: get_auth_header(&mut config, anon_identity, server, !force).await?,
         database_identity: database_identity(&config, database_name_or_identity, server, &client).await?,
         database: database_name_or_identity.to_string(),
-        cert_path: cert_path.map(PathBuf::from),
+        trust_server_cert_path: trust_server_cert_path.map(PathBuf::from),
+        client_cert_path: client_cert_path.map(PathBuf::from),
+        client_key_path: client_key_path.map(PathBuf::from),
+        trust_system,
     })
 }
 
@@ -177,16 +197,29 @@ fn stmt_result_to_table(stmt_result: &SqlStmtResult) -> anyhow::Result<(StmtStat
 
 pub async fn exec(config: Config, args: &ArgMatches) -> Result<(), anyhow::Error> {
     eprintln!("{}\n", UNSTABLE_WARNING);
-    let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+    let con = parse_req(config, args,
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+    ).await?;
+
     let interactive = args.get_one::<bool>("interactive").unwrap_or(&false);
     if *interactive {
-        let con = parse_req(config, args, cert_path).await?;
-
         crate::repl::exec(con).await?;
     } else {
         let query = args.get_one::<String>("query").unwrap();
 
-        let con = parse_req(config, args, cert_path).await?;
         let api = ClientApi::new(con);
 
         run_sql(api.sql(), query, false).await?;
diff --git a/crates/cli/src/subcommands/subscribe.rs b/crates/cli/src/subcommands/subscribe.rs
index f14082b5..7eddd08f 100644
--- a/crates/cli/src/subcommands/subscribe.rs
+++ b/crates/cli/src/subcommands/subscribe.rs
@@ -17,8 +17,9 @@ use tokio_tungstenite::tungstenite::Message as WsMessage;
 use crate::api::ClientApi;
 use crate::common_args;
 use crate::sql::parse_req;
-use crate::util::{self, UNSTABLE_WARNING};
+use crate::util::UNSTABLE_WARNING;
 use crate::Config;
+use std::path::{Path, PathBuf};
 
 pub fn cli() -> clap::Command {
     clap::Command::new("subscribe")
@@ -66,7 +67,12 @@ pub fn cli() -> clap::Command {
                 .action(ArgAction::SetTrue)
                 .help("Print the initial update for the queries."),
         )
-        .arg(common_args::cert())
+        //.arg(common_args::cert())
+        .arg(common_args::trust_server_cert())
+        .arg(common_args::client_cert())
+        .arg(common_args::client_key())
+        .arg(common_args::trust_system_root_store())
+        .arg(common_args::no_trust_system_root_store())
         .arg(common_args::anonymous())
         .arg(common_args::yes())
         .arg(common_args::server().help("The nickname, host name or URL of the server hosting the database"))
@@ -133,8 +139,22 @@ pub async fn exec(config: Config, args: &ArgMatches) -> Result<(), anyhow::Error
     let timeout = args.get_one::<u32>("timeout").copied();
     let print_initial_update = args.get_flag("print_initial_update");
 
-    let cert_path = args.get_one::<std::path::PathBuf>("cert").map(|p| p.as_path());
-    let conn = parse_req(config, args, cert_path).await?;
+    // TLS arguments
+    let trust_server_cert_path: Option<&Path> = args.get_one::<PathBuf>("trust-server-cert").map(|p| p.as_path());
+    let client_cert_path: Option<&Path> = args.get_one::<PathBuf>("client-cert").map(|p| p.as_path());
+    let client_key_path: Option<&Path> = args.get_one::<PathBuf>("client-key").map(|p| p.as_path());
+
+    // for clients, default to true unless --no-trust-system-root-store
+    // because this is used to verify the received server cert which can be signed by public CA
+    // thus using system's trust/root store, by default, makes sense.
+    let trust_system = !args.get_flag("no-trust-system-root-store");
+
+    let conn = parse_req(config, args,
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+        ).await?;
     let api = ClientApi::new(conn);
     let module_def = api.module_def().await?;
 
@@ -162,12 +182,66 @@ pub async fn exec(config: Config, args: &ArgMatches) -> Result<(), anyhow::Error
     }
 
     // Configure TLS with cert_path
-    let connector = {
-        // Changed: Use native-tls like websocket.rs
+    let connector = if req.uri().scheme_str() != Some("wss") {
+        let b:bool=trust_server_cert_path.is_some() || client_cert_path.is_some() || client_key_path.is_some();
+        if b {
+            return Err(anyhow::anyhow!("Using cert(s)/key require using https:// scheme not http://"));
+        }
+        None
+    } else {
         let mut builder = native_tls::TlsConnector::builder();
-        if let Some(cert) = util::load_root_cert(api.con.cert_path.as_deref()).await? {
-            builder.add_root_certificate(cert);
+        
+        // Validate trust store
+        if !trust_system && trust_server_cert_path.is_none() {
+            return Err(anyhow::anyhow!(
+                "--no-trust-system-root-store requires --trust-server-cert"
+            ));
+        }
+        if !trust_system {
+            builder.disable_built_in_roots(true);
+        }
+
+        if let Some(cert_path) = trust_server_cert_path {
+            let cert_data = spacetimedb_lib::read_file_limited(cert_path)
+                .await
+                .context(format!("Failed to read cert file: {}", cert_path.display()))?;
+            let certs = rustls_pemfile::certs(&mut std::io::Cursor::new(cert_data))
+                .collect::<Result<Vec<_>, _>>()
+                .context(format!("Failed to parse trust certificates: {}", cert_path.display()))?;
+            if certs.is_empty() {
+                return Err(anyhow::anyhow!(
+                    "No valid certificates in: {}",
+                    cert_path.display()
+                ));
+            }
+            for cert in certs {
+                //TODO: show me added certs like we do in other places!
+                let native_cert = native_tls::Certificate::from_der(&cert).context(format!(
+                    "Failed to convert cert to native-tls format from {}",
+                    cert_path.display()
+                ))?;
+                builder.add_root_certificate(native_cert);
+            }
         }
+
+        // Configure mTLS
+        if let Some(cert_path) = client_cert_path {
+            let key_path = client_key_path.ok_or_else(|| {
+                anyhow::anyhow!("--client-key is required with --client-cert")
+            })?;
+            let cert_data = spacetimedb_lib::read_file_limited(cert_path)
+                .await
+                .context(format!("Failed to read client cert: {}", cert_path.display()))?;
+            let key_data = spacetimedb_lib::read_file_limited(key_path)
+                .await
+                .context(format!("Failed to read client key: {}", key_path.display()))?;
+            let identity = native_tls::Identity::from_pkcs8(&cert_data, &key_data).context(format!(
+                "Failed to parse client cert/key: {}",
+                cert_path.display()
+            ))?;
+            builder.identity(identity);
+        }
+
         let tls_connector = builder.build().context("Failed to build TLS connector")?;
         Some(tokio_tungstenite::Connector::NativeTls(tls_connector))
     };
diff --git a/crates/cli/src/util.rs b/crates/cli/src/util.rs
index 6181206d..21d85b86 100644
--- a/crates/cli/src/util.rs
+++ b/crates/cli/src/util.rs
@@ -1,3 +1,4 @@
+use anyhow::anyhow;
 use anyhow::Context;
 use base64::{engine::general_purpose::STANDARD_NO_PAD as BASE_64_STD_NO_PAD, Engine as _};
 use reqwest::{RequestBuilder, Url};
@@ -10,6 +11,7 @@ use std::path::Path;
 use crate::config::Config;
 use crate::login::{spacetimedb_login_force, DEFAULT_AUTH_HOST};
 pub use spacetimedb_lib::load_root_cert;
+pub use spacetimedb_lib::read_file_limited;
 
 pub const UNSTABLE_WARNING: &str = "WARNING: This command is UNSTABLE and subject to breaking changes.";
 
@@ -109,27 +111,135 @@ impl ResponseExt for reqwest::Response {
 }
 
 
-pub async fn configure_tls(cert_path: Option<&Path>) -> anyhow::Result<reqwest::ClientBuilder> {
-    let mut client_builder = reqwest::Client::builder();
-    if let Some(cert) = load_root_cert(cert_path).await? {
-        let path:String=cert_path.map_or("<unexpected empty path>".to_string(), |p| p.display().to_string());
-        let reqwest_cert = reqwest::Certificate::from_der(&cert.to_der()
-            .context(format!("Failed to convert certificate to DER for: {}", path))?)
-            .context(format!("Invalid certificate: {}", path))?;
-        client_builder = client_builder.add_root_certificate(reqwest_cert);
+//pub async fn configure_tls(cert_path: Option<&Path>) -> anyhow::Result<reqwest::ClientBuilder> {
+//    let mut client_builder = reqwest::Client::builder();
+//    if let Some(cert) = load_root_cert(cert_path).await? {
+//        let path:String=cert_path.map_or("<unexpected empty path>".to_string(), |p| p.display().to_string());
+//        let reqwest_cert = reqwest::Certificate::from_der(&cert.to_der()
+//            .context(format!("Failed to convert certificate to DER for: {}", path))?)
+//            .context(format!("Invalid certificate: {}", path))?;
+//        client_builder = client_builder.add_root_certificate(reqwest_cert);
+//    }
+//    Ok(client_builder)
+//}
+pub async fn configure_tls(
+    trust_server_cert_path: Option<&Path>,
+    client_cert_path: Option<&Path>,
+    client_key_path: Option<&Path>,
+    trust_system: bool,
+//    no_trust_system: bool,
+) -> anyhow::Result<reqwest::ClientBuilder> {
+    let mut client_builder = reqwest::Client::builder().use_native_tls();
+
+    client_builder = if trust_system {
+        //TODO: find out if this method is taking /etc/ssl/ system trust store certs or what!
+        client_builder.tls_built_in_root_certs(true)
+    } else {
+        eprintln!("Not trusting system/root cert store.");
+        client_builder.tls_built_in_root_certs(false)
+    };
+//    // Validate trust store options
+//    if no_trust_system && trust_cert_path.is_none() {
+//        //XXX: probably never hit due to clap enforcing this.
+//        return Err(anyhow!("--no-trust-system-root-store requires --trust-server-cert"));
+//    }
+
+    // Load trust certificates
+    if let Some(path) = trust_server_cert_path {
+        let cert_data = read_file_limited(path).await?;
+        let certs = rustls_pemfile::certs(&mut std::io::Cursor::new(cert_data))
+            .collect::<Result<Vec<_>, _>>()
+            .context(format!("Failed to parse trust certificate(s): {}", path.display()))?;
+        if certs.is_empty() {
+            return Err(anyhow!("No valid certificate(s) in: {}", path.display()));
+        }
+        use x509_parser::prelude::FromDer;
+        use sha2::Digest;
+        for cert in certs {
+//            // Parse and log cert details
+//            if let Ok((_, parsed)) = x509_parser::prelude::X509Certificate::from_der(cert.as_ref()) {
+//                let subject = parsed.subject().to_string();
+//                let issuer = parsed.issuer().to_string();
+//                let not_after = parsed.validity().not_after.to_string();
+//                let serial = parsed.serial.to_string();
+//                let fingerprint = format!("{:x}", sha2::Sha256::digest(cert.as_ref()));
+//                log::info!(
+//                    "Client root cert: subject={}, issuer={}, serial={}, expires={}, fingerprint={}",
+//                    subject, issuer, serial, not_after, fingerprint
+//                );
+//            } else {
+//                log::warn!("Failed to parse client root cert from file: '{}'",path.display());
+//            }
+            // Parse and log cert details
+            let (_, parsed) = x509_parser::prelude::X509Certificate::from_der(cert.as_ref())
+                .context(format!("Failed to parse cert from {}", path.display()))?;
+            let subject = parsed.subject().to_string();
+            let issuer = parsed.issuer().to_string();
+            let not_after = parsed.validity().not_after.to_string();
+            let serial = parsed.serial.to_string();
+            let fingerprint = format!("{:x}", sha2::Sha256::digest(cert.as_ref()));
+            //log::info!(
+            eprintln!(
+                "Adding trusted root cert(for server verification): subject={}, issuer={}, serial={}, expires={}, fingerprint={}",
+                subject, issuer, serial, not_after, fingerprint
+            );
+            let reqwest_cert = reqwest::Certificate::from_der(&cert).context(format!("Failed to convert cert to reqwest format from {}", path.display()))?;
+            client_builder = client_builder.add_root_certificate(reqwest_cert);
+        }
+    }
+
+    // Configure client authentication aka mTLS
+    if let Some(cert_path) = client_cert_path {
+        //FIXME: clap ensures this, so if this is failing it's a different reason?:
+        let key_path = client_key_path.ok_or_else(|| anyhow!("--client-key is required with --client-cert"))?;
+        let cert_data = read_file_limited(cert_path).await?;
+        let key_data = read_file_limited(key_path).await?;
+        //let identity = reqwest::Identity::from_pkcs8_pem(&[&cert_data[..], &key_data[..]].concat())
+        let identity = reqwest::Identity::from_pkcs8_pem(&cert_data, &key_data)
+            .context(format!("Failed to parse client cert/key: {}", cert_path.display()))?;
+        client_builder = client_builder.identity(identity);
     }
+
     Ok(client_builder)
 }
 
-pub fn build_client_with_context(builder: reqwest::ClientBuilder, cert_path: Option<&Path>) -> anyhow::Result<reqwest::Client> {
+pub fn build_client_with_context(
+    builder: reqwest::ClientBuilder,
+    trust_server_cert_path: Option<&Path>,
+    client_cert_path: Option<&Path>,
+    client_key_path: Option<&Path>,
+    trust_system: bool,
+    ) -> anyhow::Result<reqwest::Client> {
     builder
         .build()
-        .context(format!("Failed to build client with cert {:?}", cert_path))
+        .context(
+            format!("Failed to build client with trusted (server)cert(s) {:?}, with client cert(s): {:?}, with client private key: {:?}, while {} system/root cert store.",
+            trust_server_cert_path,
+            client_cert_path,
+            client_key_path,
+            if trust_system { "trusting" } else { "NOT trusting" },
+            )
+        )
 }
 
-pub async fn build_client(cert_path: Option<&Path>) -> anyhow::Result<reqwest::Client> {
-    let builder = configure_tls(cert_path).await?;
-    build_client_with_context(builder, cert_path)
+pub async fn build_client(
+    trust_server_cert_path: Option<&Path>,
+    client_cert_path: Option<&Path>,
+    client_key_path: Option<&Path>,
+    trust_system: bool,
+    ) -> anyhow::Result<reqwest::Client> {
+    let builder = configure_tls(
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+        ).await?;
+    build_client_with_context(builder,
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+    )
 }
 
 /// Converts a name to a database identity.
@@ -149,13 +259,24 @@ pub async fn spacetime_dns(
         .context("identity endpoint did not return an identity")
 }
 
-pub async fn spacetime_server_fingerprint(url: &str, cert_path: Option<&Path>) -> anyhow::Result<String> {
-    if let Some(_path) = cert_path {
+pub async fn spacetime_server_fingerprint(
+    url: &str,
+    trust_server_cert_path: Option<&Path>,
+    client_cert_path: Option<&Path>,
+    client_key_path: Option<&Path>,
+    trust_system: bool,
+    ) -> anyhow::Result<String> {
+    if let Some(_path) = trust_server_cert_path {
         if !url.starts_with("https") {
             eprintln!("WARNING: Non-https url '{url}' but --cert was specified.");
         }
     }
-    let builder = configure_tls(cert_path).await?;
+    let builder = configure_tls(
+        trust_server_cert_path,
+        client_cert_path,
+        client_key_path,
+        trust_system,
+        ).await?;
     let client = builder.build().map_err(|e| anyhow::anyhow!("Failed to build client: {}", e))?;
     let builder = client.get(format!("{}/v1/identity/public-key", url).as_str());
     let res = builder.send().await?.error_for_status()?;
@@ -347,9 +468,21 @@ pub async fn get_login_token_or_log_in(
 
     if full_login {
         let host = Url::parse(DEFAULT_AUTH_HOST)?;
-        spacetimedb_login_force(config, &host, false, None/*TODO*/).await
+        spacetimedb_login_force(config, &host, false,
+            /*TODO*/
+            None,
+            None,
+            None,
+            false,
+            ).await
     } else {
         let host = Url::parse(&config.get_host_url(target_server)?)?;
-        spacetimedb_login_force(config, &host, true, None/*TODO*/).await
+        spacetimedb_login_force(config, &host, true,
+            /*TODO*/
+            None,
+            None,
+            None,
+            false,
+            ).await
     }
 }
diff --git a/crates/lib/Cargo.toml b/crates/lib/Cargo.toml
index 01c26eb2..faa06dbc 100644
--- a/crates/lib/Cargo.toml
+++ b/crates/lib/Cargo.toml
@@ -43,8 +43,12 @@ thiserror.workspace = true
 blake3.workspace = true
 enum-map = { workspace = true, optional = true }
 tokio.workspace = true
-native-tls = "0.2"
+#native-tls = "0.2"
+native-tls.workspace=true
 clap.workspace = true
+hyper.workspace=true
+reqwest.workspace=true
+openssl.workspace=true
 
 # For the 'proptest' feature.
 proptest = { workspace = true, optional = true }
diff --git a/crates/lib/src/lib.rs b/crates/lib/src/lib.rs
index 583ddbee..e0e7c447 100644
--- a/crates/lib/src/lib.rs
+++ b/crates/lib/src/lib.rs
@@ -6,6 +6,9 @@ use spacetimedb_sats::{impl_serialize, WithTypespace};
 use std::any::TypeId;
 use std::collections::{btree_map, BTreeMap};
 
+use tokio::io::AsyncReadExt;
+
+
 pub mod connection_id;
 pub mod db;
 mod direct_index_key;
@@ -423,13 +426,610 @@ pub async fn load_root_cert(cert_path: Option<&std::path::Path>) -> anyhow::Resu
     }
 }
 
-pub fn cert() -> clap::Arg {
-    clap::Arg::new("cert")
-        .long("cert")
+//pub fn cert() -> clap::Arg {
+//    clap::Arg::new("cert")
+//        .long("cert")
+//        .value_name("FILE")
+//        .action(clap::ArgAction::Set)
+//        .value_parser(clap::value_parser!(std::path::PathBuf))
+//        .required(false)
+//        .help("Path to the servers self-signed certificate or CA certificate (PEM format) to trust during this command (ie. as if it were part of your system's cert root store)")
+//}
+
+//for cli clients:
+pub fn trust_server_cert() -> clap::Arg {
+    //TODO: rename this to trust_ca_cert() it's less confusing
+    clap::Arg::new("trust-server-cert")
+        .long("trust-server-cert")
+        .alias("trust-server-certs")
+        .alias("trust-server-cert-bundle")
+        .alias("cert")
+        .alias("certs")
+        .alias("cert-bundle")
+        .alias("root-cert")
+        .alias("root-certs")
+        .alias("root-cert-bundle")
+        .alias("trust-ca-cert")
+        .alias("trust-ca-certs")
+        .alias("trust-ca-cert-bundle")
+        .alias("ca-certs")
+        .alias("ca-cert")
+        .alias("ca-cert-bundle")
+        .value_name("FILE")
+        .action(clap::ArgAction::Set)
+        .value_parser(clap::value_parser!(std::path::PathBuf))
+        .required(false)
+//        .requires("ssl")
+        //.help("Path to PEM file containing certificates to trust for the server (e.g., CA or self-signed)")
+        .help("Path to the servers self-signed certificate or CA certificate (PEM format, can be a bundle ie. appended PEM certs) to trust during this command (ie. as if it were part of your system's cert trust/root store)")
+}
+
+//for the cli clients:
+pub fn client_cert() -> clap::Arg {
+    clap::Arg::new("client-cert")
+        .long("client-cert")
         .value_name("FILE")
         .action(clap::ArgAction::Set)
         .value_parser(clap::value_parser!(std::path::PathBuf))
         .required(false)
-        .help("Path to the servers self-signed certificate or CA certificate (PEM format) to trust during this command (ie. as if it were part of your system's cert root store)")
+//        .requires("ssl")
+        .help("Path to the clients certificate (PEM format) for authentication")
+}
+
+//for the cli clients:
+pub fn client_key() -> clap::Arg {
+    clap::Arg::new("client-key")
+        .long("client-key")
+        .value_name("FILE")
+        .action(clap::ArgAction::Set)
+        .value_parser(clap::value_parser!(std::path::PathBuf))
+        .required(false)
+        .requires("client-cert")
+//        .requires("ssl")
+        .help("Path to the clients private key (PEM format) for authentication")
+}
+
+//for cli clients, this is the default(to trust):
+pub fn trust_system_root_store() -> clap::Arg {
+    clap::Arg::new("trust-system-root-store")
+        .long("trust-system-root-store")
+//        .alias("trust-root-store")
+        .action(clap::ArgAction::SetTrue)
+        .conflicts_with("no-trust-system-root-store")
+//        .requires("ssl")
+        .help("Use system root certificates (default)")
+}
+
+//for cli clients, setting this means only the --trust-server-certs arg is used to verify the
+//target server's cert):
+pub fn no_trust_system_root_store() -> clap::Arg {
+    clap::Arg::new("no-trust-system-root-store")
+        .long("no-trust-system-root-store")
+        .alias("empty-trust-store")
+//        .alias("no-trust-root-store")
+        .action(clap::ArgAction::SetTrue)
+        .conflicts_with("trust-system-root-store")
+        .requires("trust-server-cert")
+//        .requires("ssl")
+        .help("Use empty trust store (requires --trust-server-cert else there'd be 0 certs to verify trust)")
+}
+
+//for the standalone server:
+pub fn client_trust_cert() -> clap::Arg {
+    clap::Arg::new("client-trust-cert")
+        .long("client-trust-cert")
+        .alias("client-cert")
+        .alias("client-certs")
+        .alias("client-ca-cert")
+        .alias("client-root-cert")
+        .alias("client-trust-certs")
+        .alias("client-ca-certs")
+        .alias("client-root-certs")
+        .alias("client-cert-bundle")
+        .alias("client-trust-cert-bundle")
+        .alias("client-ca-cert-bundle")
+        .alias("client-root-cert-bundle")
+        .value_name("FILE")
+        .action(clap::ArgAction::Set)
+        .value_parser(clap::value_parser!(std::path::PathBuf))
+        .requires("ssl")
+        .required(false)
+        .help("Path to PEM file containing certificate(s) to trust for client authentication (e.g., CA or self-signed)")
+}
+
+//for the standalone server:
+pub fn client_trust_system_root_store() -> clap::Arg {
+    clap::Arg::new("client-trust-system-root-store")
+        .long("client-trust-system-root-store")
+        .action(clap::ArgAction::SetTrue)
+        .conflicts_with("client-no-trust-system-root-store")
+        .requires("ssl")
+        .help("Use system root certificates for client authentication (unusual)")
 }
 
+//for the standalone server:
+pub fn client_no_trust_system_root_store() -> clap::Arg {
+    clap::Arg::new("client-no-trust-system-root-store")
+        .long("client-no-trust-system-root-store")
+        .alias("client-empty-trust-store")
+        .action(clap::ArgAction::SetTrue)
+        .conflicts_with("client-trust-system-root-store")
+        .requires("client-trust-cert")
+        .requires("ssl")
+        .help("Use empty trust store for client authentication (default), requires --client-trust-cert to validate client certs somehow.")
+}
+
+/// Asynchronously reads a file with a maximum size limit of 1 MiB.
+pub async fn read_file_limited(path: &std::path::Path) -> anyhow::Result<Vec<u8>> {
+    const MAX_SIZE: usize = 1_048_576; // 1 MiB
+
+    let file = tokio::fs::File::open(path)
+        .await
+        .map_err(|e| anyhow::anyhow!("Failed to open file {}: {}", path.display(), e))?;
+    let metadata = file
+        .metadata()
+        .await
+        .map_err(|e| anyhow::anyhow!("Failed to read metadata for {}: {}", path.display(), e))?;
+
+    if metadata.len() > MAX_SIZE as u64 {
+        return Err(anyhow::anyhow!(
+            "File {} exceeds maximum size of {} bytes",
+            path.display(),
+            MAX_SIZE
+        ));
+    }
+
+    let mut reader = tokio::io::BufReader::new(file);
+    let mut data = Vec::with_capacity(metadata.len() as usize);
+    reader
+        .read_to_end(&mut data)
+        .await
+        .map_err(|e| anyhow::anyhow!("Failed to read file {}: {}", path.display(), e))?;
+
+    Ok(data)
+}
+
+//        /*doneFIXME: find out why I got the following error only once.
+//        ok it's this https://github.com/seanmonstar/reqwest/issues/1808 and possibly https://github.com/hyperium/hyper/issues/2136  but basically it's because client doesn't expect server to reply because client didn't request(HTTP1) anything first in order to expect a reply, so if both  reply and close  are happening on server then some race happens where mostly closed connection is handled first, even tho the reply itself is already gotten.
+//         * https://github.com/seanmonstar/reqwest/issues/2649
+//         * https://github.com/hyperium/hyper-util/pull/184
+//         *
+//$ spacetime server ping slocal --cert ../my/spacetimedb-cert-gen/ca.crt
+//WARNING: This command is UNSTABLE and subject to breaking changes.
+//
+//Adding trusted root cert(for server verification): subject=CN=MyLocalCA, issuer=CN=MyLocalCA, serial=359627719638463223090969970838819027680303337392, expires=Mar 24 13:24:50 2035 +00:00, fingerprint=25bb314ec76db8ab97f225011ec24dd0bca8aff470cb21c812600a8f4ed0cca7
+//Error: Failed sending request to https://127.0.0.1:3000: Failed to construct or send the HTTP request, source: Some(
+//    hyper_util::client::legacy::Error(
+//        Canceled,
+//        hyper::Error(
+//            Canceled,
+//            hyper::Error(
+//                Io,
+//                Custom {
+//                    kind: Other,
+//                    error: Error {
+//                        code: ErrorCode(
+//                            1,
+//                        ),
+//                        cause: Some(
+//                            Ssl(
+//                                ErrorStack(
+//                                    [
+//                                        Error {
+//                                            code: 167773276,
+//                                            library: "SSL routines",
+//                                            function: "ssl3_read_bytes",
+//                                            reason: "tlsv13 alert certificate required",
+//                                            file: "ssl/record/rec_layer_s3.c",
+//                                            line: 908,
+//                                            data: "SSL alert number 116",
+//                                        },
+//                                    ],
+//                                ),
+//                            ),
+//                        ),
+//                    },
+//                },
+//            ),
+//        ),
+//    ),
+//)
+//
+//
+//XXX: and why I get instead this:
+//
+//$ spacetime server ping slocal --cert ../my/spacetimedb-cert-gen/ca.crt
+//WARNING: This command is UNSTABLE and subject to breaking changes.
+//
+//Adding trusted root cert(for server verification): subject=CN=MyLocalCA, issuer=CN=MyLocalCA, serial=359627719638463223090969970838819027680303337392, expires=Mar 24 13:24:50 2035 +00:00, fingerprint=25bb314ec76db8ab97f225011ec24dd0bca8aff470cb21c812600a8f4ed0cca7
+//Error: Failed sending request to https://127.0.0.1:3000: Server closed the connection because you did NOT provide the args --client-cert and --client-key for mutual TLS (mTLS), source: Some(
+//    hyper_util::client::legacy::Error(
+//        SendRequest,
+//        hyper::Error(
+//            ChannelClosed,
+//        ),
+//    ),
+//)
+//
+//        */
+
+
+////last known working variant2: good, has fn-s
+//use std::path::Path;
+////use openssl::ssl::Error as SslError;
+////use openssl::error::ErrorStack;
+//use std::error::Error;//help: trait `Error` which provides `source` is implemented but not in scope; perhaps you want to import it
+//
+//
+//pub fn map_request_error<E: Into<anyhow::Error>>(
+//    e: E,
+//    url: &String,
+//    client_cert_path: Option<&Path>,
+//    client_key_path: Option<&Path>,
+//) -> anyhow::Error {
+//    let e = e.into();
+//    let mut last_message = "Unknown error occurred";
+//    let mut max_specificity = 0; // 0: Unknown, 1: reqwest, 2: ChannelClosed, 3: tlsv13 alert
+//
+//    // Helper to check TLS alerts using ErrorStack
+//    fn check_tls_alert(
+//        ssl_error: &openssl::ssl::Error,
+//        client_cert_path: Option<&Path>,
+//        client_key_path: Option<&Path>,
+//    ) -> Option<(&'static str, i32)> {
+//        if ssl_error
+//            .ssl_error()
+//            .map(|stack: &openssl::error::ErrorStack| {
+//                stack
+//                    .errors()
+//                    .iter()
+//                    .any(|e| e.reason() == Some("tlsv13 alert certificate required"))
+//            })
+//            .unwrap_or(false)
+//        {
+//            return Some((
+//                if client_cert_path.is_none() && client_key_path.is_none() {
+//                    "You didn't pass the required client certificate(yours) for mTLS, use --client-cert and --client-key"
+//                } else {
+//                    "TLS handshake failed: server requires a valid client certificate for mTLS"
+//                },
+//                3,
+//            ));
+//        }
+//        None
+//    }
+//
+//    // Helper for hyper::Error checks
+//    fn check_hyper_error(
+//        hyper_err: &hyper::Error,
+//        client_cert_path: Option<&Path>,
+//        client_key_path: Option<&Path>,
+//    ) -> Option<(&'static str, i32)> {
+//        if hyper_err.is_closed() {
+//            return Some((
+//                if client_cert_path.is_none() && client_key_path.is_none() {
+//                    "Server closed the connection likely because you did NOT provide the args --client-cert and --client-key for mutual TLS (mTLS) and server requires it, also you need the hyper-util patch which affects hyper/reqwest and makes them not hide connection errors behind ChannelClosed from here: https://github.com/hyperium/hyper-util/pull/184  which means that's why you're seeing this generic error."
+//                } else {
+//                    "Connection channel closed unexpectedly (server may be down or misconfigured), you should have this PR https://github.com/hyperium/hyper-util/pull/184 applied to avoid hiding the real reason behind ChannelClosed error(s)."
+//                },
+//                2,
+//            ));
+//        }
+//        if let Some(io_err) = hyper_err.source() {
+//            if let Some(ssl_err) = io_err.downcast_ref::<std::io::Error>() {
+//                if let Some(openssl_err) = ssl_err.get_ref() {
+//                    if let Some(ssl_error) = openssl_err.downcast_ref::<openssl::ssl::Error>() {
+//                        return check_tls_alert(ssl_error, client_cert_path, client_key_path);
+//                    }
+//                }
+//            }
+//        }
+//        None
+//    }
+//
+//    // Helper for reqwest::Error checks
+//    fn check_reqwest_error(reqwest_err: &reqwest::Error) -> Option<(&'static str, i32)> {
+//        if reqwest_err.is_connect() {
+//            return Some(("Failed to connect to the server (connection refused or network unreachable)", 1));
+//        } else if reqwest_err.is_timeout() {
+//            return Some(("Request timed out while trying to reach the server", 1));
+//        } else if reqwest_err.is_request() {
+//            return Some(("Failed to construct or send the HTTP request", 1));
+//        } else if reqwest_err.is_body() {
+//            return Some(("Error in the request body", 1));
+//        } else if reqwest_err.is_decode() {
+//            return Some(("Failed to decode the response", 1));
+//        }
+//        None
+//    }
+//
+////    // doneFIXME: duplicated code block logic, dedup? also TODO: check what grok3 made in this function.
+////    // Check the top-level error (anyhow::Error)
+////    if let Some(hyper_err) = e.downcast_ref::<hyper::Error>() {
+////        if let Some((msg, spec)) = check_hyper_error(hyper_err, client_cert_path, client_key_path) {
+////            if spec > max_specificity {
+////                last_message = msg;
+////                max_specificity = spec;
+////            }
+////        }
+////    } else if let Some(reqwest_err) = e.downcast_ref::<reqwest::Error>() {
+////        if let Some((msg, spec)) = check_reqwest_error(reqwest_err) {
+////            if spec > max_specificity {
+////                last_message = msg;
+////                max_specificity = spec;
+////            }
+////        }
+////    }
+//
+//    // Traverse the error source chain
+//    //let mut source = e.source();
+////    if e.is_some() {
+////    let e=e.unwrap();
+//    //let mut source:Option<&(dyn Error + 'static)> = Some(e.down);
+//    //let mut source:Option<&(dyn Error + 'static)> = e.downcast_ref::<dyn std::error::Error>();
+//    //let mut source: Option<&dyn std::error::Error> = Some(&e);
+//    //use std::error::Error as StdError;
+//    //let mut source: Option<&dyn StdError> = Some(&e as &dyn StdError);
+//    let mut source: Option<&dyn Error> = Some(e.as_ref());//compile ok
+//    //let mut source: Option<&dyn Error> = Some(&e);//compile error
+//    while let Some(err) = source {
+//        if let Some(hyper_err) = err.downcast_ref::<hyper::Error>() {
+//            if let Some((msg, spec)) = check_hyper_error(hyper_err, client_cert_path, client_key_path) {
+//                if spec > max_specificity {
+//                    last_message = msg;
+//                    max_specificity = spec;
+//                }
+//            }
+//        } else if let Some(reqwest_err) = err.downcast_ref::<reqwest::Error>() {
+//            if let Some((msg, spec)) = check_reqwest_error(reqwest_err) {
+//                if spec > max_specificity {
+//                    last_message = msg;
+//                    max_specificity = spec;
+//                }
+//            }
+//        }
+//        source = err.source();
+//    }
+////    }
+//
+//    anyhow::anyhow!(
+//        "Failed sending request to {}, err: {}, source: {:#?}\n{}",
+//        url,
+//        last_message,
+//        e.source(),
+//        last_message, // easier to see if it's last
+//    )
+//}
+
+//use std::path::Path;
+//use std::error::Error;//help: trait `Error` which provides `source` is implemented but not in scope; perhaps you want to import it
+//
+//pub fn map_request_error<E: Into<anyhow::Error>>(
+//    e: E,
+//    url: &String,
+//    client_cert_path: Option<&Path>,
+//    client_key_path: Option<&Path>,
+//) -> anyhow::Error {
+//    let e = e.into();
+//    let mut last_message = "Unknown error occurred";
+//    let mut max_specificity = 0; // 0: Unknown, 1: reqwest, 2: ChannelClosed, 3: tlsv13 alert
+//
+//    // Helper to check TLS alerts using ErrorStack
+//    fn check_tls_alert(
+//        ssl_error: &openssl::ssl::Error,
+//        client_cert_path: Option<&Path>,
+//        client_key_path: Option<&Path>,
+//    ) -> Option<(&'static str, i32)> {
+//        if ssl_error
+//            .ssl_error()
+//            .map(|stack: &openssl::error::ErrorStack| {
+//                stack
+//                    .errors()
+//                    .iter()
+//                    .any(|e| e.reason() == Some("tlsv13 alert certificate required"))
+//            })
+//            .unwrap_or(false)
+//        {
+//            return Some((
+//                if client_cert_path.is_none() && client_key_path.is_none() {
+//                    "You didn't pass the required client certificate(yours) for mTLS, use --client-cert and --client-key "
+//                } else {
+//                    "TLS handshake failed: server requires a valid client certificate(yours) for mTLS "
+//                },
+//                3,
+//            ));
+//        }
+//        None
+//    }
+//
+//    // Helper for hyper::Error checks
+//    fn check_hyper_error(
+//        hyper_err: &hyper::Error,
+//        client_cert_path: Option<&Path>,
+//        client_key_path: Option<&Path>,
+//    ) -> Option<(&'static str, i32)> {
+//        if hyper_err.is_closed() {
+//            return Some((
+//                if client_cert_path.is_none() && client_key_path.is_none() {
+//                    "Server closed the connection likely because you did NOT provide the args --client-cert and --client-key for mutual TLS (mTLS) and server requires it, also you need the hyper-util patch which affects hyper/reqwest and makes them not hide connection errors behind ChannelClosed from here: https://github.com/hyperium/hyper-util/pull/184  which means that's why you're seeing this generic error."
+//                } else {
+//                    "Connection channel closed unexpectedly (server may be down or misconfigured), you should have this PR https://github.com/hyperium/hyper-util/pull/184 applied to avoid hiding the real reason behind ChannelClosed error(s)."
+//                },
+//                2,
+//            ));
+//        }
+//        if let Some(io_err) = hyper_err.source() {
+//            if let Some(ssl_err) = io_err.downcast_ref::<std::io::Error>() {
+//                if let Some(openssl_err) = ssl_err.get_ref() {
+//                    if let Some(ssl_error) = openssl_err.downcast_ref::<openssl::ssl::Error>() {
+//                        return check_tls_alert(ssl_error, client_cert_path, client_key_path);
+//                    }
+//                }
+//            }
+//        }
+//        None
+//    }
+//
+//    // Helper for reqwest::Error checks
+//    fn check_reqwest_error(reqwest_err: &reqwest::Error) -> Option<(&'static str, i32)> {
+//        if reqwest_err.is_connect() {
+//            return Some(("Failed to connect to the server (connection refused or network unreachable)", 1));
+//        } else if reqwest_err.is_timeout() {
+//            return Some(("Request timed out while trying to reach the server", 1));
+//        } else if reqwest_err.is_request() {
+//            return Some(("Failed to construct or send the HTTP request", 1));
+//        } else if reqwest_err.is_body() {
+//            return Some(("Error in the request body", 1));
+//        } else if reqwest_err.is_decode() {
+//            return Some(("Failed to decode the response", 1));
+//        }
+//        None
+//    }
+//
+////    // Unified error check
+////    fn check_error(
+////        err: &dyn std::error::Error,
+////        client_cert_path: Option<&Path>,
+////        client_key_path: Option<&Path>,
+////    ) -> Option<(&'static str, i32)> {
+////        if let Some(hyper_err) = err.downcast_ref::<hyper::Error>() {
+////            check_hyper_error(hyper_err, client_cert_path, client_key_path)
+////        } else if let Some(reqwest_err) = err.downcast_ref::<reqwest::Error>() {
+////            check_reqwest_error(reqwest_err)
+////        } else {
+////            None
+////        }
+////    }
+//    // Unified error check with explicit lifetime
+//    fn check_error<'a>(
+//        err: &'a dyn std::error::Error,
+//        client_cert_path: Option<&Path>,
+//        client_key_path: Option<&Path>,
+//    ) -> Option<(&'static str, i32)> {
+//        if let Some(hyper_err) = <dyn std::error::Error>::downcast_ref::<hyper::Error>(err) {
+//            check_hyper_error(hyper_err, client_cert_path, client_key_path)
+//        } else if let Some(reqwest_err) = <dyn std::error::Error>::downcast_ref::<reqwest::Error>(err) {
+//            check_reqwest_error(reqwest_err)
+//        } else {
+//            None
+//        }
+//    }
+//
+//    // Traverse the error chain using e.as_ref()
+//    let mut current: Option<&dyn std::error::Error> = Some(e.as_ref());
+//    while let Some(err) = current {
+//        if let Some((msg, spec)) = check_error(err, client_cert_path, client_key_path) {
+//            if spec > max_specificity {
+//                last_message = msg;
+//                max_specificity = spec;
+//            }
+//        }
+//        current = err.source();
+//    }
+//
+//    anyhow::anyhow!(
+//        "Failed sending request to {}, err: {}, source: {:#?}\n{}",
+//        url,
+//        last_message,
+//        e.source(),
+//        last_message, // easier to see if it's last
+//    )
+//}
+
+use std::path::Path;
+use std::error::Error;
+
+pub fn map_request_error<E: Into<anyhow::Error>>(
+    e: E,
+    url: &String,
+    client_cert_path: Option<&Path>,
+    client_key_path: Option<&Path>,
+) -> anyhow::Error {
+    let e = e.into();
+    let mut last_message = "Unknown error occurred";
+    let mut max_specificity = 0; // 0: Unknown, 1: reqwest, 2: ChannelClosed, 3: tlsv13 alert
+
+    // Traverse the error chain using e.as_ref()
+    let mut current: Option<&dyn std::error::Error> = Some(e.as_ref());
+    while let Some(err) = current {
+        // Check hyper::Error
+        if let Some(hyper_err) = err.downcast_ref::<hyper::Error>() {
+            if hyper_err.is_closed() {
+                let msg = (
+                    if client_cert_path.is_none() && client_key_path.is_none() {
+                        "Server closed the connection likely because you did NOT provide the args --client-cert and --client-key for mutual TLS (mTLS) and server requires it, also you need the hyper-util patch which affects hyper/reqwest and makes them not hide connection errors behind ChannelClosed from here: https://github.com/hyperium/hyper-util/pull/184 which means that's why you're seeing this generic error."
+                    } else {
+                        "Connection channel closed unexpectedly (server may be down or misconfigured), you should have this PR https://github.com/hyperium/hyper-util/pull/184 applied to avoid hiding the real reason behind ChannelClosed error(s)."
+                    },
+                    2,
+                );
+                if msg.1 > max_specificity {
+                    last_message = msg.0;
+                    max_specificity = msg.1;
+                }
+            }
+            if let Some(io_err) = hyper_err.source() {
+                if let Some(ssl_err) = io_err.downcast_ref::<std::io::Error>() {
+                    if let Some(openssl_err) = ssl_err.get_ref() {
+                        if let Some(ssl_error) = openssl_err.downcast_ref::<openssl::ssl::Error>() {
+                            if ssl_error
+                                .ssl_error()
+                                .map(|stack: &openssl::error::ErrorStack| {
+                                    stack
+                                        .errors()
+                                        .iter()
+                                        .any(|e| e.reason() == Some("tlsv13 alert certificate required"))
+                                })
+                                .unwrap_or(false)
+                            {
+                                let msg = (
+                                    if client_cert_path.is_none() && client_key_path.is_none() {
+                                        "You didn't pass the required client certificate(yours) for mTLS, use --client-cert and --client-key "
+                                    } else {
+                                        "TLS handshake failed: server requires a valid client certificate(yours) for mTLS "
+                                    },
+                                    3,
+                                );
+                                if msg.1 > max_specificity {
+                                    last_message = msg.0;
+                                    max_specificity = msg.1;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        // Check reqwest::Error
+        else if let Some(reqwest_err) = err.downcast_ref::<reqwest::Error>() {
+            let msg = if reqwest_err.is_connect() {
+                Some(("Failed to connect to the server (connection refused or network unreachable)", 1))
+            } else if reqwest_err.is_timeout() {
+                Some(("Request timed out while trying to reach the server", 1))
+            } else if reqwest_err.is_request() {
+                Some(("Failed to construct or send the HTTP request", 1))
+            } else if reqwest_err.is_body() {
+                Some(("Error in the request body", 1))
+            } else if reqwest_err.is_decode() {
+                Some(("Failed to decode the response", 1))
+            } else {
+                None
+            };
+            if let Some((msg, spec)) = msg {
+                if spec > max_specificity {
+                    last_message = msg;
+                    max_specificity = spec;
+                }
+            }
+        }
+        current = err.source();
+    }
+
+    anyhow::anyhow!(
+        "Failed sending request to {}, err: {}, source: {:#?}\n{}",
+        url,
+        last_message,
+        e.source(),
+        last_message
+    )
+}
diff --git a/crates/sdk/Cargo.toml b/crates/sdk/Cargo.toml
index 2d95cbbe..89ba431d 100644
--- a/crates/sdk/Cargo.toml
+++ b/crates/sdk/Cargo.toml
@@ -29,10 +29,15 @@ prometheus.workspace = true
 rand.workspace = true
 tokio.workspace = true
 tokio-tungstenite.workspace = true
-rustls = "0.23"
-rustls-pemfile = "2.2.0"
-native-tls = "0.2"  # Explicitly add for Connector::NativeTls
-anyhow="1.0"
+#rustls = "0.23"
+rustls.workspace = true
+#rustls-pemfile = "2.2.0"
+rustls-pemfile.workspace = true
+#native-tls = "0.2"  # Explicitly add for Connector::NativeTls
+native-tls.workspace = true
+#anyhow="1.0"
+anyhow.workspace=true
+clap.workspace=true
 
 [dev-dependencies]
 # for quickstart-chat and cursive-chat examples
diff --git a/crates/sdk/examples/quickstart-chat/main.rs b/crates/sdk/examples/quickstart-chat/main.rs
index 25cc5d5b..041ae165 100644
--- a/crates/sdk/examples/quickstart-chat/main.rs
+++ b/crates/sdk/examples/quickstart-chat/main.rs
@@ -5,20 +5,86 @@ use module_bindings::*;
 
 use spacetimedb_sdk::{credentials, DbContext, Error, Event, Identity, Status, Table, TableWithPrimaryKey};
 
+use clap::{Arg, Command};
 use std::path::PathBuf;
 
 
 // ## Define the main function
 
 fn main() {
-    // ### Parse command-line arguments for --cert into a PathBuf
-    let args: Vec<String> = std::env::args().collect();
-    let cert_path: Option<PathBuf> = args.iter()
-        .position(|arg| arg == "--cert")
-        .map(|i| args.get(i + 1).expect("Missing certificate path after --cert"))
-        .map(|s| PathBuf::from(s));
-    // Connect to the database with optional cert
-    let ctx = connect_to_db(cert_path);
+     // Parse command-line arguments with clap
+    let matches = Command::new("quickstart-chat")
+        .arg(
+            Arg::new("trust-server-cert")
+                .long("trust-server-cert")
+                .alias("cert")
+                .value_name("FILE")
+                .value_parser(clap::value_parser!(PathBuf))
+                .help("Path to PEM file containing certificates to trust for the server"),
+        )
+        .arg(
+            Arg::new("client-cert")
+                .long("client-cert")
+                .value_name("FILE")
+                .value_parser(clap::value_parser!(PathBuf))
+                .help("Path to the clients certificate (PEM) for mTLS"),
+        )
+        .arg(
+            Arg::new("client-key")
+                .long("client-key")
+                .value_name("FILE")
+                .value_parser(clap::value_parser!(PathBuf))
+                .requires("client-cert")
+                .help("Path to the clients private key (PEM) for mTLS"),
+        )
+        .arg(
+            Arg::new("trust-system-certs")
+                .long("trust-system-certs")
+                .action(clap::ArgAction::SetTrue)
+                .conflicts_with("no-trust-system-certs")
+                .help("Use system root certificates (default)"),
+        )
+        .arg(
+            Arg::new("no-trust-system-certs")
+                .long("no-trust-system-certs")
+                .alias("empty-trust-store")
+                .action(clap::ArgAction::SetTrue)
+                .conflicts_with("trust-system-certs")
+                .help("Use empty trust store (requires --trust-server-cert)"),
+        )
+        .get_matches();
+    //FIXME: check args./aliases
+
+    //FIXME: see if this 'if' makes sense:
+    // Validate no-trust-system-certs
+    if matches.get_flag("no-trust-system-certs") && !matches.contains_id("trust-server-cert") {
+        eprintln!("--no-trust-system-certs requires --trust-server-cert");
+        std::process::exit(1);
+    }
+
+//    // ### Parse command-line arguments for --cert into a PathBuf
+//    let args: Vec<String> = std::env::args().collect();
+//    let cert_path: Option<PathBuf> = args.iter()
+//        .position(|arg| arg == "--cert")
+//        .map(|i| args.get(i + 1).expect("Missing certificate path after --cert"))
+//        .map(|s| PathBuf::from(s));
+//    // Connect to the database with optional cert
+//    let ctx = connect_to_db(cert_path);
+
+    // Extract arguments
+    let trust_server_cert = matches.get_one::<PathBuf>("trust-server-cert").cloned();
+    let client_cert = matches.get_one::<PathBuf>("client-cert").cloned();
+    let client_key = matches.get_one::<PathBuf>("client-key").cloned();
+    let trust_system_certs = if matches.get_flag("no-trust-system-certs") {
+        Some(false)
+    } else if matches.get_flag("trust-system-certs") {
+        Some(true)
+    } else {
+        None // None here but deeper this means 'true', in db_connection.rs
+    };
+
+    // Connect to the database
+    let ctx = connect_to_db(trust_server_cert, client_cert, client_key, trust_system_certs);
 
     // Register callbacks to run in response to database events.
     register_callbacks(&ctx);
@@ -31,6 +97,13 @@ fn main() {
 
     // Handle CLI input
     user_input_loop(&ctx);
+    //gracefully exit, if Ctrl+D was pressed (Ctrl+Z on Windows)
+    let _=ctx.disconnect();
+    const TIMEOUT:u64=3;
+    let duration = std::time::Duration::from_secs(TIMEOUT);
+    std::thread::sleep(duration);
+    //not reached:
+    println!("Failed to disconnect from the database! Waited {} seconds.", TIMEOUT);
 }
 
 // ## Connect to the database
@@ -42,9 +115,15 @@ const HOST_PORT: &str = "localhost:3000";
 const DB_NAME: &str = "quickstart-chat";
 
 /// Load credentials from a file and connect to the database.
-fn connect_to_db(cert_path: Option<PathBuf>) -> DbConnection {
+fn connect_to_db(
+    cert_path: Option<PathBuf>,
+    client_cert: Option<PathBuf>,
+    client_key: Option<PathBuf>,
+    trust_system_certs: Option<impl Into<bool>>
+    ) -> DbConnection {
     // ### Construct URI with scheme based on cert presence
-    let scheme = if cert_path.is_some() { "https" } else { "http" };
+    let expects_https=cert_path.is_some() || client_cert.is_some() || client_key.is_some();
+    let scheme = if expects_https { "https" } else { "http" };
     let uri = format!("{}://{}", scheme, HOST_PORT);
 
 //    let mut builder=
@@ -73,6 +152,12 @@ fn connect_to_db(cert_path: Option<PathBuf>) -> DbConnection {
 //         .expect("Failed to connect")
         // ### Add trusted cert if provided
         .with_trusted_cert(cert_path)
+        // Add client identity (TLS)
+        .with_client_cert(client_cert)
+        .with_client_key(client_key)
+        // Configure trust store
+        .with_trust_system_certs(trust_system_certs)
+
         // Finalize configuration and connect!
         .build()
         .expect("Failed to connect")
diff --git a/crates/sdk/src/db_connection.rs b/crates/sdk/src/db_connection.rs
index fbc2dd57..b3c955a8 100644
--- a/crates/sdk/src/db_connection.rs
+++ b/crates/sdk/src/db_connection.rs
@@ -44,6 +44,7 @@ use tokio::{
     runtime::{self, Runtime},
     sync::Mutex as TokioMutex,
 };
+use std::path::PathBuf;
 
 pub(crate) type SharedCell<T> = Arc<StdMutex<T>>;
 
@@ -750,6 +751,9 @@ pub struct DbConnectionBuilder<M: SpacetimeModule> {
     params: WsParams,
 
     trusted_cert: Option<std::path::PathBuf>,
+    client_cert: Option<std::path::PathBuf>,
+    client_key: Option<std::path::PathBuf>,
+    trust_system_certs: Option<bool>,
 }
 
 /// This process's global connection ID, which will be attacked to all connections it makes.
@@ -797,6 +801,9 @@ impl<M: SpacetimeModule> DbConnectionBuilder<M> {
             on_disconnect: None,
             params: <_>::default(),
             trusted_cert: None,
+            client_cert: None,
+            client_key: None,
+            trust_system_certs: None,
         }
     }
 
@@ -845,6 +852,10 @@ but you must call one of them, or else the connection will never progress.
                 get_connection_id(),
                 self.params,
                 self.trusted_cert.as_ref(),
+                self.client_cert.as_ref(),
+                self.client_key.as_ref(),
+                //XXX: trust system/root store by default, for clients when verifying server certs!
+                self.trust_system_certs.unwrap_or(true),
             ))
         })
         .map_err(|source| crate::Error::FailedToConnect {
@@ -901,6 +912,29 @@ but you must call one of them, or else the connection will never progress.
         self
     }
 
+    pub fn with_client_cert(mut self, cert: Option<impl Into<PathBuf>>) -> Self {
+        self.client_cert = cert.map(|c| c.into());
+        self
+    }
+
+    pub fn with_client_key(mut self, key: Option<impl Into<PathBuf>>) -> Self {
+        self.client_key = key.map(|c| c.into());
+        self
+    }
+
+//    pub fn with_trust_system_certs(mut self, trust: bool) -> Self {
+//        self.trust_system_certs = trust;
+//        self
+//    }
+//    pub fn with_trust_system_certs(mut self, trust: Option<impl Into<Option<bool>>>) -> Self {
+//        self.trust_system_certs = trust.map(|t| t.into()).unwrap_or(None);
+//        self
+//    }
+    pub fn with_trust_system_certs(mut self, trust: Option<impl Into<bool>>) -> Self {
+        self.trust_system_certs = trust.map(|t| t.into());
+        self
+    }
+
     /// Set the name or identity of the remote module.
     pub fn with_module_name(mut self, name_or_identity: impl Into<String>) -> Self {
         self.module_name = Some(name_or_identity.into());
diff --git a/crates/sdk/src/websocket.rs b/crates/sdk/src/websocket.rs
index 90148b84..006aba31 100644
--- a/crates/sdk/src/websocket.rs
+++ b/crates/sdk/src/websocket.rs
@@ -220,6 +220,9 @@ impl WsConnection {
         connection_id: ConnectionId,
         params: WsParams,
         trusted_cert: Option<&std::path::PathBuf>,
+        client_cert: Option<&std::path::PathBuf>,
+        client_key: Option<&std::path::PathBuf>,
+        trust_system_certs: bool,
     ) -> Result<Self, WsError> {
         let req = make_request(host, db_name, token, connection_id, params)?;
 
@@ -227,7 +230,6 @@ impl WsConnection {
         let uri = req.uri().clone();
 
         let host = uri.clone(); //shadow, and it's thus wss:// not https://
-        use native_tls::TlsConnector;
         use std::sync::Arc;
         use tokio::net::TcpStream;
         use tokio_tungstenite::{client_async_tls_with_config, Connector, MaybeTlsStream, WebSocketStream};
@@ -253,12 +255,101 @@ impl WsConnection {
 
         let connector = if host.scheme_str() == Some("wss") {
             //FIXME: --cert implies wss, or do we want to allow --cert even for ws instead of error-ing!
-            let mut builder = TlsConnector::builder();
-            if let Some(cert_path) = trusted_cert {
-                if let Some(cert) = spacetimedb_lib::load_root_cert(Some(cert_path.as_path())).await? {
-                    builder.add_root_certificate(cert);
-                }
+            let mut builder = native_tls::TlsConnector::builder();
+
+            // Validate trust store
+            if !trust_system_certs && trusted_cert.is_none() {
+                return Err(WsError::Tungstenite {
+                    uri: uri.clone(),
+                    source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                                std::io::ErrorKind::Other,
+                                "--no-trust-system-root-store requires --trust-server-cert",
+                    ))),
+                });
+            }
+            if !trust_system_certs {
+                eprintln!("Not trusting system/root cert store.");
+                builder.disable_built_in_roots(true);
             }
+
+            if let Some(cert_path) = trusted_cert {
+                // This is the server's self-signed cert or local CA's cert that signed the server's cert.
+                let cert_data = spacetimedb_lib::read_file_limited(cert_path)
+                    .await?;
+                //FIXME: fix this and 2 more below.
+//                    .map_err(|e| WsError::Tungstenite {
+//                        uri: uri.clone(),
+//                        source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(e)),
+//                    })?;
+                let certs = rustls_pemfile::certs(&mut std::io::Cursor::new(cert_data))
+                    .collect::<Result<Vec<_>, _>>()
+                    .map_err(|e| WsError::Tungstenite {
+                        uri: uri.clone(),
+                        source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                                    std::io::ErrorKind::Other,
+                                    format!("Failed to parse trust certificates: {}", e),
+                        ))),
+                    })?;
+                if certs.is_empty() {
+                    return Err(WsError::Tungstenite {
+                        uri: uri.clone(),
+                        source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                                    std::io::ErrorKind::Other,
+                                    format!("No valid certificates in {}", cert_path.display()),
+                        ))),
+                    });
+                }//if
+                for cert in certs {
+                    builder
+                        .add_root_certificate(native_tls::Certificate::from_der(&cert).map_err(|e| WsError::Tungstenite {
+                            uri: uri.clone(),
+                            source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                                        std::io::ErrorKind::Other,
+                                        e,
+                            ))),
+                        })?);
+                }//for
+            }//if
+
+            // Configure mTLS
+            if let Some(cert_path) = client_cert {
+                let key_path = client_key.ok_or_else(|| WsError::Tungstenite {
+                    uri: uri.clone(),
+                    source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                                std::io::ErrorKind::Other,
+                                "--client-key is required with --client-cert",
+                    ))),
+                })?;
+                let cert_data = spacetimedb_lib::read_file_limited(cert_path)
+                    .await?;
+//                    .map_err(|e| WsError::Tungstenite {
+//                        uri: uri.clone(),
+//                        source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(e)),
+//                    })?;
+                let key_data = spacetimedb_lib::read_file_limited(key_path)
+                    .await?;
+//                    .map_err(|e| WsError::Tungstenite {
+//                        uri: uri.clone(),
+//                        source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(e)),
+//                    })?;
+                //use anyhow::Context;
+                let identity = native_tls::Identity::from_pkcs8(&cert_data, &key_data)
+//                    .context("Failed to parse client cert/key")?;
+//                    //XXX: that shows: error: "Failed to parse client cert/key" only!
+                    .map_err(|e| WsError::Tungstenite {
+                    uri: uri.clone(),
+                    //this shows: error: "Failed to parse client cert/key: expected PKCS#8 PEM"
+                    source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
+                                std::io::ErrorKind::Other,
+                                // {:#?} here would show only "NotPkcs8"
+                                // {} here shows "expected PKCS#8 PEM"
+                                format!("Failed to parse client cert/key: {}", e),
+                    //TODO: make better error msgs like these in other places that use .context()
+                    ))),
+                })?;
+                builder.identity(identity);
+            } //if
+
             let tls_connector = builder.build().map_err(|e| WsError::Tungstenite {
                 uri: uri.clone(),
                 source: Arc::new(tokio_tungstenite::tungstenite::Error::Io(std::io::Error::new(
diff --git a/crates/standalone/Cargo.toml b/crates/standalone/Cargo.toml
index beef27b7..c83862da 100644
--- a/crates/standalone/Cargo.toml
+++ b/crates/standalone/Cargo.toml
@@ -31,13 +31,19 @@ async-trait.workspace = true
 axum.workspace = true
 
 # Add this for TLS support
-#axum-server = "0.6"  # Compatible with axum 0.7.9
-#axum-server = "0.7"  # Compatible with axum 0.7.9
-axum-server = { version = "0.7.2", features = ["tls-rustls"] }
+#axum-server = { version = "0.7.2", features = ["tls-rustls"] }
+axum-server.workspace=true
+#rustls-platform-verifier.workspace=true
+rustls-native-certs.workspace=true
+x509-parser.workspace=true
+sha2.workspace=true
 
-ring = "0.17"  # explicitly add this for the CryptoProvider, even tho it's included transitively.
-rustls= { version="0.23", default-features = true, features=[ "ring" ] }
-rustls-pemfile = "2.2"
+#ring = "0.17"  # explicitly add this for the CryptoProvider, even tho it's included transitively.
+ring.workspace=true
+#rustls= { version="0.23", default-features = true, features=[ "ring" ] }
+rustls.workspace=true
+#rustls-pemfile = "2.2"
+rustls-pemfile.workspace=true
 
 clap = { workspace = true, features = ["derive", "string"] }
 dirs.workspace = true
diff --git a/crates/standalone/src/subcommands/start.rs b/crates/standalone/src/subcommands/start.rs
index fd3e2ae3..5abcea37 100644
--- a/crates/standalone/src/subcommands/start.rs
+++ b/crates/standalone/src/subcommands/start.rs
@@ -1,7 +1,6 @@
 use std::sync::Arc;
 use std::path::Path;
 use std::path::PathBuf;
-use tokio::io::AsyncReadExt;
 use rustls::pki_types::{CertificateDer, PrivateKeyDer};
 use rustls::pki_types::PrivatePkcs8KeyDer;
 
@@ -19,6 +18,8 @@ use spacetimedb_client_api::routes::router;
 use spacetimedb_paths::cli::{PrivKeyPath, PubKeyPath};
 use spacetimedb_paths::server::ServerDataDir;
 
+pub use spacetimedb_lib::read_file_limited;
+
 pub fn cli() -> clap::Command {
     clap::Command::new("start")
         .about("Starts a standalone SpacetimeDB instance")
@@ -71,60 +72,77 @@ pub fn cli() -> clap::Command {
         .arg(Arg::new("in_memory").long("in-memory").action(SetTrue).help(
             "If specified the database will run entirely in memory. After the process exits all data will be lost.",
         ))
-        .arg(Arg::new("ssl").long("ssl").alias("tls").alias("https").alias("secure").action(clap::ArgAction::SetTrue).help("enables the standalone server to listen in SSL mode, ie. use https instead of http to connect to it. Aliases --tls, --ssl, --secure, or --https."))
+
+        .arg(spacetimedb_lib::client_trust_cert())
+        .arg(spacetimedb_lib::client_trust_system_root_store())
+        .arg(spacetimedb_lib::client_no_trust_system_root_store())
+
         .arg(
-            spacetimedb_lib::cert()
+            Arg::new("ssl")
+            .long("ssl")
+            .alias("tls")
+            .alias("https")
+            .alias("secure")
+            .action(clap::ArgAction::SetTrue)
+            .help("enables the standalone server to listen in SSL mode, ie. use https instead of http to connect to it. Aliases --tls, --ssl, --secure, or --https. While in this mode, plaintext connections aren't supported, only SSL/TLS.")
+        )
+        .arg(
+//            spacetimedb_lib::cert()
+            clap::Arg::new("server-cert")
+            .long("server-cert")
+            .alias("cert")
+            .alias("server-public-cert")
+            .value_name("FILE")
+            .action(clap::ArgAction::Set)
+            .value_parser(clap::value_parser!(std::path::PathBuf))
+            .required(false)
             .requires("ssl")
-            .help("--cert server.crt: The server sends this to clients during the TLS handshake. ie. server's certificate which contains its public key, which if it's self-signed then this is the file that you must pass to clients via --cert when talking to the server from a client(or the cli), or if signed by a local CA then pass that CA's cert to your clients instead, in order to can trust this server from a client connection. Otherwise, you don't have to pass anything to clients if this cert was signed by a public CA like Let's Encrypt.")
+            .help("--cert server.crt: The server sends this to clients during the TLS handshake. ie. server's certificate(in PEM format), which if it's self-signed then this is the file that you must pass to clients via --cert when talking to the server from a client(or the cli), or if signed by a local CA then pass that CA's cert to your clients instead, in order to can trust this server from a client connection. Otherwise, you don't have to pass anything to clients if this cert was signed by a public CA like Let's Encrypt.")
         )
-        .arg(Arg::new("key").long("key").requires("ssl").value_name("FILE")
+        .arg(
+            Arg::new("server-key")
+            .long("server-key")
+            .alias("server-private-key")
+            .alias("private-key")
+            .alias("key")
+            .requires("ssl")
+            .requires("server-cert")
+            .value_name("FILE")
             .action(clap::ArgAction::Set)
             .value_parser(clap::value_parser!(PathBuf))
-            .help("--key server.key: The server's private key used to decrypt and sign responses."))
+            .help("--key server.key: The server's private key used to decrypt and sign responses. Used for SSL/TLS connections ie. https"))
     // .after_help("Run `spacetime help start` for more detailed information.")
 }
 
-/// Asynchronously reads a file with a maximum size limit of 1 MiB.
-async fn read_file_limited(path: &Path) -> anyhow::Result<Vec<u8>> {
-    const MAX_SIZE: usize = 1_048_576; // 1 MiB
-
-    let file = tokio::fs::File::open(path)
-        .await
-        .map_err(|e| anyhow::anyhow!("Failed to open file {}: {}", path.display(), e))?;
-    let metadata = file
-        .metadata()
-        .await
-        .map_err(|e| anyhow::anyhow!("Failed to read metadata for {}: {}", path.display(), e))?;
-
-    if metadata.len() > MAX_SIZE as u64 {
-        return Err(anyhow::anyhow!(
-            "File {} exceeds maximum size of {} bytes",
-            path.display(),
-            MAX_SIZE
-        ));
-    }
-
-    let mut reader = tokio::io::BufReader::new(file);
-    let mut data = Vec::with_capacity(metadata.len() as usize);
-    reader
-        .read_to_end(&mut data)
-        .await
-        .map_err(|e| anyhow::anyhow!("Failed to read file {}: {}", path.display(), e))?;
-
-    Ok(data)
-}
 
 /// Loads certificates from a PEM file.
-async fn load_certs(file_path: &Path) -> anyhow::Result<Vec<CertificateDer<'static>>> {
+async fn load_certs(file_path: &Path, expected_num: Option<usize>) -> anyhow::Result<Vec<CertificateDer<'static>>> {
     let data = read_file_limited(file_path).await?;
     let certs: Vec<CertificateDer<'static>> = rustls_pemfile::certs(&mut std::io::Cursor::new(data))
         .collect::<Result<Vec<_>, _>>()
         .map_err(|e| anyhow::anyhow!("Failed to parse certificates from {}: {:?}", file_path.display(), e))?;
-    match certs.len() {
-        0 => Err(anyhow::anyhow!("No certificates found in file {}", file_path.display())),
-        1 => Ok(certs),
-        _ => Err(anyhow::anyhow!("Multiple certificates found in file {}; only one certificate is expected.", file_path.display())),
+    if certs.len() < 1 {
+        //Err(anyhow::anyhow!("No certificate(s) found in file {}", file_path.display()))
+        eprintln!("WARNING: No certificate(s) found in file {}", file_path.display())
+    }
+//    } else {
+//        Ok(certs)
+//    }
+    if let Some(expected_num)=expected_num {
+        let len=certs.len();
+        if len == expected_num {
+            return Ok(certs);
+        } else {
+            return Err(anyhow::anyhow!("{} certificate(s) found in file {}, but expected {} cert(s) exactly!", len, file_path.display(), expected_num));
+        }
+    } else {
+        return Ok(certs);
     }
+//    match certs.len() {
+//        0 => Err(anyhow::anyhow!("No certificate(s) found in file {}, expected {} cert(s)", file_path.display(), expected_num)),
+//        expected_num => Ok(certs),
+//        _ => Err(anyhow::anyhow!("Multiple certificates found in file {}; only {} certificate(s) is expected.", file_path.display(), expected_num)),
+//    }
 }
 
 /// Loads a private key from a PEM file.
@@ -133,6 +151,11 @@ async fn load_private_key(file_path: &Path) -> anyhow::Result<PrivateKeyDer<'sta
     let keys: Vec<PrivatePkcs8KeyDer<'static>> = rustls_pemfile::pkcs8_private_keys(&mut std::io::Cursor::new(data))
         .collect::<Result<Vec<_>, _>>()
         .map_err(|e| anyhow::anyhow!("Failed to parse private keys from {}: {:?}", file_path.display(), e))?;
+//    if keys.len() < 1 {
+//        Err(anyhow::anyhow!("No private key(s) found in file {}", file_path.display())),
+//    } else {
+//        Ok(keys)
+//    }
     match keys.len() {
         0 => Err(anyhow::anyhow!("No private key found in file {}", file_path.display())),
         1 => Ok(PrivateKeyDer::Pkcs8(keys.into_iter().next().unwrap())),
@@ -221,7 +244,7 @@ pub async fn exec(args: &ArgMatches) -> anyhow::Result<()> {
     };
     let db_config = Config { storage };
 
-    banner();
+    //banner();//FIXME: bring this back
     let exe_name = std::env::current_exe()?;
     let exe_name = exe_name.file_name().unwrap().to_str().unwrap();
     println!("{} version: {}", exe_name, env!("CARGO_PKG_VERSION"));
@@ -282,13 +305,85 @@ pub async fn exec(args: &ArgMatches) -> anyhow::Result<()> {
         rustls::crypto::CryptoProvider::install_default(custom_crypto_provider())
             .map_err(|e| anyhow::anyhow!("Failed to install custom CryptoProvider: {:?}", e))?;
 
-        let cert_path: &Path = args.get_one::<PathBuf>("cert").context("Missing --cert for SSL")?.as_path();
-        let key_path: &Path = args.get_one::<PathBuf>("key").context("Missing --key for SSL")?.as_path();
+        let cert_path: &Path = args.get_one::<PathBuf>("server-cert").context("Missing --cert for SSL")?.as_path();
+        let key_path: &Path = args.get_one::<PathBuf>("server-key").context("Missing --key for SSL")?.as_path();
 
         // Load certificate and private key with file size limit
-        let cert_chain = load_certs(cert_path).await?;
+        let cert_chain = load_certs(cert_path,Some(1)).await?;
         let private_key = load_private_key(key_path).await?;
 
+        // XXX: No revocation status is checked, so a valid-but-revoked cert would pass. (because
+        // code doesn't use .with_crls() )
+
+        // Initialize root store
+        let mut roots = rustls::RootCertStore::empty();
+
+        // Handle system root certificates
+        let trust_system = args.get_flag("client-trust-system-root-store");
+
+        use x509_parser::prelude::FromDer;
+        use sha2::{Digest, Sha256};
+        //use openssl::sha::{Sha256, Digest};
+
+        if trust_system {
+            //unusual to trust system store with mTLS
+            //load system trust store certs
+            let cr:rustls_native_certs::CertificateResult = rustls_native_certs::load_native_certs();
+            if cr.errors.len() > 0 {
+                return Err(anyhow::anyhow!("Failed to load system certs: {:#?}", cr.errors));
+            }
+            let system_store = cr.expect("impossible now: failed to load system certs.");
+            for cert in system_store {
+                // Parse and log cert details
+                if let Ok((_, parsed)) = x509_parser::prelude::X509Certificate::from_der(cert.as_ref()) {
+                    let subject = parsed.subject().to_string();
+                    let issuer = parsed.issuer().to_string();
+                    let not_after = parsed.validity().not_after.to_string();
+                    let serial = parsed.serial.to_string();
+                    let fingerprint = format!("{:x}", Sha256::digest(cert.as_ref()));
+                    log::info!(
+                        "System cert: subject={}, issuer={}, serial={}, expires={}, fingerprint={}",
+                        subject, issuer, serial, not_after, fingerprint
+                    );
+                } else {
+                    log::warn!("Failed to parse system cert");
+                }
+
+                roots.add(cert)?;
+            }
+        }
+
+        // Load custom client trust certificates
+        if let Some(client_trust_path) = args.get_one::<PathBuf>("client-trust-cert") {
+            let client_certs = load_certs(client_trust_path, None).await?;
+            for cert in client_certs {
+                // Parse and log cert details
+                if let Ok((_, parsed)) = x509_parser::prelude::X509Certificate::from_der(cert.as_ref()) {
+                    let subject = parsed.subject().to_string();
+                    let issuer = parsed.issuer().to_string();
+                    let not_after = parsed.validity().not_after.to_string();
+                    let serial = parsed.serial.to_string();
+                    let fingerprint = format!("{:x}", Sha256::digest(cert.as_ref()));
+                    log::info!(
+                        "Custom cert: subject={}, issuer={}, serial={}, expires={}, fingerprint={}",
+                        subject, issuer, serial, not_after, fingerprint
+                    );
+                } else {
+                    log::warn!("Failed to parse custom cert from file {}", client_trust_path.display());
+                }
+                roots.add(cert)?;
+            }
+        }
+
+        // Configure client authentication (mTLS)
+        let client_auth: Arc<dyn rustls::server::danger::ClientCertVerifier> = if args.get_one::<PathBuf>("client-trust-cert").is_some() || trust_system {
+            rustls::server::WebPkiClientVerifier::builder(roots.into()) //Arc::new(roots))
+                .build()
+                .map_err(|e| anyhow::anyhow!("Failed to build client verifier: {}", e))?
+        } else {
+            rustls::server::WebPkiClientVerifier::no_client_auth()
+        };
+
         // Create ServerConfig with secure settings
         let config=
             rustls::ServerConfig::builder_with_protocol_versions(&[
@@ -296,7 +391,8 @@ pub async fn exec(args: &ArgMatches) -> anyhow::Result<()> {
 //                &rustls::version::TLS12,
             ])
 //            rustls::ServerConfig::builder() // using this instead, wouldn't restrict proto versions.
-            .with_no_client_auth()
+            .with_client_cert_verifier(client_auth)
+            //.with_no_client_auth() ^
             .with_single_cert(cert_chain, private_key)
             .map_err(|e| anyhow::anyhow!("Failed to set certificates from files pub:'{}', priv:'{}', err: {}", cert_path.display(), key_path.display(), e))?;
 
@@ -320,48 +416,3 @@ pub async fn exec(args: &ArgMatches) -> anyhow::Result<()> {
     Ok(())
 }
 
-fn banner() {
-    println!(
-        r#"
-
-                                                                                                       
-                                                                                                       
-                                                                                                    
-                                                                                                    
-                                                                            
-                                         88888888888888888888    8                           
-                                      8888888888    88                             
-                                    88888      888                              
-                                   88888              888888                              
-                                  8888                 888888                               
-                                 8888                      8888                               
-                                 8888                       8888                               
-                                 88888  8                       8  88888                               
-                                 8888                       8888                               
-                                 8888                      8888                               
-                                 888888                 8888                                
-                                888888              88888                                 
-                                888      88888                                  
-                               88    8888888888                                    
-                             8    88888888888888888888                                       
-                                                                            
-                                                                                                    
-                                                                                                    
-                                                                                                       
-                                                                                                       
-  .d8888b.                                     888    d8b                        8888888b.  888888b.   
- d88P  Y88b                                    888    Y8P                        888  "Y88b 888  "88b  
- Y88b.                                         888                               888    888 888  .88P  
-  "Y888b.   88888b.   8888b.   .d8888b .d88b.  888888 888 88888b.d88b.   .d88b.  888    888 8888888K.  
-     "Y88b. 888 "88b     "88b d88P"   d8P  Y8b 888    888 888 "888 "88b d8P  Y8b 888    888 888  "Y88b 
-       "888 888  888 .d888888 888     88888888 888    888 888  888  888 88888888 888    888 888    888 
- Y88b  d88P 888 d88P 888  888 Y88b.   Y8b.     Y88b.  888 888  888  888 Y8b.     888  .d88P 888   d88P 
-  "Y8888P"  88888P"  "Y888888  "Y8888P "Y8888   "Y888 888 888  888  888  "Y8888  8888888P"  8888888P"  
-            888                                                                                        
-            888                                                                                        
-            888                                                                                        
-                                  "Multiplayer at the speed of light"                                  
-
-    "#
-    )
-}
